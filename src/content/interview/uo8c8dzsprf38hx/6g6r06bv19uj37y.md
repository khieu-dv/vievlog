---
title: "Design Patterns - Câu Hỏi Phỏng Vấn Backend (1-10)"
postId: "6g6r06bv19uj37y"
category: "BackEnd Interview"
created: "2/9/2025"
updated: "2/9/2025"
---

# Design Patterns - Câu Hỏi Phỏng Vấn Backend (1-10)



### Câu 1: Tại sao biến global và static không nên dùng?

**Vấn đề:**
- **Khó bảo trì:** Các module phụ thuộc lẫn nhau qua biến global, dẫn đến khó thay đổi code.
- **Khó kiểm thử:** Biến global gây khó khăn khi test riêng lẻ, dễ dẫn đến lỗi không rõ nguyên nhân.
- **Xung đột tên:** Nhiều module dùng cùng tên biến, gây khó debug.
- **Vi phạm đóng gói:** Biến global lộ thông tin, không kiểm soát được truy cập.
- **Rò rỉ bộ nhớ:** Biến global tồn tại suốt vòng đời ứng dụng, không được dọn dẹp.

**Giải pháp:**
- Sử dụng **Dependency Injection** để truyền phụ thuộc.
- Áp dụng **Singleton Pattern** (cẩn thận khi dùng).
- Sử dụng **Module Pattern** hoặc **Configuration Objects**.

\---

### Câu 2: Inversion of Control (IoC) là gì?

**Định nghĩa:**
IoC là nguyên tắc thiết kế giúp đối tượng không tự tạo phụ thuộc mà nhận chúng từ bên ngoài.

**Ví dụ:**
- **Trước IoC:** 
  ```java
  class OrderService {
      private EmailService emailService = new EmailService(); // Phụ thuộc cứng
      void processOrder(Order order) {
          emailService.sendConfirmation(order);
      }
  }
  ```
- **Sau IoC:**
  ```java
  class OrderService {
      private EmailService emailService;
      OrderService(EmailService emailService) { // Nhận phụ thuộc từ ngoài
          this.emailService = emailService;
      }
      void processOrder(Order order) {
          emailService.sendConfirmation(order);
      }
  }
  ```

**Lợi ích:**
- Giảm sự phụ thuộc giữa các module.
- Dễ kiểm thử (dùng mock).
- Linh hoạt khi thay đổi cấu hình.
- Code dễ bảo trì.

**Cách thực hiện:**
- Tiêm phụ thuộc qua constructor, setter, hoặc interface.
- Sử dụng Service Locator (ít phổ biến hơn).

\---

### Câu 3: Law of Demeter là gì?

**Định nghĩa:**
Law of Demeter yêu cầu một đối tượng chỉ nên tương tác với các đối tượng "gần gũi" (như chính nó, tham số, hoặc thành phần trực tiếp).

**Ví dụ vi phạm:**
```java
class Order {
    void processPayment() {
        this.customer.getWallet().getPaymentMethod().charge(amount); // Truy cập quá sâu
    }
}
```

**Ví dụ đúng:**
```java
class Order {
    void processPayment() {
        customer.chargePayment(amount); // Chuyển giao trách nhiệm
    }
}
class Customer {
    void chargePayment(double amount) {
        wallet.processPayment(amount); // Xử lý chi tiết
    }
}
```

**Lợi ích:**
- Giảm sự phụ thuộc giữa các đối tượng.
- Dễ bảo trì và tái cấu trúc code.
- Tăng tính đóng gói.

\---

### Câu 4: Hạn chế của Active Record Pattern?

**Hạn chế:**
- **Phụ thuộc database:** Logic nghiệp vụ trộn lẫn với logic database, khó thay đổi schema.
- **Vi phạm SRP:** Một class vừa lưu data vừa xử lý database, gây phức tạp.
- **Khó kiểm thử:** Cần kết nối database để test, khó mock.
- **Khó mở rộng:** Với logic phức tạp, class trở nên cồng kềnh, hiệu năng kém.

**Ví dụ:**
```ruby
class User < ActiveRecord::Base
    def full_name
        "#{first_name} #{last_name}"
    end
    def send_welcome_email
        UserMailer.welcome_email(self).deliver
    end
end
```

**Khi nào dùng:**
- Ứng dụng CRUD đơn giản.
- Dự án prototype hoặc MVP.

\---

### Câu 5: Data Mapper Pattern khác Active Record như thế nào?

**Data Mapper:**
- Tách biệt đối tượng nghiệp vụ khỏi database.
- Một class riêng (Mapper) xử lý thao tác database.
- Đối tượng nghiệp vụ không biết về lưu trữ.

**Ví dụ:**
```java
class User {
    private String name;
    void changeEmail(String newEmail) {
        if (isValidEmail(newEmail)) {
            this.email = newEmail;
        }
    }
}
class UserMapper {
    User findById(Long id) { /* Tìm trong DB */ }
    void save(User user) { /* Lưu vào DB */ }
}
```

**So sánh:**

| Tiêu chí | Active Record | Data Mapper |
|----------|---------------|-------------|
| Phụ thuộc DB | Cao | Thấp |
| Kiểm thử | Khó | Dễ |
| Độ phức tạp | Đơn giản | Phức tạp hơn |
| Hiệu năng | Có thể chậm | Tối ưu hơn |
| Logic nghiệp vụ | Trộn với DB | Tách biệt |

**Khi nào dùng Data Mapper:**
- Ứng dụng có logic nghiệp vụ phức tạp.
- Áp dụng Domain-Driven Design.
- Cần kiểm thử dễ dàng.

\---

### Câu 6: Vấn đề Null Reference và cách giải quyết?

**Vấn đề:**
NullPointerException gây lỗi runtime, khó debug, cần kiểm tra null thường xuyên.

**Ví dụ:**
```java
String getUserCity(Long userId) {
    User user = userRepository.findById(userId);
    return user.getAddress().getCity(); // Có thể lỗi null
}
```

**Giải pháp:**
1. **Null Object Pattern:**
   ```java
   class NullAddress extends Address {
       String getCity() { return "Unknown"; }
   }
   Address getAddress() {
       return address != null ? address : new NullAddress();
   }
   ```
2. **Optional/Maybe Types:**
   ```java
   Optional<String> getUserCity(Long userId) {
       return userRepository.findById(userId)
           .map(User::getAddress)
           .map(Address::getCity);
   }
   ```
3. **Nullable Annotations:**
   ```java
   @Nullable String getCity(@NonNull Long userId) {
       // Công cụ phân tích tĩnh phát hiện lỗi
   }
   ```

**Gợi ý:**
- Tránh trả về null, dùng Optional.
- Kiểm tra input sớm.
- Sử dụng giá trị mặc định khi phù hợp.

\---

### Câu 7: So sánh Inheritance và Composition?

**Inheritance (Kế thừa):**
- **Ưu điểm:** Tái sử dụng code dễ, hỗ trợ đa hình, thể hiện quan hệ IS-A.
- **Nhược điểm:** Phụ thuộc chặt vào lớp cha, khó thay đổi behavior lúc runtime, dễ gây lỗi khi lớp cha thay đổi.

**Composition (Tổ hợp):**
- **Ưu điểm:** Linh hoạt, dễ thay đổi behavior, thể hiện quan hệ HAS-A, tránh được hierarchy phức tạp.
- **Nhược điểm:** Cần viết nhiều code lặp lại để chuyển giao.

**Ví dụ:**
- **Inheritance:**
  ```java
  class Car extends Vehicle { /* Phụ thuộc vào Vehicle */ }
  ```
- **Composition:**
  ```java
  class Car {
      private Engine engine;
      void start() { engine.start(); } // Chuyển giao
  }
  ```

**Nguyên tắc:** Ưu tiên Composition hơn Inheritance vì linh hoạt, dễ test và bảo trì.

\---

### Câu 8: Anti-Corruption Layer là gì?

**Định nghĩa:**
Anti-Corruption Layer (ACL) là lớp bảo vệ domain model khỏi ảnh hưởng của hệ thống bên ngoài, chuyển đổi dữ liệu giữa các hệ thống.

**Vấn đề:**
- Hệ thống bên ngoài có mô hình dữ liệu khác.
- Thay đổi API bên ngoài có thể phá hủy domain model.

**Ví dụ:**
- API bên ngoài trả về:
  ```json
  { "usr_id": "123", "usr_nm": "John Doe", "usr_sts": "A" }
  ```
- ACL chuyển đổi:
  ```java
  class UserAPIAdapter {
      User adaptExternalUser(ExternalUserData data) {
          return User.builder()
              .id(Long.valueOf(data.getUsrId()))
              .name(data.getUsrNm())
              .status("A".equals(data.getUsrSts()) ? UserStatus.ACTIVE : UserStatus.INACTIVE)
              .build();
      }
  }
  ```

**Lợi ích:**
- Giữ domain model sạch.
- Cách ly khỏi thay đổi bên ngoài.
- Dễ bảo trì, rõ ranh giới.

\---

### Câu 9: Singleton Pattern có thread-safe không? Cách triển khai?

**Vấn đề:** Singleton thông thường không thread-safe, có thể gây lỗi khi nhiều thread truy cập cùng lúc.

**Ví dụ không thread-safe:**
```java
class Singleton {
    private static Singleton instance;
    static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Lỗi nếu nhiều thread
        }
        return instance;
    }
}
```

**Cách triển khai thread-safe:**
1. **Synchronized Method:**
   ```java
   class Singleton {
       private static Singleton instance;
       static synchronized Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ```
2. **Double-Checked Locking:**
   ```java
   class Singleton {
       private static volatile Singleton instance;
       static Singleton getInstance() {
           if (instance == null) {
               synchronized (Singleton.class) {
                   if (instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```
3. **Enum Singleton (khuyến nghị):**
   ```java
   enum Singleton {
       INSTANCE;
       void doSomething() { /* Logic */ }
   }
   ```

\---

### Câu 10: DRY Principle là gì và cách áp dụng?

**Định nghĩa:**
DRY (Don't Repeat Yourself) yêu cầu mỗi phần logic chỉ nên xuất hiện một lần trong hệ thống.

**Vấn đề của lặp code:**
- Khó bảo trì.
- Lỗi xuất hiện ở nhiều nơi.
- Mất thời gian phát triển.

**Cách áp dụng:**
1. **Tách hàm riêng:**
   ```java
   void applyDiscount(Order order) {
       if (order.getAmount() > 1000) {
           order.setDiscount(0.1);
       }
   }
   ```
2. **Dùng hằng số:**
   ```java
   static final double DISCOUNT_THRESHOLD = 1000.0;
   static final double DISCOUNT_RATE = 0.1;
   ```
3. **Tạo component tái sử dụng:**
   ```java
   class ValidationUtils {
       static boolean isValidEmail(String email) {
           return email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
       }
   }
   ```
4. **Dùng file cấu hình:**
   ```yaml
   business:
     discount:
       threshold: 1000.0
       rate: 0.1
   ```

**Lưu ý:**
- Không lạm dụng DRY, tránh abstraction quá sớm.
- Cân bằng giữa DRY và tính dễ đọc.



---

*Post ID: 6g6r06bv19uj37y*  
*Category: BackEnd Interview*  
*Created: 2/9/2025*  
*Updated: 2/9/2025*
