---
title: "Danh S√°ch Li√™n K·∫øt ƒê√¥i (Doubly Linked List)"
postId: "pjaolesiv5j2gta"
category: "Data Structures"
created: "19/8/2025"
updated: "2/9/2025"
---

# Danh S√°ch Li√™n K·∫øt ƒê√¥i (Doubly Linked List)



## üéØ M·ª•c Ti√™u B√†i H·ªçc

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:
- Hi·ªÉu **Danh S√°ch Li√™n K·∫øt ƒê√¥i** l√† g√¨ v√† c√°ch n√≥ ho·∫°t ƒë·ªông.
- So s√°nh ƒë∆∞·ª£c v·ªõi Danh S√°ch Li√™n K·∫øt ƒê∆°n (Singly Linked List).
- Bi·∫øt c√°ch vi·∫øt code cho Doubly Linked List b·∫±ng JavaScript.
- √Åp d·ª•ng v√†o c√°c b√†i to√°n th·ª±c t·∫ø nh∆∞ tr√¨nh duy·ªát web hay tr√¨nh ph√°t nh·∫°c.
- Hi·ªÉu t·ªëc ƒë·ªô c·ªßa c√°c thao t√°c ch√≠nh.

## üìù N·ªôi Dung Chi Ti·∫øt

### Kh√°i Ni·ªám C∆° B·∫£n

**Danh S√°ch Li√™n K·∫øt ƒê√¥i (Doubly Linked List)** gi·ªëng nh∆∞ m·ªôt chu·ªói c√°c h·ªôp (node), m·ªói h·ªôp ch·ª©a d·ªØ li·ªáu v√† c√≥ hai d√¢y n·ªëi:
- M·ªôt d√¢y n·ªëi ƒë·∫øn h·ªôp **ti·∫øp theo** (nh∆∞ Singly Linked List).
- M·ªôt d√¢y n·ªëi ƒë·∫øn h·ªôp **tr∆∞·ªõc ƒë√≥** (ƒëi·ªÉm ƒë·∫∑c bi·ªát!).

**V√≠ d·ª• d·ªÖ hi·ªÉu**: H√£y t∆∞·ªüng t∆∞·ª£ng m·ªôt ƒëo√†n t√†u, m·ªói toa t√†u (node) c√≥ c·ª≠a s·ªï nh√¨n ƒë∆∞·ª£c c·∫£ ph√≠a tr∆∞·ªõc v√† ph√≠a sau. B·∫°n c√≥ th·ªÉ ƒëi ti·∫øn ho·∫∑c l√πi d·ªÖ d√†ng, kh√¥ng nh∆∞ xe bu√Ωt ch·ªâ ƒëi m·ªôt chi·ªÅu.

### So S√°nh V·ªõi Singly Linked List

| ƒê·∫∑c ƒêi·ªÉm | Singly Linked List | Doubly Linked List |
|----------|-------------------|-------------------|
| **C·∫•u tr√∫c** | A ‚Üí B ‚Üí C | null ‚Üê A ‚áÑ B ‚áÑ C ‚Üí null |
| **H∆∞·ªõng ƒëi** | Ch·ªâ ti·∫øn (‚Üí) | C·∫£ ti·∫øn v√† l√πi (‚áÑ) |
| **B·ªô nh·ªõ** | √çt h∆°n (1 d√¢y n·ªëi) | Nhi·ªÅu h∆°n (2 d√¢y n·ªëi) |
| **X√≥a cu·ªëi** | Ch·∫≠m (O(n)) | Nhanh (O(1)) |

### Th√†nh Ph·∫ßn C·∫•u Tr√∫c

1. **Node**: M·ªói h·ªôp ch·ª©a:
   - **D·ªØ li·ªáu**: Th√¥ng tin c·∫ßn l∆∞u.
   - **Next**: D√¢y n·ªëi ƒë·∫øn node ti·∫øp theo.
   - **Previous**: D√¢y n·ªëi ƒë·∫øn node tr∆∞·ªõc ƒë√≥.

2. **Head**: Node ƒë·∫ßu ti√™n (kh√¥ng c√≥ node tr∆∞·ªõc).
3. **Tail**: Node cu·ªëi c√πng (kh√¥ng c√≥ node sau).

### ∆Øu ƒêi·ªÉm

- **Di chuy·ªÉn hai chi·ªÅu**: D·ªÖ d√†ng ƒëi ti·∫øn ho·∫∑c l√πi.
- **X√≥a cu·ªëi nhanh**: Ch·ªâ c·∫ßn nh√¨n v√†o tail, kh√¥ng c·∫ßn t√¨m l√¢u.
- **D·ªÖ d√πng**: H·ªØu √≠ch cho c√°c ·ª©ng d·ª•ng c·∫ßn chuy·ªÉn qua l·∫°i (nh∆∞ n√∫t Next/Previous).

### Nh∆∞·ª£c ƒêi·ªÉm

- **T·ªën b·ªô nh·ªõ**: M·ªói node c·∫ßn th√™m m·ªôt d√¢y n·ªëi (previous).
- **Code ph·ª©c t·∫°p h∆°n**: Ph·∫£i qu·∫£n l√Ω c·∫£ hai d√¢y n·ªëi.

![Doubly Linked List](https://www.vievlog.com/dsa/images/doubly-linked-list.jpeg)

### Tri·ªÉn Khai Trong JavaScript

#### B∆∞·ªõc 1: T·∫°o L·ªõp Node

M·ªói node c√≥ d·ªØ li·ªáu, d√¢y n·ªëi t·ªõi node ti·∫øp theo v√† node tr∆∞·ªõc ƒë√≥:

```javascript
class DoublyLinkedListNode {
  constructor(value, next = null, previous = null) {
    this.value = value;       // D·ªØ li·ªáu
    this.next = next;         // Node ti·∫øp theo
    this.previous = previous; // Node tr∆∞·ªõc ƒë√≥
  }

  toString(callback) {
    return callback ? callback(this.value) : `${this.value}`;
  }
}
```

#### B∆∞·ªõc 2: T·∫°o L·ªõp DoublyLinkedList

L·ªõp n√†y qu·∫£n l√Ω to√†n b·ªô danh s√°ch:

```javascript
class DoublyLinkedList {
  constructor(comparatorFunction) {
    this.head = null; // Node ƒë·∫ßu
    this.tail = null; // Node cu·ªëi
    this.compare = new Comparator(comparatorFunction);
  }

  prepend(value) {
    const newNode = new DoublyLinkedListNode(value, this.head);
    if (this.head) {
      this.head.previous = newNode;
    }
    this.head = newNode;
    if (!this.tail) {
      this.tail = newNode;
    }
    return this;
  }

  append(value) {
    const newNode = new DoublyLinkedListNode(value);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
      return this;
    }
    this.tail.next = newNode;
    newNode.previous = this.tail;
    this.tail = newNode;
    return this;
  }

  delete(value) {
    if (!this.head) return null;
    let deletedNode = null;
    let currentNode = this.head;
    while (currentNode) {
      if (this.compare.equal(currentNode.value, value)) {
        deletedNode = currentNode;
        if (deletedNode === this.head) {
          this.head = deletedNode.next;
          if (this.head) {
            this.head.previous = null;
          }
          if (deletedNode === this.tail) {
            this.tail = null;
          }
        } else if (deletedNode === this.tail) {
          this.tail = deletedNode.previous;
          this.tail.next = null;
        } else {
          const prevNode = deletedNode.previous;
          const nextNode = deletedNode.next;
          prevNode.next = nextNode;
          nextNode.previous = prevNode;
        }
      }
      currentNode = currentNode.next;
    }
    return deletedNode;
  }

  find({ value = undefined, callback = undefined }) {
    if (!this.head) return null;
    let currentNode = this.head;
    while (currentNode) {
      if (callback && callback(currentNode.value)) {
        return currentNode;
      }
      if (value !== undefined && this.compare.equal(currentNode.value, value)) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }
    return null;
  }

  deleteTail() {
    if (!this.tail) return null;
    if (this.head === this.tail) {
      const deletedTail = this.tail;
      this.head = null;
      this.tail = null;
      return deletedTail;
    }
    const deletedTail = this.tail;
    this.tail = this.tail.previous;
    this.tail.next = null;
    return deletedTail;
  }

  deleteHead() {
    if (!this.head) return null;
    const deletedHead = this.head;
    if (this.head.next) {
      this.head = this.head.next;
      this.head.previous = null;
    } else {
      this.head = null;
      this.tail = null;
    }
    return deletedHead;
  }

  toArray() {
    const nodes = [];
    let currentNode = this.head;
    while (currentNode) {
      nodes.push(currentNode);
      currentNode = currentNode.next;
    }
    return nodes;
  }

  traverseReverse() {
    const values = [];
    let currentNode = this.tail;
    while (currentNode) {
      values.push(currentNode.value);
      currentNode = currentNode.previous;
    }
    return values;
  }

  reverse() {
    let currentNode = this.head;
    let tempNode = null;
    while (currentNode) {
      tempNode = currentNode.previous;
      currentNode.previous = currentNode.next;
      currentNode.next = tempNode;
      currentNode = currentNode.previous;
    }
    tempNode = this.head;
    this.head = this.tail;
    this.tail = tempNode;
    return this;
  }
}
```

**C√°c thao t√°c ch√≠nh**:
1. **prepend(value)**: Th√™m v√†o ƒë·∫ßu danh s√°ch (O(1)).
2. **append(value)**: Th√™m v√†o cu·ªëi danh s√°ch (O(1)).
3. **delete(value)**: X√≥a node c√≥ gi√° tr·ªã cho tr∆∞·ªõc (O(n) ƒë·ªÉ t√¨m, O(1) ƒë·ªÉ x√≥a).
4. **deleteTail()**: X√≥a node cu·ªëi, r·∫•t nhanh (O(1)).
5. **traverseReverse()**: Duy·ªát ng∆∞·ª£c t·ª´ cu·ªëi l√™n ƒë·∫ßu, ch·ªâ Doubly l√†m ƒë∆∞·ª£c.

### V√≠ D·ª• Minh H·ªça

#### V√≠ d·ª• 1: H·ªá th·ªëng ƒëi·ªÅu h∆∞·ªõng tr√¨nh duy·ªát

```javascript
const browserHistory = new DoublyLinkedList();
browserHistory.append('google.com');
browserHistory.append('stackoverflow.com');
browserHistory.append('github.com');
console.log('Trang hi·ªán t·∫°i:', browserHistory.tail.value); // github.com
if (browserHistory.tail.previous) {
  console.log('Trang tr∆∞·ªõc:', browserHistory.tail.previous.value); // stackoverflow.com
}
console.log('L·ªãch s·ª≠ duy·ªát:', browserHistory.traverseReverse());
// ['github.com', 'stackoverflow.com', 'google.com']
```

## üèÜ B√†i T·∫≠p Th·ª±c H√†nh

### B√†i T·∫≠p 1: H·ªá Th·ªëng Media Player

**M√¥ t·∫£**: X√¢y d·ª±ng tr√¨nh ph√°t nh·∫°c v·ªõi playlist c√≥ th·ªÉ:
- Th√™m b√†i h√°t.
- Ph√°t b√†i hi·ªán t·∫°i.
- Chuy·ªÉn b√†i ti·∫øp theo/l√πi l·∫°i b√†i tr∆∞·ªõc.
- X√≥a b√†i hi·ªán t·∫°i.
- ƒê·∫£o th·ª© t·ª± playlist.

```javascript
class Song {
  constructor(title, artist, duration) {
    this.title = title;
    this.artist = artist;
    this.duration = duration;
    this.isPlaying = false;
  }

  toString() {
    const status = this.isPlaying ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
    return `${status} ${this.title} - ${this.artist} (${this.duration})`;
  }
}

class MediaPlayer {
  constructor() {
    this.playlist = new DoublyLinkedList();
    this.currentSong = null;
  }

  addSong(title, artist, duration) {
    const song = new Song(title, artist, duration);
    this.playlist.append(song);
    if (!this.currentSong) {
      this.currentSong = this.playlist.head;
    }
    console.log(`Th√™m: ${song.toString()}`);
  }

  play() {
    if (!this.currentSong) {
      console.log('Kh√¥ng c√≥ b√†i h√°t');
      return;
    }
    this.stopAll();
    this.currentSong.value.isPlaying = true;
    console.log(`ƒêang ph√°t: ${this.currentSong.value.toString()}`);
  }

  stopAll() {
    let node = this.playlist.head;
    while (node) {
      node.value.isPlaying = false;
      node = node.next;
    }
  }

  next() {
    if (!this.currentSong || !this.currentSong.next) {
      console.log('Kh√¥ng c√≥ b√†i ti·∫øp theo');
      return;
    }
    this.stopAll();
    this.currentSong = this.currentSong.next;
    this.play();
  }

  previous() {
    if (!this.currentSong || !this.currentSong.previous) {
      console.log('Kh√¥ng c√≥ b√†i tr∆∞·ªõc');
      return;
    }
    this.stopAll();
    this.currentSong = this.currentSong.previous;
    this.play();
  }

  removeCurrent() {
    if (!this.currentSong) {
      console.log('Kh√¥ng c√≥ b√†i hi·ªán t·∫°i');
      return;
    }
    const songToRemove = this.currentSong.value;
    console.log(`X√≥a: ${songToRemove.title}`);
    let newCurrent = this.currentSong.next || this.currentSong.previous;
    this.playlist.delete(songToRemove);
    this.currentSong = newCurrent;
    if (this.currentSong) {
      this.play();
    } else {
      console.log('Playlist r·ªóng');
    }
  }

  shuffle() {
    console.log('ƒê·∫£o playlist...');
    this.playlist.reverse();
    if (this.currentSong) {
      this.currentSong = this.playlist.find({
        callback: song => song.title === this.currentSong.value.title
      });
    }
  }

  showPlaylist() {
    console.log('\n=== PLAYLIST ===');
    if (!this.playlist.head) {
      console.log('Playlist r·ªóng');
      return;
    }
    const songs = this.playlist.toArray();
    songs.forEach((node, index) => {
      const marker = node === this.currentSong ? 'üëâ' : '  ';
      console.log(`${marker} ${index + 1}. ${node.value.toString()}`);
    });
    console.log(`T·ªïng s·ªë b√†i: ${songs.length}`);
  }
}

const player = new MediaPlayer();
player.addSong('Blinding Lights', 'The Weeknd', '3:20');
player.addSong('Shape of You', 'Ed Sheeran', '3:53');
player.addSong('Bohemian Rhapsody', 'Queen', '5:55');
player.showPlaylist();
player.play();
player.next();
player.previous();
player.removeCurrent();
player.shuffle();
player.showPlaylist();
```

### B√†i T·∫≠p 2: Text Editor V·ªõi Undo/Redo

**M√¥ t·∫£**: X√¢y d·ª±ng tr√¨nh so·∫°n th·∫£o vƒÉn b·∫£n c√≥ th·ªÉ:
- L∆∞u l·ªãch s·ª≠ ch·ªânh s·ª≠a.
- Undo (quay l·∫°i) v√† Redo (ti·∫øn t·ªõi).
- Gi·ªõi h·∫°n l·ªãch s·ª≠ t·ªëi ƒëa 10 tr·∫°ng th√°i.
- X√≥a l·ªãch s·ª≠.

```javascript
class TextState {
  constructor(content, action = '') {
    this.content = content;
    this.action = action;
  }

  toString() {
    return `${this.action}: "${this.content}"`;
  }
}

class TextEditor {
  constructor(maxHistorySize = 10) {
    this.history = new DoublyLinkedList();
    this.currentState = null;
    this.maxHistorySize = maxHistorySize;
    this.setState('', 'T·∫°o t√†i li·ªáu');
  }

  setState(content, action) {
    const newState = new TextState(content, action);
    if (this.currentState && this.currentState.next) {
      this.clearRedoHistory();
    }
    this.history.append(newState);
    this.currentState = this.history.tail;
    this.limitHistorySize();
    console.log(`L∆∞u tr·∫°ng th√°i: ${action}`);
    this.showCurrentState();
  }

  clearRedoHistory() {
    let nodeToDelete = this.currentState.next;
    while (nodeToDelete) {
      const nextNode = nodeToDelete.next;
      this.history.delete(nodeToDelete.value);
      nodeToDelete = nextNode;
    }
  }

  limitHistorySize() {
    const historyArray = this.history.toArray();
    while (historyArray.length > this.maxHistorySize) {
      this.history.deleteHead();
      historyArray.shift();
      if (!this.currentState.previous) {
        this.currentState = this.history.head;
      }
    }
  }

  undo() {
    if (!this.currentState || !this.currentState.previous) {
      console.log('‚ùå Kh√¥ng th·ªÉ Undo');
      return false;
    }
    this.currentState = this.currentState.previous;
    console.log('‚Ü©Ô∏è ƒê√£ Undo');
    this.showCurrentState();
    return true;
  }

  redo() {
    if (!this.currentState || !this.currentState.next) {
      console.log('‚ùå Kh√¥ng th·ªÉ Redo');
      return false;
    }
    this.currentState = this.currentState.next;
    console.log('‚Ü™Ô∏è ƒê√£ Redo');
    this.showCurrentState();
    return true;
  }

  type(text) {
    const newContent = this.currentState.value.content + text;
    this.setState(newContent, `G√µ "${text}"`);
  }

  delete(numChars) {
    const currentContent = this.currentState.value.content;
    const newContent = currentContent.slice(0, -numChars);
    this.setState(newContent, `X√≥a ${numChars} k√Ω t·ª±`);
  }

  showCurrentState() {
    if (!this.currentState) {
      console.log('Kh√¥ng c√≥ tr·∫°ng th√°i');
      return;
    }
    console.log('\n=== VƒÇN B·∫¢N HI·ªÜN T·∫†I ===');
    console.log(`N·ªôi dung: "${this.currentState.value.content}"`);
    console.log(`H√†nh ƒë·ªông: ${this.currentState.value.action}`);
  }

  showHistory() {
    console.log('\n=== L·ªäCH S·ª¨ CH·ªàNH S·ª¨A ===');
    if (!this.history.head) {
      console.log('Kh√¥ng c√≥ l·ªãch s·ª≠');
      return;
    }
    const states = this.history.toArray();
    states.forEach((node, index) => {
      const marker = node === this.currentState ? 'üëâ' : '  ';
      console.log(`${marker} ${index + 1}. ${node.value.toString()}`);
    });
  }

  clearHistory() {
    this.history = new DoublyLinkedList();
    this.currentState = null;
    this.setState('', 'X√≥a l·ªãch s·ª≠');
  }
}

const editor = new TextEditor(5);
editor.type('Hello');
editor.type(' World');
editor.showHistory();
editor.undo();
editor.redo();
editor.showHistory();
```

## üîë Nh·ªØng ƒêi·ªÉm Quan Tr·ªçng

### Kh√°i Ni·ªám Ch√≠nh

1. **Hai d√¢y n·ªëi**: M·ªói node c√≥ c·∫£ `next` v√† `previous`.
2. **X√≥a cu·ªëi nhanh**: Ch·ªâ m·∫•t O(1), kh√¥ng nh∆∞ Singly (O(n)).
3. **Duy·ªát ng∆∞·ª£c**: Ch·ªâ Doubly l√†m ƒë∆∞·ª£c, t·ª´ tail v·ªÅ head.
4. **T·ªën b·ªô nh·ªõ h∆°n**: Do c√≥ th√™m d√¢y n·ªëi `previous`.

### ∆Øu ƒêi·ªÉm So V·ªõi Singly

- **X√≥a cu·ªëi nhanh**: Kh√¥ng c·∫ßn t√¨m node tr∆∞·ªõc.
- **Di chuy·ªÉn hai chi·ªÅu**: H·ªó tr·ª£ n√∫t Next/Previous.
- **X√≥a gi·ªØa d·ªÖ h∆°n**: Kh√¥ng c·∫ßn t√¨m node tr∆∞·ªõc.

### L·ªói Th∆∞·ªùng G·∫∑p

1. **Qu√™n c·∫≠p nh·∫≠t d√¢y n·ªëi**:
   - Ph·∫£i c·∫≠p nh·∫≠t c·∫£ `next` v√† `previous` khi th√™m/x√≥a node.
   - **S·ª≠a**: Ki·ªÉm tra v√† g√°n c·∫£ hai d√¢y n·ªëi.

2. **Kh√¥ng x·ª≠ l√Ω tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát**:
   - Ki·ªÉm tra danh s√°ch r·ªóng, ch·ªâ c√≥ m·ªôt node, v.v.
   - **S·ª≠a**: Th√™m ƒëi·ªÅu ki·ªán ki·ªÉm tra `null`.

### So S√°nh Hi·ªáu Su·∫•t

| Thao t√°c | Doubly | Singly | Array |
|----------|--------|--------|-------|
| Truy c·∫≠p ng·∫´u nhi√™n | Ch·∫≠m (O(n)) | Ch·∫≠m (O(n)) | Nhanh (O(1)) |
| Th√™m v√†o ƒë·∫ßu | Nhanh (O(1)) | Nhanh (O(1)) | Ch·∫≠m (O(n)) |
| X√≥a cu·ªëi | Nhanh (O(1)) | Ch·∫≠m (O(n)) | Nhanh (O(1)) |
| Duy·ªát ng∆∞·ª£c | C√≥ (O(n)) | Kh√¥ng | C√≥ (O(n)) |

### Khi N√†o D√πng Doubly Linked List?

**N√™n d√πng khi**:
- C·∫ßn di chuy·ªÉn qua l·∫°i (Next/Previous).
- Th∆∞·ªùng xuy√™n x√≥a node cu·ªëi.
- L√†m h·ªá th·ªëng Undo/Redo.
- C·∫ßn duy·ªát ng∆∞·ª£c danh s√°ch.

**Kh√¥ng n√™n d√πng khi**:
- C·∫ßn ti·∫øt ki·ªám b·ªô nh·ªõ.
- Ch·ªâ ƒëi m·ªôt chi·ªÅu.
- C·∫ßn truy c·∫≠p ng·∫´u nhi√™n nhanh.

## üìù B√†i T·∫≠p V·ªÅ Nh√†

### B√†i T·∫≠p 1: LRU Cache

X√¢y d·ª±ng b·ªô nh·ªõ ƒë·ªám LRU (Least Recently Used):
- `get(key)`: L·∫•y gi√° tr·ªã v√† ƒë∆∞a l√™n ƒë·∫ßu (m·ªõi d√πng g·∫ßn ƒë√¢y).
- `put(key, value)`: Th√™m/c·∫≠p nh·∫≠t v√† ƒë∆∞a l√™n ƒë·∫ßu.
- X√≥a item √≠t d√πng nh·∫•t khi cache ƒë·∫ßy.
- Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc cache.

**G·ª£i √Ω**: K·∫øt h·ª£p HashMap ƒë·ªÉ t√¨m nhanh v√† Doubly Linked List ƒë·ªÉ theo d√µi th·ª© t·ª± s·ª≠ d·ª•ng.

### B√†i T·∫≠p 2: Text Editor V·ªõi Nhi·ªÅu Con Tr·ªè

X√¢y d·ª±ng tr√¨nh so·∫°n th·∫£o vƒÉn b·∫£n n√¢ng cao:
- H·ªó tr·ª£ nhi·ªÅu con tr·ªè ch·ªânh s·ª≠a.
- M·ªói con tr·ªè c√≥ l·ªãch s·ª≠ Undo/Redo ri√™ng.
- Chuy·ªÉn ƒë·ªïi gi·ªØa c√°c con tr·ªè.
- ƒê·ªìng b·ªô ho·∫∑c ch·ªânh s·ª≠a ri√™ng t·ª´ng con tr·ªè.

**G·ª£i √Ω**: M·ªói con tr·ªè d√πng m·ªôt Doubly Linked List ƒë·ªÉ l∆∞u l·ªãch s·ª≠ ch·ªânh s·ª≠a.

\---



---

*Post ID: pjaolesiv5j2gta*  
*Category: Data Structures*  
*Created: 19/8/2025*  
*Updated: 2/9/2025*
