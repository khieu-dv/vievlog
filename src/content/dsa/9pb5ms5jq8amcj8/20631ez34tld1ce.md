---
title: "Trie (C√¢y Ti·ªÅn T·ªë)"
postId: "20631ez34tld1ce"
category: "Data Structures"
created: "19/8/2025"
updated: "27/8/2025"
---

# Trie (C√¢y Ti·ªÅn T·ªë)


## üéØ M·ª•c ti√™u b√†i h·ªçc

Sau khi ho√†n th√†nh b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- **Hi·ªÉu b·∫£n ch·∫•t c·ªßa Trie**: N·∫Øm v·ªØng c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y l∆∞u tr·ªØ chu·ªói theo ti·ªÅn t·ªë, c√°ch th·ª©c ho·∫°t ƒë·ªông v√† t·∫°i sao n√≥ hi·ªáu qu·∫£ cho vi·ªác t√¨m ki·∫øm chu·ªói
- **Th√†nh th·∫°o c√°c thao t√°c c∆° b·∫£n**: Tri·ªÉn khai ch√≠nh x√°c c√°c ph∆∞∆°ng th·ª©c insert, search, delete v√† c√°c thao t√°c li√™n quan ƒë·∫øn ti·ªÅn t·ªë
- **T·ªëi ∆∞u h√≥a b·ªô nh·ªõ v√† hi·ªáu su·∫•t**: Hi·ªÉu c√°ch Trie ti·∫øt ki·ªám kh√¥ng gian nh·ªù chia s·∫ª ti·ªÅn t·ªë chung v√† t·ªëi ∆∞u th·ªùi gian t√¨m ki·∫øm O(m) v·ªõi m l√† ƒë·ªô d√†i chu·ªói
- **·ª®ng d·ª•ng th·ª±c t·∫ø**: X√¢y d·ª±ng ƒë∆∞·ª£c h·ªá th·ªëng autocomplete, ki·ªÉm tra ch√≠nh t·∫£, v√† c√°c t√≠nh nƒÉng t√¨m ki·∫øm th√¥ng minh
- **Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p**: So s√°nh hi·ªáu su·∫•t Trie v·ªõi Hash Table v√† Binary Search Tree trong c√°c t√¨nh hu·ªëng kh√°c nhau

## üìù N·ªôi dung chi ti·∫øt

### Trie l√† g√¨?

Trie (ph√°t √¢m l√† "try") hay Prefix Tree l√† c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·∫∑c bi·ªát ƒë·ªÉ l∆∞u tr·ªØ v√† t√¨m ki·∫øm chu·ªói hi·ªáu qu·∫£. M·ªói n√∫t trong c√¢y ƒë·∫°i di·ªán cho m·ªôt k√Ω t·ª±, v√† ƒë∆∞·ªùng ƒëi t·ª´ g·ªëc ƒë·∫øn m·ªôt n√∫t t·∫°o th√†nh ti·ªÅn t·ªë c·ªßa c√°c chu·ªói ƒë∆∞·ª£c l∆∞u tr·ªØ.

![Trie](https://www.vievlog.com/dsa/images/trie.jpg)

**ƒê·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t:**
- **Prefix sharing**: C√°c chu·ªói c√≥ chung ti·ªÅn t·ªë s·∫Ω chia s·∫ª c√πng m·ªôt ƒë∆∞·ªùng ƒëi t·ª´ g·ªëc
- **Fast prefix operations**: T√¨m ki·∫øm theo ti·ªÅn t·ªë c√≥ ƒë·ªô ph·ª©c t·∫°p O(p) v·ªõi p l√† ƒë·ªô d√†i ti·ªÅn t·ªë
- **Memory efficient**: Ti·∫øt ki·ªám b·ªô nh·ªõ khi c√≥ nhi·ªÅu chu·ªói c√≥ ti·ªÅn t·ªë chung
- **Deterministic search**: Th·ªùi gian t√¨m ki·∫øm ch·ªâ ph·ª• thu·ªôc v√†o ƒë·ªô d√†i chu·ªói, kh√¥ng ph·ª• thu·ªôc v√†o s·ªë l∆∞·ª£ng chu·ªói

### C·∫•u tr√∫c TrieNode

```javascript
import HashTable from '../hash-table/HashTable';

export default class TrieNode {
  constructor(character, isCompleteWord = false) {
    this.character = character;           // K√Ω t·ª± c·ªßa n√∫t hi·ªán t·∫°i
    this.isCompleteWord = isCompleteWord; // ƒê√°nh d·∫•u k·∫øt th√∫c m·ªôt t·ª´ ho√†n ch·ªânh
    this.children = new HashTable();      // L∆∞u tr·ªØ c√°c n√∫t con
  }

  // L·∫•y n√∫t con theo k√Ω t·ª±
  getChild(character) {
    return this.children.get(character);
  }

  // Th√™m n√∫t con m·ªõi
  addChild(character, isCompleteWord = false) {
    if (!this.children.has(character)) {
      this.children.set(character, new TrieNode(character, isCompleteWord));
    }

    const childNode = this.children.get(character);
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i t·ª´ ho√†n ch·ªânh (cho tr∆∞·ªùng h·ª£p "car" v√† "cars")
    childNode.isCompleteWord = childNode.isCompleteWord || isCompleteWord;
    
    return childNode;
  }

  // X√≥a n√∫t con (ch·ªâ khi an to√†n)
  removeChild(character) {
    const childNode = this.getChild(character);
    
    // Ch·ªâ x√≥a khi n√∫t con kh√¥ng c√≥ con v√† kh√¥ng ph·∫£i t·ª´ ho√†n ch·ªânh
    if (childNode && !childNode.isCompleteWord && !childNode.hasChildren()) {
      this.children.delete(character);
    }
    
    return this;
  }

  // Ki·ªÉm tra t·ªìn t·∫°i n√∫t con
  hasChild(character) {
    return this.children.has(character);
  }

  // Ki·ªÉm tra c√≥ n√∫t con n√†o kh√¥ng
  hasChildren() {
    return this.children.getKeys().length !== 0;
  }

  // L·∫•y danh s√°ch k√Ω t·ª± c·ªßa c√°c n√∫t con
  suggestChildren() {
    return [...this.children.getKeys()];
  }

  toString() {
    let childrenAsString = this.suggestChildren().toString();
    childrenAsString = childrenAsString ? `:${childrenAsString}` : '';
    const isCompleteString = this.isCompleteWord ? '*' : '';
    return `${this.character}${isCompleteString}${childrenAsString}`;
  }
}
```

### Tri·ªÉn khai Trie ch√≠nh

```javascript
import TrieNode from './TrieNode';

const HEAD_CHARACTER = '*';

export default class Trie {
  constructor() {
    this.head = new TrieNode(HEAD_CHARACTER);
  }

  // Th√™m t·ª´ v√†o Trie
  addWord(word) {
    const characters = Array.from(word);
    let currentNode = this.head;

    for (let charIndex = 0; charIndex < characters.length; charIndex++) {
      const isComplete = charIndex === characters.length - 1;
      currentNode = currentNode.addChild(characters[charIndex], isComplete);
    }

    return this;
  }

  // X√≥a t·ª´ kh·ªèi Trie (s·ª≠ d·ª•ng depth-first approach)
  deleteWord(word) {
    const depthFirstDelete = (currentNode, charIndex = 0) => {
      if (charIndex >= word.length) {
        return;
      }

      const character = word[charIndex];
      const nextNode = currentNode.getChild(character);

      if (nextNode == null) {
        return; // T·ª´ kh√¥ng t·ªìn t·∫°i trong Trie
      }

      // ƒê·ªá quy xu·ªëng level s√¢u h∆°n
      depthFirstDelete(nextNode, charIndex + 1);

      // Khi quay l·∫°i, b·ªè ƒë√°nh d·∫•u t·ª´ ho√†n ch·ªânh n·∫øu ƒë√¢y l√† k√Ω t·ª± cu·ªëi
      if (charIndex === (word.length - 1)) {
        nextNode.isCompleteWord = false;
      }

      // Th·ª≠ x√≥a n√∫t con n·∫øu c√≥ th·ªÉ
      currentNode.removeChild(character);
    };

    depthFirstDelete(this.head);
    return this;
  }

  // Ki·ªÉm tra t·ª´ c√≥ t·ªìn t·∫°i kh√¥ng
  doesWordExist(word) {
    const lastCharacter = this.getLastCharacterNode(word);
    return !!lastCharacter && lastCharacter.isCompleteWord;
  }

  // L·∫•y n√∫t k√Ω t·ª± cu·ªëi c√πng c·ªßa t·ª´
  getLastCharacterNode(word) {
    const characters = Array.from(word);
    let currentNode = this.head;

    for (let charIndex = 0; charIndex < characters.length; charIndex++) {
      if (!currentNode.hasChild(characters[charIndex])) {
        return null;
      }
      currentNode = currentNode.getChild(characters[charIndex]);
    }

    return currentNode;
  }

  // G·ª£i √Ω k√Ω t·ª± ti·∫øp theo c√≥ th·ªÉ c√≥
  suggestNextCharacters(word) {
    const lastCharacter = this.getLastCharacterNode(word);
    
    if (!lastCharacter) {
      return null;
    }

    return lastCharacter.suggestChildren();
  }

  // T√¨m t·∫•t c·∫£ t·ª´ c√≥ ti·ªÅn t·ªë cho tr∆∞·ªõc
  findWordsWithPrefix(prefix) {
    const prefixNode = this.getLastCharacterNode(prefix);
    if (!prefixNode) {
      return [];
    }

    const words = [];
    this.collectWords(prefixNode, prefix, words);
    return words;
  }

  // Thu th·∫≠p t·∫•t c·∫£ t·ª´ t·ª´ m·ªôt n√∫t (s·ª≠ d·ª•ng DFS)
  collectWords(node, currentWord, words) {
    if (node.isCompleteWord) {
      words.push(currentWord);
    }

    const children = node.suggestChildren();
    for (let child of children) {
      const childNode = node.getChild(child);
      this.collectWords(childNode, currentWord + child, words);
    }
  }
}
```

### V√≠ d·ª• s·ª≠ d·ª•ng c∆° b·∫£n

```javascript
const trie = new Trie();

// Th√™m t·ª´
const words = ['cat', 'car', 'card', 'care', 'careful', 'cars'];
words.forEach(word => trie.addWord(word));

// Ki·ªÉm tra t·ª´ t·ªìn t·∫°i
console.log(trie.doesWordExist('car'));      // true
console.log(trie.doesWordExist('care'));     // true  
console.log(trie.doesWordExist('careful'));  // true
console.log(trie.doesWordExist('ca'));       // false

// T√¨m t·ª´ theo ti·ªÅn t·ªë
console.log(trie.findWordsWithPrefix('car'));
// Output: ['car', 'card', 'care', 'careful', 'cars']

// G·ª£i √Ω k√Ω t·ª± ti·∫øp theo
console.log(trie.suggestNextCharacters('ca'));
// Output: ['r', 't']
```

### Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

| Thao t√°c | ƒê·ªô ph·ª©c t·∫°p th·ªùi gian | ƒê·ªô ph·ª©c t·∫°p kh√¥ng gian |
|----------|----------------------|----------------------|
| Insert | O(m) | O(m) |
| Search | O(m) | O(1) |
| Delete | O(m) | O(1) |
| Prefix Search | O(p + k) | O(k) |
| Autocomplete | O(p + k) | O(k) |

*Trong ƒë√≥: m = ƒë·ªô d√†i t·ª´, p = ƒë·ªô d√†i ti·ªÅn t·ªë, k = s·ªë k·∫øt qu·∫£ tr·∫£ v·ªÅ*

## üèÜ B√†i t·∫≠p th·ª±c h√†nh

### B√†i t·∫≠p 1: H·ªá th·ªëng t·ª± ƒë·ªông ho√†n th√†nh t√¨m ki·∫øm

**ƒê·ªÅ b√†i**: X√¢y d·ª±ng h·ªá th·ªëng t·ª± ƒë·ªông ho√†n th√†nh cho m·ªôt trang web th∆∞∆°ng m·∫°i ƒëi·ªán t·ª≠. H·ªá th·ªëng c·∫ßn h·ªó tr·ª£:
- Th√™m s·∫£n ph·∫©m v√†o c∆° s·ªü d·ªØ li·ªáu t√¨m ki·∫øm
- G·ª£i √Ω t·ª± ƒë·ªông ho√†n th√†nh d·ª±a tr√™n ƒë·ªô ph·ªï bi·∫øn
- Theo d√µi t·∫ßn su·∫•t t√¨m ki·∫øm ƒë·ªÉ c·∫£i thi·ªán g·ª£i √Ω

**Ph√¢n t√≠ch b√†i to√°n**:
- S·ª≠ d·ª•ng Trie ƒë·ªÉ l∆∞u tr·ªØ t√™n s·∫£n ph·∫©m v√† t√¨m ki·∫øm theo ti·ªÅn t·ªë
- K·∫øt h·ª£p v·ªõi Map ƒë·ªÉ l∆∞u tr·ªØ ƒëi·ªÉm s·ªë popularity
- S·∫Øp x·∫øp k·∫øt qu·∫£ theo ƒë·ªô ph·ªï bi·∫øn

**L·ªùi gi·∫£i chi ti·∫øt**:

```javascript
class AutocompleteSystem {
  constructor() {
    this.trie = new Trie();
    this.popularityScores = new Map(); // L∆∞u ƒëi·ªÉm ph·ªï bi·∫øn
    this.searchHistory = new Map();    // L∆∞u l·ªãch s·ª≠ t√¨m ki·∫øm
  }

  // Th√™m s·∫£n ph·∫©m v·ªõi ƒëi·ªÉm ph·ªï bi·∫øn ban ƒë·∫ßu
  addProduct(productName, initialPopularity = 0) {
    this.trie.addWord(productName.toLowerCase());
    this.popularityScores.set(productName.toLowerCase(), initialPopularity);
    console.log(`‚úÖ ƒê√£ th√™m s·∫£n ph·∫©m: "${productName}" v·ªõi ƒëi·ªÉm ph·ªï bi·∫øn: ${initialPopularity}`);
  }

  // Ghi nh·∫≠n l∆∞·ª£t t√¨m ki·∫øm
  recordSearch(query) {
    const lowerQuery = query.toLowerCase();
    
    // TƒÉng s·ªë l·∫ßn t√¨m ki·∫øm
    const searchCount = this.searchHistory.get(lowerQuery) || 0;
    this.searchHistory.set(lowerQuery, searchCount + 1);
    
    // TƒÉng ƒëi·ªÉm ph·ªï bi·∫øn n·∫øu l√† s·∫£n ph·∫©m c√≥ th·∫≠t
    if (this.trie.doesWordExist(lowerQuery)) {
      const currentScore = this.popularityScores.get(lowerQuery) || 0;
      this.popularityScores.set(lowerQuery, currentScore + 10);
    }
    
    console.log(`üîç Ghi nh·∫≠n t√¨m ki·∫øm: "${query}"`);
  }

  // L·∫•y g·ª£i √Ω t·ª± ƒë·ªông ho√†n th√†nh
  getAutocompleteSuggestions(prefix, limit = 5) {
    const lowerPrefix = prefix.toLowerCase();
    
    // T√¨m t·∫•t c·∫£ s·∫£n ph·∫©m c√≥ ti·ªÅn t·ªë ph√π h·ª£p
    const matchingProducts = this.trie.findWordsWithPrefix(lowerPrefix);
    
    if (matchingProducts.length === 0) {
      return {
        suggestions: [],
        message: `Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o b·∫Øt ƒë·∫ßu v·ªõi "${prefix}"`
      };
    }

    // S·∫Øp x·∫øp theo ƒëi·ªÉm ph·ªï bi·∫øn v√† gi·ªõi h·∫°n s·ªë l∆∞·ª£ng
    const sortedSuggestions = matchingProducts
      .map(product => ({
        name: product,
        popularity: this.popularityScores.get(product) || 0,
        searchCount: this.searchHistory.get(product) || 0
      }))
      .sort((a, b) => b.popularity - a.popularity)
      .slice(0, limit);

    return {
      suggestions: sortedSuggestions,
      totalMatches: matchingProducts.length,
      message: `T√¨m th·∫•y ${matchingProducts.length} s·∫£n ph·∫©m ph√π h·ª£p`
    };
  }

  // Ph√¢n t√≠ch th·ªëng k√™ t√¨m ki·∫øm
  getSearchAnalytics() {
    const topSearches = Array.from(this.searchHistory.entries())
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([query, count]) => ({ query, count }));

    const topProducts = Array.from(this.popularityScores.entries())
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([product, score]) => ({ product, score }));

    return {
      topSearches,
      topProducts,
      totalSearches: Array.from(this.searchHistory.values()).reduce((a, b) => a + b, 0)
    };
  }
}

// S·ª≠ d·ª•ng h·ªá th·ªëng
const autocomplete = new AutocompleteSystem();

// Th√™m d·ªØ li·ªáu s·∫£n ph·∫©m
const products = [
  { name: 'iPhone 15 Pro Max', popularity: 95 },
  { name: 'iPhone 15 Pro', popularity: 90 },
  { name: 'iPhone 15', popularity: 85 },
  { name: 'iPad Pro', popularity: 80 },
  { name: 'iPad Air', popularity: 75 },
  { name: 'MacBook Pro', popularity: 88 },
  { name: 'MacBook Air', popularity: 83 },
  { name: 'AirPods Pro', popularity: 92 },
  { name: 'AirPods Max', popularity: 70 },
  { name: 'Apple Watch', popularity: 85 }
];

products.forEach(product => {
  autocomplete.addProduct(product.name, product.popularity);
});

// M√¥ ph·ªèng ng∆∞·ªùi d√πng t√¨m ki·∫øm
console.log('\n=== DEMO T√åM KI·∫æM ===');

// Test 1: T√¨m ki·∫øm iPhone
console.log('\n1. T√¨m ki·∫øm "iph":');
let result = autocomplete.getAutocompleteSuggestions('iph');
console.log(result.message);
result.suggestions.forEach((item, index) => {
  console.log(`  ${index + 1}. ${item.name} (ƒêi·ªÉm: ${item.popularity})`);
});

// Test 2: Ghi nh·∫≠n l∆∞·ª£t t√¨m ki·∫øm
autocomplete.recordSearch('iPhone 15');
autocomplete.recordSearch('iPhone 15');
autocomplete.recordSearch('iPhone 15 Pro');

console.log('\n2. T√¨m ki·∫øm "iphone" sau khi ghi nh·∫≠n l∆∞·ª£t t√¨m:');
result = autocomplete.getAutocompleteSuggestions('iphone');
result.suggestions.forEach((item, index) => {
  console.log(`  ${index + 1}. ${item.name} (ƒêi·ªÉm: ${item.popularity}, L∆∞·ª£t t√¨m: ${item.searchCount})`);
});

// Test 3: Th·ªëng k√™
console.log('\n3. Th·ªëng k√™ t√¨m ki·∫øm:');
const analytics = autocomplete.getSearchAnalytics();
console.log(`T·ªïng l∆∞·ª£t t√¨m ki·∫øm: ${analytics.totalSearches}`);
console.log('Top 5 s·∫£n ph·∫©m ph·ªï bi·∫øn nh·∫•t:');
analytics.topProducts.slice(0, 5).forEach((item, index) => {
  console.log(`  ${index + 1}. ${item.product} (${item.score} ƒëi·ªÉm)`);
});
```

### B√†i t·∫≠p 2: H·ªá th·ªëng ki·ªÉm tra v√† s·ª≠a l·ªói ch√≠nh t·∫£ th√¥ng minh

**ƒê·ªÅ b√†i**: Ph√°t tri·ªÉn m·ªôt tr√¨nh ki·ªÉm tra ch√≠nh t·∫£ cho ·ª©ng d·ª•ng so·∫°n th·∫£o vƒÉn b·∫£n. H·ªá th·ªëng c·∫ßn:
- Ph√°t hi·ªán t·ª´ sai ch√≠nh t·∫£
- ƒê·ªÅ xu·∫•t t·ª´ thay th·∫ø ph√π h·ª£p
- H·ªçc t·ª´ ng∆∞·ªùi d√πng ƒë·ªÉ c·∫£i thi·ªán ƒë·ªô ch√≠nh x√°c

**Ph√¢n t√≠ch b√†i to√°n**:
- S·ª≠ d·ª•ng Trie ƒë·ªÉ l∆∞u t·ª´ ƒëi·ªÉn chu·∫©n
- √Åp d·ª•ng thu·∫≠t to√°n Edit Distance ƒë·ªÉ t√¨m t·ª´ t∆∞∆°ng t·ª±
- H·ªá th·ªëng h·ªçc t·∫≠p t·ª´ feedback c·ªßa ng∆∞·ªùi d√πng

**L·ªùi gi·∫£i chi ti·∫øt**:

```javascript
class SmartSpellChecker {
  constructor() {
    this.dictionary = new Trie();           // T·ª´ ƒëi·ªÉn chu·∫©n
    this.userWords = new Trie();           // T·ª´ ng∆∞·ªùi d√πng th√™m
    this.corrections = new Map();          // L∆∞u c√°c l·∫ßn s·ª≠a l·ªói
    this.ignoreWords = new Set();          // T·ª´ ƒë∆∞·ª£c b·ªè qua
  }

  // Th√™m t·ª´ v√†o t·ª´ ƒëi·ªÉn chu·∫©n
  addToDictionary(word) {
    this.dictionary.addWord(word.toLowerCase());
  }

  // Th√™m nhi·ªÅu t·ª´ v√†o t·ª´ ƒëi·ªÉn
  loadDictionary(words) {
    words.forEach(word => this.addToDictionary(word));
    console.log(`üìö ƒê√£ t·∫£i ${words.length} t·ª´ v√†o t·ª´ ƒëi·ªÉn`);
  }

  // Th√™m t·ª´ do ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a
  addUserWord(word) {
    this.userWords.addWord(word.toLowerCase());
    console.log(`‚ûï ƒê√£ th√™m t·ª´ "${word}" v√†o t·ª´ ƒëi·ªÉn c√° nh√¢n`);
  }

  // Ki·ªÉm tra t·ª´ c√≥ ƒë√∫ng ch√≠nh t·∫£ kh√¥ng
  isWordCorrect(word) {
    const lowerWord = word.toLowerCase();
    return this.dictionary.doesWordExist(lowerWord) || 
           this.userWords.doesWordExist(lowerWord) ||
           this.ignoreWords.has(lowerWord);
  }

  // T√≠nh kho·∫£ng c√°ch Levenshtein gi·ªØa hai t·ª´
  calculateEditDistance(word1, word2) {
    const len1 = word1.length;
    const len2 = word2.length;
    const matrix = Array(len1 + 1).fill().map(() => Array(len2 + 1).fill(0));

    // Kh·ªüi t·∫°o h√†ng v√† c·ªôt ƒë·∫ßu
    for (let i = 0; i <= len1; i++) matrix[i][0] = i;
    for (let j = 0; j <= len2; j++) matrix[0][j] = j;

    // T√≠nh to√°n ma tr·∫≠n
    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        if (word1[i-1] === word2[j-1]) {
          matrix[i][j] = matrix[i-1][j-1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i-1][j] + 1,     // x√≥a
            matrix[i][j-1] + 1,     // th√™m
            matrix[i-1][j-1] + 1    // thay th·∫ø
          );
        }
      }
    }

    return matrix[len1][len2];
  }

  // ƒê·ªÅ xu·∫•t t·ª´ thay th·∫ø cho t·ª´ sai
  getSuggestions(incorrectWord, maxSuggestions = 5) {
    const lowerWord = incorrectWord.toLowerCase();
    
    if (this.isWordCorrect(lowerWord)) {
      return [`"${incorrectWord}" ƒë√£ ƒë√∫ng ch√≠nh t·∫£`];
    }

    const suggestions = [];
    const maxDistance = Math.min(3, Math.ceil(lowerWord.length / 3));

    // L·∫•y t·∫•t c·∫£ t·ª´ trong t·ª´ ƒëi·ªÉn ƒë·ªÉ so s√°nh
    const allWords = [
      ...this.getAllWordsFromTrie(this.dictionary),
      ...this.getAllWordsFromTrie(this.userWords)
    ];

    // T√≠nh to√°n ƒë·ªô t∆∞∆°ng t·ª± v√† s·∫Øp x·∫øp
    for (const word of allWords) {
      const distance = this.calculateEditDistance(lowerWord, word);
      
      if (distance <= maxDistance && distance > 0) {
        suggestions.push({
          word,
          distance,
          similarity: 1 - (distance / Math.max(lowerWord.length, word.length))
        });
      }
    }

    // S·∫Øp x·∫øp theo ƒë·ªô t∆∞∆°ng t·ª± v√† gi·ªõi h·∫°n s·ªë l∆∞·ª£ng
    return suggestions
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, maxSuggestions)
      .map(item => item.word);
  }

  // L·∫•y t·∫•t c·∫£ t·ª´ t·ª´ m·ªôt Trie
  getAllWordsFromTrie(trie) {
    const words = [];
    const collectAllWords = (node, currentWord) => {
      if (node.isCompleteWord) {
        words.push(currentWord);
      }
      
      const children = node.suggestChildren();
      for (const char of children) {
        const childNode = node.getChild(char);
        collectAllWords(childNode, currentWord + char);
      }
    };

    collectAllWords(trie.head, '');
    return words;
  }

  // Ki·ªÉm tra c·∫£ vƒÉn b·∫£n
  checkText(text) {
    // T√°ch t·ª´ v√† lo·∫°i b·ªè d·∫•u c√¢u
    const words = text.toLowerCase()
      .replace(/[^\w\s√†√°·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√®√©·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√¨√≠·ªâƒ©·ªã√≤√≥·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√π√∫·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±·ª≥√Ω·ª∑·ªπ·ªµƒë]/gi, '')
      .split(/\s+/)
      .filter(word => word.length > 0);

    const errors = [];
    
    words.forEach((word, index) => {
      if (!this.isWordCorrect(word)) {
        const suggestions = this.getSuggestions(word, 3);
        errors.push({
          position: index,
          incorrectWord: word,
          suggestions: suggestions.slice(0, 3)
        });
      }
    });

    return {
      totalWords: words.length,
      errors: errors.length,
      errorDetails: errors,
      accuracy: ((words.length - errors.length) / words.length * 100).toFixed(1)
    };
  }

  // Ghi nh·∫≠n s·ª± s·ª≠a l·ªói c·ªßa ng∆∞·ªùi d√πng (ƒë·ªÉ h·ªçc)
  recordCorrection(incorrectWord, correctWord) {
    const key = incorrectWord.toLowerCase();
    if (!this.corrections.has(key)) {
      this.corrections.set(key, []);
    }
    this.corrections.get(key).push(correctWord.toLowerCase());
    
    // T·ª± ƒë·ªông th√™m t·ª´ ƒë√∫ng v√†o t·ª´ ƒëi·ªÉn ng∆∞·ªùi d√πng
    this.addUserWord(correctWord);
    console.log(`üîÑ ƒê√£ ghi nh·∫≠n: "${incorrectWord}" ‚Üí "${correctWord}"`);
  }

  // B·ªè qua t·ª´ (kh√¥ng coi l√† l·ªói)
  ignoreWord(word) {
    this.ignoreWords.add(word.toLowerCase());
    console.log(`‚è≠Ô∏è ƒê√£ b·ªè qua t·ª´: "${word}"`);
  }

  // Th·ªëng k√™ hi·ªáu su·∫•t
  getStatistics() {
    return {
      dictionaryWords: this.getAllWordsFromTrie(this.dictionary).length,
      userWords: this.getAllWordsFromTrie(this.userWords).length,
      ignoredWords: this.ignoreWords.size,
      corrections: this.corrections.size,
      totalWords: this.getAllWordsFromTrie(this.dictionary).length + 
                  this.getAllWordsFromTrie(this.userWords).length
    };
  }
}

// Demo h·ªá th·ªëng ki·ªÉm tra ch√≠nh t·∫£
const spellChecker = new SmartSpellChecker();

// T·∫£i t·ª´ ƒëi·ªÉn c∆° b·∫£n
const basicDictionary = [
  'javascript', 'python', 'programming', 'computer', 'algorithm',
  'function', 'variable', 'array', 'object', 'string',
  'number', 'boolean', 'null', 'undefined', 'console',
  'document', 'window', 'element', 'event', 'click',
  'hello', 'world', 'example', 'test', 'code', 'debug'
];

spellChecker.loadDictionary(basicDictionary);

// Test ki·ªÉm tra t·ª´ng t·ª´
console.log('\n=== TEST KI·ªÇM TRA T·ª™NG T·ª™ ===');
const testWords = ['javascript', 'javascrip', 'phyton', 'algortihm'];

testWords.forEach(word => {
  const isCorrect = spellChecker.isWordCorrect(word);
  console.log(`\n"${word}": ${isCorrect ? '‚úÖ ƒê√∫ng' : '‚ùå Sai'}`);
  
  if (!isCorrect) {
    const suggestions = spellChecker.getSuggestions(word, 3);
    console.log(`  G·ª£i √Ω: ${suggestions.join(', ')}`);
  }
});

// Test ki·ªÉm tra vƒÉn b·∫£n
console.log('\n=== TEST KI·ªÇM TRA VƒÇN B·∫¢N ===');
const sampleText = "I am lerning javascrip and phyton progaming. This is a simpl exampl of spel cheking.";

console.log(`VƒÉn b·∫£n g·ªëc: "${sampleText}"`);
const result = spellChecker.checkText(sampleText);

console.log(`\nK·∫øt qu·∫£ ki·ªÉm tra:`);
console.log(`- T·ªïng s·ªë t·ª´: ${result.totalWords}`);
console.log(`- S·ªë l·ªói: ${result.errors}`);
console.log(`- ƒê·ªô ch√≠nh x√°c: ${result.accuracy}%`);

if (result.errorDetails.length > 0) {
  console.log(`\nChi ti·∫øt l·ªói:`);
  result.errorDetails.forEach((error, index) => {
    console.log(`  ${index + 1}. "${error.incorrectWord}" ‚Üí G·ª£i √Ω: ${error.suggestions.join(', ')}`);
  });
}

// Test h·ªçc t·ª´ ng∆∞·ªùi d√πng
console.log('\n=== TEST H·ªåC T·ª™ NG∆Ø·ªúI D√ôNG ===');
spellChecker.recordCorrection('lerning', 'learning');
spellChecker.recordCorrection('progaming', 'programming');
spellChecker.addUserWord('TypeScript');

// Th·ªëng k√™
console.log('\n=== TH·ªêNG K√ä H·ªÜ TH·ªêNG ===');
const stats = spellChecker.getStatistics();
console.log(`T·ª´ ƒëi·ªÉn chu·∫©n: ${stats.dictionaryWords} t·ª´`);
console.log(`T·ª´ ƒëi·ªÉn c√° nh√¢n: ${stats.userWords} t·ª´`);
console.log(`T·ª´ b·ªè qua: ${stats.ignoredWords} t·ª´`);
console.log(`L·∫ßn s·ª≠a l·ªói: ${stats.corrections} l·∫ßn`);
```

## üîë Nh·ªØng ƒëi·ªÉm quan tr·ªçng c·∫ßn l∆∞u √Ω

### 1. **T·ªëi ∆∞u b·ªô nh·ªõ**
- Trie c√≥ th·ªÉ t·ªën nhi·ªÅu b·ªô nh·ªõ khi alphabet size l·ªõn
- S·ª≠ d·ª•ng Compressed Trie (Patricia Tree) cho d·ªØ li·ªáu th∆∞a
- C√¢n nh·∫Øc s·ª≠ d·ª•ng array thay v√¨ HashMap cho c√°c b·∫£ng ch·ªØ c√°i nh·ªè

### 2. **X·ª≠ l√Ω k√Ω t·ª± Unicode**
- V·ªõi ti·∫øng Vi·ªát, c·∫ßn x·ª≠ l√Ω ƒë√∫ng c√°c k√Ω t·ª± c√≥ d·∫•u
- S·ª≠ d·ª•ng `Array.from()` thay v√¨ `split('')` ƒë·ªÉ t√°ch chu·ªói Unicode
- C√¢n nh·∫Øc normalize chu·ªói tr∆∞·ªõc khi x·ª≠ l√Ω

### 3. **Chi·∫øn l∆∞·ª£c x√≥a**
- X√≥a trong Trie ph·ª©c t·∫°p h∆°n th√™m v√† t√¨m ki·∫øm
- C·∫ßn ƒë·∫£m b·∫£o kh√¥ng x√≥a nh·∫ßm n√∫t ƒë∆∞·ª£c chia s·∫ª
- S·ª≠ d·ª•ng thu·∫≠t to√°n DFS ƒë·ªÉ x√≥a an to√†n t·ª´ d∆∞·ªõi l√™n

### 4. **C·∫£i thi·ªán hi·ªáu su·∫•t**
- Cache k·∫øt qu·∫£ t√¨m ki·∫øm cho c√°c truy v·∫•n ph·ªï bi·∫øn
- S·ª≠ d·ª•ng lazy evaluation cho vi·ªác thu th·∫≠p t·ª´
- C√¢n nh·∫Øc gi·ªõi h·∫°n ƒë·ªô s√¢u ƒë·ªÉ tr√°nh stack overflow

### 5. **L·ªói th∆∞·ªùng g·∫∑p**
- Qu√™n ƒë√°nh d·∫•u `isCompleteWord = true` khi th√™m t·ª´
- Kh√¥ng ki·ªÉm tra null khi traverse tree
- X·ª≠ l√Ω kh√¥ng ƒë√∫ng tr∆∞·ªùng h·ª£p t·ª´ r·ªóng
- So s√°nh case-sensitive khi kh√¥ng mong mu·ªën

## üìù B√†i t·∫≠p v·ªÅ nh√†

### B√†i t·∫≠p 1: H·ªá th·ªëng URL Shortener v·ªõi Trie

**Y√™u c·∫ßu**: X√¢y d·ª±ng m·ªôt h·ªá th·ªëng r√∫t g·ªçn URL s·ª≠ d·ª•ng Trie ƒë·ªÉ:
- L∆∞u tr·ªØ v√† t√¨m ki·∫øm c√°c URL ƒë√£ ƒë∆∞·ª£c r√∫t g·ªçn
- T·∫°o ra c√°c short URL unique
- H·ªó tr·ª£ t√≠nh nƒÉng custom alias cho URL
- Theo d√µi s·ªë l·∫ßn click cho m·ªói URL
- T√¨m ki·∫øm URL theo domain ho·∫∑c keyword

**G·ª£i √Ω k·ªπ thu·∫≠t**:
- S·ª≠ d·ª•ng Trie ƒë·ªÉ l∆∞u tr·ªØ mapping gi·ªØa short code v√† original URL
- K·∫øt h·ª£p v·ªõi hash table ƒë·ªÉ tƒÉng t·ªëc lookup
- Implement thu·∫≠t to√°n t·∫°o short code t·ª± ƒë·ªông
- Th√™m t√≠nh nƒÉng analytics v√† reporting

### B√†i t·∫≠p 2: Game T·ª´ V·ª±ng Th√¥ng Minh

**Y√™u c·∫ßu**: Ph√°t tri·ªÉn m·ªôt tr√≤ ch∆°i t·ª´ v·ª±ng v·ªõi c√°c t√≠nh nƒÉng:
- Ng∆∞·ªùi ch∆°i t·∫°o t·ª´ b·∫±ng c√°ch th√™m t·ª´ng k√Ω t·ª±
- H·ªá th·ªëng g·ª£i √Ω k√Ω t·ª± ti·∫øp theo c√≥ th·ªÉ t·∫°o th√†nh t·ª´ h·ª£p l·ªá
- T√≠nh ƒëi·ªÉm d·ª±a tr√™n ƒë·ªô d√†i v√† ƒë·ªô hi·∫øm c·ªßa t·ª´
- Ch·∫ø ƒë·ªô th·ª≠ th√°ch v·ªõi th·ªùi gian gi·ªõi h·∫°n
- H·ªó tr·ª£ nhi·ªÅu ng√¥n ng·ªØ (ti·∫øng Anh, ti·∫øng Vi·ªát)
- L∆∞u tr·ªØ high score v√† th·ªëng k√™ ng∆∞·ªùi ch∆°i

**G·ª£i √Ω k·ªπ thu·∫≠t**:
- S·ª≠ d·ª•ng multiple Tries cho c√°c ng√¥n ng·ªØ kh√°c nhau
- Implement scoring algorithm d·ª±a tr√™n word frequency
- T·∫°o hint system th√¥ng minh
- Thi·∫øt k·∫ø game mechanics h·∫•p d·∫´n v·ªõi power-ups

---

*Post ID: 20631ez34tld1ce*  
*Category: Data Structures*  
*Created: 19/8/2025*  
*Updated: 27/8/2025*
