# B√†i 6: Middleware



## üéØ M·ª•c ti√™u b√†i h·ªçc

Sau khi ho√†n th√†nh b√†i h·ªçc n√†y, h·ªçc vi√™n s·∫Ω c√≥ th·ªÉ:
- Hi·ªÉu kh√°i ni·ªám Middleware v√† c√°ch ho·∫°t ƒë·ªông trong Next.js
- T·∫°o v√† c·∫•u h√¨nh Middleware cho authentication, logging, v√† redirects
- S·ª≠ d·ª•ng NextRequest v√† NextResponse ƒë·ªÉ x·ª≠ l√Ω requests/responses
- √Åp d·ª•ng Middleware patterns ph·ªï bi·∫øn trong d·ª± √°n th·ª±c t·∫ø
- T·ªëi ∆∞u hi·ªáu su·∫•t v√† b·∫£o m·∫≠t v·ªõi Middleware

## üìù N·ªôi dung chi ti·∫øt

### 1. Middleware l√† g√¨?

Middleware trong Next.js l√† code ch·∫°y tr∆∞·ªõc khi request ƒë∆∞·ª£c ho√†n th√†nh. N√≥ cho ph√©p b·∫°n:

- **Rewrite**: Thay ƒë·ªïi response b·∫±ng c√°ch rewrite URL
- **Redirect**: Chuy·ªÉn h∆∞·ªõng requests ƒë·∫øn URL kh√°c
- **Modify request/response headers**: Th√™m, s·ª≠a, x√≥a headers
- **Authentication**: Ki·ªÉm tra quy·ªÅn truy c·∫≠p
- **Logging**: Ghi log requests
- **Feature flagging**: B·∫≠t/t·∫Øt features d·ª±a tr√™n conditions

Middleware ch·∫°y tr√™n **Edge Runtime**, c√≥ nghƒ©a l√† n√≥ c√≥ hi·ªáu su·∫•t cao v√† ƒë·ªô tr·ªÖ th·∫•p.

### 2. C√°ch t·∫°o Middleware

#### T·∫°o file middleware.ts
T·∫°o file `middleware.ts` (ho·∫∑c `middleware.js`) ·ªü root c·ªßa project (c√πng c·∫•p v·ªõi `app/`):

```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // Middleware logic ·ªü ƒë√¢y
  console.log('Middleware ƒëang ch·∫°y cho:', request.url)
  
  // Cho ph√©p request ti·∫øp t·ª•c
  return NextResponse.next()
}

// C·∫•u h√¨nh matcher - Middleware s·∫Ω ch·∫°y cho nh·ªØng paths n√†o
export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

#### C·∫•u tr√∫c c∆° b·∫£n c·ªßa Middleware
```typescript
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Log request
  console.log(`${request.method} ${pathname}`)
  
  // Ki·ªÉm tra conditions
  if (pathname.startsWith('/admin')) {
    // Logic cho admin routes
    return handleAdminRoutes(request)
  }
  
  if (pathname.startsWith('/api')) {
    // Logic cho API routes
    return handleApiRoutes(request)
  }
  
  // Default: cho ph√©p request ti·∫øp t·ª•c
  return NextResponse.next()
}

function handleAdminRoutes(request: NextRequest) {
  // Implementation s·∫Ω th√™m sau
  return NextResponse.next()
}

function handleApiRoutes(request: NextRequest) {
  // Implementation s·∫Ω th√™m sau
  return NextResponse.next()
}
```

### 3. Matcher Configuration

Matcher cho ph√©p b·∫°n filter paths m√† Middleware s·∫Ω ch·∫°y:

```typescript
export const config = {
  // Ch·ªâ ch·∫°y cho specific paths
  matcher: '/dashboard/:path*',
}

// Multiple matchers
export const config = {
  matcher: [
    '/dashboard/:path*',
    '/admin/:path*',
    '/api/:path*'
  ],
}

// Regex patterns
export const config = {
  matcher: [
    // Match t·∫•t c·∫£ tr·ª´ static files v√† API routes
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}

// Conditional matching
export const config = {
  matcher: [
    // Match admin routes nh∆∞ng kh√¥ng match admin/public
    '/admin/((?!public).*)',
  ],
}
```

### 4. Authentication Middleware

#### Basic Authentication Check
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Protected routes
  const protectedPaths = ['/dashboard', '/profile', '/admin']
  const isProtectedPath = protectedPaths.some(path => 
    pathname.startsWith(path)
  )
  
  if (isProtectedPath) {
    return checkAuthentication(request)
  }
  
  return NextResponse.next()
}

function checkAuthentication(request: NextRequest) {
  // Ki·ªÉm tra token t·ª´ cookie
  const token = request.cookies.get('auth-token')?.value
  
  if (!token) {
    // Redirect ƒë·∫øn login page
    const loginUrl = new URL('/login', request.url)
    loginUrl.searchParams.set('redirect', request.nextUrl.pathname)
    return NextResponse.redirect(loginUrl)
  }
  
  // Validate token (simplified - trong th·ª±c t·∫ø c·∫ßn verify JWT)
  if (!isValidToken(token)) {
    // Clear invalid token v√† redirect
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.cookies.delete('auth-token')
    return response
  }
  
  return NextResponse.next()
}

function isValidToken(token: string): boolean {
  // Simplified validation - trong th·ª±c t·∫ø c·∫ßn verify JWT signature
  try {
    // Basic check - token kh√¥ng empty v√† c√≥ format ƒë√∫ng
    return token.length > 10 && token.includes('.')
  } catch {
    return false
  }
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|login|register).*)',
  ],
}
```

#### Role-based Access Control
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { jwtVerify } from 'jose'

interface UserPayload {
  id: string
  email: string
  role: 'user' | 'admin' | 'moderator'
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Admin routes - ch·ªâ admin m·ªõi ƒë∆∞·ª£c truy c·∫≠p
  if (pathname.startsWith('/admin')) {
    return await checkAdminAccess(request)
  }
  
  // Moderator routes
  if (pathname.startsWith('/moderate')) {
    return await checkModeratorAccess(request)
  }
  
  // Protected routes - c·∫ßn ƒëƒÉng nh·∫≠p
  const protectedPaths = ['/dashboard', '/profile', '/settings']
  const isProtectedPath = protectedPaths.some(path => 
    pathname.startsWith(path)
  )
  
  if (isProtectedPath) {
    return await checkAuthentication(request)
  }
  
  return NextResponse.next()
}

async function checkAdminAccess(request: NextRequest) {
  try {
    const user = await getCurrentUser(request)
    
    if (!user || user.role !== 'admin') {
      return NextResponse.redirect(new URL('/unauthorized', request.url))
    }
    
    return NextResponse.next()
  } catch {
    return NextResponse.redirect(new URL('/login', request.url))
  }
}

async function checkModeratorAccess(request: NextRequest) {
  try {
    const user = await getCurrentUser(request)
    
    if (!user || !['admin', 'moderator'].includes(user.role)) {
      return NextResponse.redirect(new URL('/unauthorized', request.url))
    }
    
    return NextResponse.next()
  } catch {
    return NextResponse.redirect(new URL('/login', request.url))
  }
}

async function checkAuthentication(request: NextRequest) {
  try {
    const user = await getCurrentUser(request)
    
    if (!user) {
      const loginUrl = new URL('/login', request.url)
      loginUrl.searchParams.set('redirect', request.nextUrl.pathname)
      return NextResponse.redirect(loginUrl)
    }
    
    return NextResponse.next()
  } catch {
    return NextResponse.redirect(new URL('/login', request.url))
  }
}

async function getCurrentUser(request: NextRequest): Promise<UserPayload | null> {
  try {
    const token = request.cookies.get('auth-token')?.value
    
    if (!token) {
      return null
    }
    
    // Verify JWT token
    const secret = new TextEncoder().encode(
      process.env.JWT_SECRET || 'your-secret-key'
    )
    
    const { payload } = await jwtVerify(token, secret)
    
    return payload as UserPayload
  } catch {
    return null
  }
}
```

### 5. Request/Response Manipulation

#### Adding Headers
```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // Add security headers
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'origin-when-cross-origin')
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline'"
  )
  
  // Add custom headers
  response.headers.set('X-Request-ID', generateRequestId())
  response.headers.set('X-Timestamp', new Date().toISOString())
  
  return response
}

function generateRequestId(): string {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15)
}
```

#### CORS Configuration
```typescript
export function middleware(request: NextRequest) {
  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    return new Response(null, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    })
  }
  
  const response = NextResponse.next()
  
  // Add CORS headers
  response.headers.set('Access-Control-Allow-Origin', '*')
  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization')
  
  return response
}

export const config = {
  matcher: '/api/:path*',
}
```

### 6. Redirects v√† Rewrites

#### Conditional Redirects
```typescript
export function middleware(request: NextRequest) {
  const { pathname, search } = request.nextUrl
  
  // Redirect old URLs
  if (pathname === '/old-dashboard') {
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }
  
  // Maintenance mode
  if (process.env.MAINTENANCE_MODE === 'true') {
    if (!pathname.startsWith('/maintenance') && !pathname.startsWith('/api')) {
      return NextResponse.redirect(new URL('/maintenance', request.url))
    }
  }
  
  // Feature flagging
  const hasNewFeature = request.cookies.get('new-feature-enabled')?.value === 'true'
  if (pathname === '/dashboard' && hasNewFeature) {
    return NextResponse.rewrite(new URL('/dashboard-v2', request.url))
  }
  
  // A/B Testing
  if (pathname === '/pricing') {
    const variant = getABTestVariant(request)
    if (variant === 'b') {
      return NextResponse.rewrite(new URL('/pricing-v2', request.url))
    }
  }
  
  return NextResponse.next()
}

function getABTestVariant(request: NextRequest): 'a' | 'b' {
  // Check if user already has variant stored
  const storedVariant = request.cookies.get('ab-test-variant')?.value
  if (storedVariant === 'a' || storedVariant === 'b') {
    return storedVariant
  }
  
  // Assign new variant (50/50 split)
  return Math.random() < 0.5 ? 'a' : 'b'
}
```

#### Internationalization (i18n) Redirects
```typescript
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Supported locales
  const locales = ['en', 'vi', 'ja', 'ko']
  
  // Check if pathname has locale
  const pathnameHasLocale = locales.some(
    locale => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
  
  if (!pathnameHasLocale) {
    // Get preferred locale
    const locale = getPreferredLocale(request)
    
    // Redirect to localized version
    const localizedUrl = new URL(`/${locale}${pathname}`, request.url)
    return NextResponse.redirect(localizedUrl)
  }
  
  return NextResponse.next()
}

function getPreferredLocale(request: NextRequest): string {
  // Check cookie first
  const cookieLocale = request.cookies.get('preferred-locale')?.value
  if (cookieLocale && ['en', 'vi', 'ja', 'ko'].includes(cookieLocale)) {
    return cookieLocale
  }
  
  // Check Accept-Language header
  const acceptLanguage = request.headers.get('Accept-Language')
  if (acceptLanguage) {
    if (acceptLanguage.includes('vi')) return 'vi'
    if (acceptLanguage.includes('ja')) return 'ja'
    if (acceptLanguage.includes('ko')) return 'ko'
  }
  
  // Default to English
  return 'en'
}
```

### 7. Rate Limiting

#### Simple Rate Limiting
```typescript
// middleware.ts
const rateLimitMap = new Map<string, { count: number; lastReset: number }>()

export function middleware(request: NextRequest) {
  // Apply rate limiting to API routes
  if (request.nextUrl.pathname.startsWith('/api')) {
    return applyRateLimit(request)
  }
  
  return NextResponse.next()
}

function applyRateLimit(request: NextRequest) {
  const ip = getClientIP(request)
  const limit = 100 // requests per window
  const windowMs = 15 * 60 * 1000 // 15 minutes
  
  const now = Date.now()
  const userLimit = rateLimitMap.get(ip) || { count: 0, lastReset: now }
  
  // Reset count if window has passed
  if (now - userLimit.lastReset > windowMs) {
    userLimit.count = 0
    userLimit.lastReset = now
  }
  
  userLimit.count++
  rateLimitMap.set(ip, userLimit)
  
  // Check if limit exceeded
  if (userLimit.count > limit) {
    return new NextResponse(
      JSON.stringify({ 
        error: 'Too Many Requests',
        retryAfter: Math.ceil((userLimit.lastReset + windowMs - now) / 1000)
      }),
      {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'Retry-After': String(Math.ceil((userLimit.lastReset + windowMs - now) / 1000))
        },
      }
    )
  }
  
  // Add rate limit headers
  const response = NextResponse.next()
  response.headers.set('X-RateLimit-Limit', String(limit))
  response.headers.set('X-RateLimit-Remaining', String(limit - userLimit.count))
  response.headers.set('X-RateLimit-Reset', String(userLimit.lastReset + windowMs))
  
  return response
}

function getClientIP(request: NextRequest): string {
  // Try to get real IP from various headers
  const forwarded = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  const cfConnectingIp = request.headers.get('cf-connecting-ip')
  
  if (forwarded) {
    return forwarded.split(',')[0].trim()
  }
  if (realIp) {
    return realIp
  }
  if (cfConnectingIp) {
    return cfConnectingIp
  }
  
  return request.ip || 'unknown'
}
```

### 8. Logging v√† Monitoring

#### Request Logging
```typescript
export function middleware(request: NextRequest) {
  const start = Date.now()
  const requestId = generateRequestId()
  
  // Log incoming request
  logRequest({
    requestId,
    method: request.method,
    url: request.url,
    userAgent: request.headers.get('User-Agent'),
    ip: getClientIP(request),
    timestamp: new Date().toISOString(),
  })
  
  const response = NextResponse.next()
  
  // Add request ID to response
  response.headers.set('X-Request-ID', requestId)
  
  // Log response (this runs after the response is ready)
  Promise.resolve().then(() => {
    const duration = Date.now() - start
    logResponse({
      requestId,
      status: response.status,
      duration,
      timestamp: new Date().toISOString(),
    })
  })
  
  return response
}

interface RequestLog {
  requestId: string
  method: string
  url: string
  userAgent: string | null
  ip: string
  timestamp: string
}

interface ResponseLog {
  requestId: string
  status: number
  duration: number
  timestamp: string
}

function logRequest(data: RequestLog) {
  // In production, send to logging service (DataDog, CloudWatch, etc.)
  console.log('[REQUEST]', JSON.stringify(data))
}

function logResponse(data: ResponseLog) {
  console.log('[RESPONSE]', JSON.stringify(data))
}
```

## üèÜ B√†i t·∫≠p th·ª±c h√†nh

### ƒê·ªÅ b√†i: X√¢y d·ª±ng Authentication & Security Middleware

T·∫°o m·ªôt middleware system ho√†n ch·ªânh v·ªõi c√°c t√≠nh nƒÉng:
1. **Authentication**: JWT-based v·ªõi role checking
2. **Rate Limiting**: API rate limiting per IP
3. **Security Headers**: CORS, CSP, v√† security headers kh√°c
4. **Logging**: Request/response logging v·ªõi monitoring
5. **A/B Testing**: Feature flagging v√† A/B testing

### L·ªùi gi·∫£i chi ti·∫øt:

**B∆∞·ªõc 1**: Setup d·ª± √°n
```bash
npx create-next-app@latest secure-app --typescript --tailwind --eslint --app
cd secure-app
npm install jose
```

**B∆∞·ªõc 2**: Environment variables
```bash
# .env.local
JWT_SECRET=your-super-secret-jwt-key-here
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

**B∆∞·ªõc 3**: Middleware ch√≠nh
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { jwtVerify } from 'jose'

// Rate limiting storage
const rateLimitMap = new Map<string, { count: number; lastReset: number }>()

// A/B test variants storage
const abTestMap = new Map<string, string>()

interface UserPayload {
  id: string
  email: string
  role: 'user' | 'admin' | 'moderator'
}

export async function middleware(request: NextRequest) {
  const start = Date.now()
  const requestId = generateRequestId()
  
  // Log incoming request
  logRequest(request, requestId)
  
  // Apply security headers
  const response = await processRequest(request)
  
  // Add common headers
  addSecurityHeaders(response)
  response.headers.set('X-Request-ID', requestId)
  
  // Log response timing
  const duration = Date.now() - start
  console.log(`[MIDDLEWARE] ${request.method} ${request.nextUrl.pathname} - ${duration}ms`)
  
  return response
}

async function processRequest(request: NextRequest): Promise<NextResponse> {
  const { pathname } = request.nextUrl
  
  // Apply rate limiting to API routes
  if (pathname.startsWith('/api')) {
    const rateLimitResponse = applyRateLimit(request)
    if (rateLimitResponse) return rateLimitResponse
  }
  
  // Handle authentication for protected routes
  if (isProtectedRoute(pathname)) {
    return await handleAuthentication(request)
  }
  
  // Handle admin routes
  if (pathname.startsWith('/admin')) {
    return await handleAdminAccess(request)
  }
  
  // A/B testing for specific pages
  if (pathname === '/pricing') {
    return handleABTesting(request)
  }
  
  return NextResponse.next()
}

function isProtectedRoute(pathname: string): boolean {
  const protectedPaths = [
    '/dashboard',
    '/profile',
    '/settings',
    '/account'
  ]
  
  return protectedPaths.some(path => pathname.startsWith(path))
}

async function handleAuthentication(request: NextRequest): Promise<NextResponse> {
  try {
    const user = await getCurrentUser(request)
    
    if (!user) {
      return redirectToLogin(request)
    }
    
    // Add user info to request headers for downstream use
    const response = NextResponse.next()
    response.headers.set('X-User-ID', user.id)
    response.headers.set('X-User-Role', user.role)
    
    return response
  } catch (error) {
    console.error('[AUTH ERROR]', error)
    return redirectToLogin(request)
  }
}

async function handleAdminAccess(request: NextRequest): Promise<NextResponse> {
  try {
    const user = await getCurrentUser(request)
    
    if (!user) {
      return redirectToLogin(request)
    }
    
    if (user.role !== 'admin') {
      return NextResponse.redirect(new URL('/unauthorized', request.url))
    }
    
    const response = NextResponse.next()
    response.headers.set('X-User-ID', user.id)
    response.headers.set('X-User-Role', user.role)
    
    return response
  } catch {
    return redirectToLogin(request)
  }
}

async function getCurrentUser(request: NextRequest): Promise<UserPayload | null> {
  try {
    const token = request.cookies.get('auth-token')?.value
    
    if (!token) {
      return null
    }
    
    const secret = new TextEncoder().encode(
      process.env.JWT_SECRET || 'fallback-secret'
    )
    
    const { payload } = await jwtVerify(token, secret)
    return payload as UserPayload
  } catch (error) {
    console.error('[JWT VERIFY ERROR]', error)
    return null
  }
}

function redirectToLogin(request: NextRequest): NextResponse {
  const loginUrl = new URL('/login', request.url)
  loginUrl.searchParams.set('redirect', request.nextUrl.pathname)
  return NextResponse.redirect(loginUrl)
}

function applyRateLimit(request: NextRequest): NextResponse | null {
  const ip = getClientIP(request)
  const limit = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100')
  const windowMs = parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000') // 15 minutes
  
  const now = Date.now()
  const userLimit = rateLimitMap.get(ip) || { count: 0, lastReset: now }
  
  // Reset if window expired
  if (now - userLimit.lastReset > windowMs) {
    userLimit.count = 0
    userLimit.lastReset = now
  }
  
  userLimit.count++
  rateLimitMap.set(ip, userLimit)
  
  if (userLimit.count > limit) {
    const retryAfter = Math.ceil((userLimit.lastReset + windowMs - now) / 1000)
    
    return new NextResponse(
      JSON.stringify({
        error: 'Too Many Requests',
        message: `Rate limit exceeded. Try again in ${retryAfter} seconds.`,
        retryAfter
      }),
      {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'Retry-After': String(retryAfter),
          'X-RateLimit-Limit': String(limit),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': String(userLimit.lastReset + windowMs)
        }
      }
    )
  }
  
  return null
}

function handleABTesting(request: NextRequest): NextResponse {
  const ip = getClientIP(request)
  let variant = abTestMap.get(ip)
  
  if (!variant) {
    // Assign variant (70% A, 30% B)
    variant = Math.random() < 0.7 ? 'a' : 'b'
    abTestMap.set(ip, variant)
  }
  
  if (variant === 'b') {
    return NextResponse.rewrite(new URL('/pricing-v2', request.url))
  }
  
  const response = NextResponse.next()
  response.headers.set('X-AB-Variant', variant)
  
  return response
}

function addSecurityHeaders(response: NextResponse) {
  // Security headers
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'origin-when-cross-origin')
  response.headers.set('X-XSS-Protection', '1; mode=block')
  response.headers.set(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains'
  )
  
  // CSP Header
  response.headers.set(
    'Content-Security-Policy',
    [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.example.com",
      "frame-ancestors 'none'"
    ].join('; ')
  )
}

function getClientIP(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  const cfConnectingIp = request.headers.get('cf-connecting-ip')
  
  if (forwarded) return forwarded.split(',')[0].trim()
  if (realIp) return realIp
  if (cfConnectingIp) return cfConnectingIp
  
  return request.ip || 'unknown'
}

function generateRequestId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substr(2)
}

function logRequest(request: NextRequest, requestId: string) {
  const logData = {
    requestId,
    method: request.method,
    url: request.url,
    userAgent: request.headers.get('User-Agent'),
    ip: getClientIP(request),
    timestamp: new Date().toISOString(),
  }
  
  console.log('[REQUEST]', JSON.stringify(logData, null, 2))
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
```

**B∆∞·ªõc 4**: API Route ƒë·ªÉ test rate limiting
```typescript
// app/api/test/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  // Get user info from middleware headers
  const userId = request.headers.get('X-User-ID')
  const userRole = request.headers.get('X-User-Role')
  const requestId = request.headers.get('X-Request-ID')
  
  return NextResponse.json({
    message: 'API test successful',
    user: userId ? { id: userId, role: userRole } : null,
    requestId,
    timestamp: new Date().toISOString()
  })
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  
  return NextResponse.json({
    message: 'Data received',
    data: body,
    requestId: request.headers.get('X-Request-ID')
  })
}
```

**B∆∞·ªõc 5**: Test pages
```tsx
// app/login/page.tsx
'use client'
import { useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const searchParams = useSearchParams()
  const redirectTo = searchParams.get('redirect') || '/dashboard'

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)

    try {
      // Mock login - in real app, call your auth API
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      })

      if (response.ok) {
        router.push(redirectTo)
      } else {
        alert('Login failed')
      }
    } catch (error) {
      alert('Login error')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleLogin}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <input
                type="email"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div>
              <input
                type="password"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
            >
              {loading ? 'Signing in...' : 'Sign in'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
```

**B∆∞·ªõc 6**: Protected Dashboard
```tsx
// app/dashboard/page.tsx
export default function DashboardPage() {
  return (
    <div className="min-h-screen bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white overflow-hidden shadow rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <h1 className="text-2xl font-bold text-gray-900 mb-4">
              Dashboard
            </h1>
            <p className="text-gray-600 mb-6">
              Welcome to your protected dashboard! This page is only accessible to authenticated users.
            </p>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="bg-blue-50 p-4 rounded-lg">
                <h3 className="font-semibold text-blue-900">Total Users</h3>
                <p className="text-2xl font-bold text-blue-600">1,234</p>
              </div>
              <div className="bg-green-50 p-4 rounded-lg">
                <h3 className="font-semibold text-green-900">Revenue</h3>
                <p className="text-2xl font-bold text-green-600">$56,789</p>
              </div>
              <div className="bg-purple-50 p-4 rounded-lg">
                <h3 className="font-semibold text-purple-900">Orders</h3>
                <p className="text-2xl font-bold text-purple-600">890</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
```

**Gi·∫£i th√≠ch logic:**
1. **Authentication Flow**: JWT verification v·ªõi role-based access
2. **Rate Limiting**: Per-IP rate limiting cho API routes
3. **Security Headers**: Comprehensive security headers
4. **Logging**: Request/response logging v·ªõi unique request IDs
5. **A/B Testing**: Simple variant assignment v√† rewriting

## üîë Nh·ªØng ƒëi·ªÉm quan tr·ªçng c·∫ßn l∆∞u √Ω

1. **Edge Runtime Limitations**:
   - Kh√¥ng th·ªÉ s·ª≠ d·ª•ng Node.js APIs
   - Gi·ªõi h·∫°n memory v√† execution time
   - Ch·ªâ support m·ªôt subset c·ªßa Web APIs

2. **Performance Considerations**:
   - Middleware ch·∫°y cho m·ªçi request matching pattern
   - Keep logic minimal v√† fast
   - Avoid complex computations

3. **Security Best Practices**:
   - Always validate v√† sanitize inputs
   - Use secure headers
   - Implement proper rate limiting
   - Log security events

4. **Debugging**:
   - Use console.log cho development
   - Implement structured logging cho production
   - Monitor middleware performance

5. **Testing**:
   - Test middleware logic separately
   - Use integration tests cho full request flow
   - Mock external dependencies

## üìù B√†i t·∫≠p v·ªÅ nh√†

X√¢y d·ª±ng m·ªôt **Multi-tenant SaaS Middleware System** v·ªõi c√°c t√≠nh nƒÉng:

### Y√™u c·∫ßu ch√≠nh:
1. **Tenant Detection**: 
   - Subdomain-based tenant detection (tenant1.app.com)
   - Custom domain support (custom-domain.com)
   - Tenant-specific routing v√† configuration

2. **Advanced Authentication**:
   - Multi-factor authentication support
   - Session management v·ªõi Redis (mock)
   - OAuth provider integration simulation

3. **Advanced Security**:
   - IP whitelisting per tenant
   - Advanced rate limiting (per user, per endpoint)
   - Request signing verification
   - Audit logging

4. **Feature Management**:
   - Tenant-specific feature flags
   - Usage quotas per tenant
   - Plan-based access control

### C·∫•u tr√∫c middleware:
```typescript
// middleware.ts structure
export async function middleware(request: NextRequest) {
  // 1. Tenant detection & validation
  const tenant = await detectTenant(request)
  
  // 2. Security checks (IP whitelist, etc.)
  await performSecurityChecks(request, tenant)
  
  // 3. Authentication & authorization
  await authenticateRequest(request, tenant)
  
  // 4. Feature flag evaluation
  await evaluateFeatureFlags(request, tenant)
  
  // 5. Usage quota checking
  await checkUsageQuotas(request, tenant)
  
  // 6. Request routing & rewriting
  return routeRequest(request, tenant)
}
```

### Y√™u c·∫ßu k·ªπ thu·∫≠t:
- TypeScript v·ªõi proper interfaces cho tenant, user, features
- Comprehensive error handling v√† logging
- Mock external services (Redis, OAuth providers)
- Rate limiting v·ªõi different strategies
- Monitoring v√† alerting hooks
- Configuration management per tenant

### Bonus features:
- Geo-based routing
- Request caching strategies
- Real-time usage monitoring
- Automated security threat detection
- Dynamic configuration updates
