# B√†i 5: H∆∞·ªõng d·∫´n Textures v√† Bind Groups trong WebGPU

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-900 mb-4">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <ul className="space-y-2 text-blue-800">
    <li>‚úÖ Hi·ªÉu kh√°i ni·ªám Texture v√† ·ª©ng d·ª•ng trong ƒë·ªì h·ªça 3D</li>
    <li>‚úÖ H·ªçc c√°ch t·∫£i v√† x·ª≠ l√Ω h√¨nh ·∫£nh t·ª´ file</li>
    <li>‚úÖ N·∫Øm v·ªØng c√°ch s·ª≠ d·ª•ng TextureView v√† Sampler</li>
    <li>‚úÖ L√†m ch·ªß BindGroup v√† PipelineLayout</li>
    <li>‚úÖ Th·ª±c h√†nh t·∫°o m·ªôt ·ª©ng d·ª•ng hi·ªÉn th·ªã texture ho√†n ch·ªânh</li>
  </ul>
</div>

## 1. Gi·ªõi thi·ªáu v·ªÅ Textures

### 1.1 Texture l√† g√¨?

**Texture** l√† h√¨nh ·∫£nh ƒë∆∞·ª£c √°p l√™n b·ªÅ m·∫∑t c√°c ƒë·ªëi t∆∞·ª£ng 3D ƒë·ªÉ t·∫°o ra chi ti·∫øt v√† ƒë·ªô s·ªëng ƒë·ªông. Thay v√¨ v·∫Ω h√†ng tri·ªáu tam gi√°c ƒë·ªÉ t·∫°o chi ti·∫øt, ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng texture ƒë·ªÉ "l·ª´a" m·∫Øt ng∆∞·ªùi xem.

```mermaid
graph TD
    A[3D Mesh ƒë∆°n gi·∫£n] --> B[√Åp d·ª•ng Texture]
    B --> C[ƒê·ªëi t∆∞·ª£ng 3D chi ti·∫øt]
    
    D[Hi·ªáu su·∫•t cao] --> B
    E[Chi ti·∫øt phong ph√∫] --> C
    
    style A fill:#ffcccc
    style C fill:#ccffcc
    style B fill:#ccccff
```

### 1.2 C√°c lo·∫°i Texture ph·ªï bi·∫øn

| Lo·∫°i Texture | M·ª•c ƒë√≠ch | V√≠ d·ª• |
|--------------|----------|--------|
| **Diffuse Map** | M√†u s·∫Øc c∆° b·∫£n c·ªßa v·∫≠t li·ªáu | M√†u g·ªó, m√†u da |
| **Normal Map** | Chi ti·∫øt b·ªÅ m·∫∑t (ƒë·ªô g·ªì gh·ªÅ) | V·∫øt n·ª©t, v√¢n g·ªó |
| **Specular Map** | ƒê·ªô b√≥ng/ph·∫£n chi·∫øu | Kim lo·∫°i, nh·ª±a |
| **Bump Map** | ƒê·ªô nh·∫•p nh√¥ nh·ªè | ƒê·ªô nh√°m c·ªßa b·ªÅ m·∫∑t |

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-6">
  <p className="text-yellow-800"><strong>üìù L∆∞u √Ω:</strong> Trong b√†i h·ªçc n√†y, ch√∫ng ta s·∫Ω t·∫≠p trung v√†o <strong>Diffuse Texture</strong> - lo·∫°i texture c∆° b·∫£n nh·∫•t ƒë·ªÉ hi·ªÉn th·ªã m√†u s·∫Øc.</p>
</div>

## 2. Chu·∫©n b·ªã v√† t·∫£i h√¨nh ·∫£nh

### 2.1 C√†i ƒë·∫∑t th∆∞ vi·ªán c·∫ßn thi·∫øt

Th√™m v√†o `Cargo.toml`:

```toml
[dependencies.image]
version = "0.24"
default-features = false
features = ["png", "jpeg"]

[dependencies]
anyhow = "1.0"
```

### 2.2 Quy tr√¨nh t·∫£i texture

```mermaid
flowchart LR
    A[File h√¨nh ·∫£nh] --> B[T·∫£i v√†o memory]
    B --> C[Chuy·ªÉn ƒë·ªïi RGBA8]
    C --> D[T·∫°o GPU Texture]
    D --> E[S·ª≠ d·ª•ng trong shader]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#9f9,stroke:#333,stroke-width:2px
```

### 2.3 Code t·∫£i texture c∆° b·∫£n

```rust
// T·∫£i h√¨nh ·∫£nh t·ª´ file
let diffuse_bytes = include_bytes!("happy-tree.png");
let diffuse_image = image::load_from_memory(diffuse_bytes).unwrap();
let diffuse_rgba = diffuse_image.to_rgba8();

// L·∫•y k√≠ch th∆∞·ªõc h√¨nh ·∫£nh
use image::GenericImageView;
let dimensions = diffuse_image.dimensions();
```

## 3. T·∫°o GPU Texture

### 3.1 C·∫•u h√¨nh Texture Descriptor

| Tham s·ªë | √ù nghƒ©a | Gi√° tr·ªã th∆∞·ªùng d√πng |
|---------|---------|-------------------|
| `size` | K√≠ch th∆∞·ªõc texture | width √ó height √ó 1 |
| `format` | ƒê·ªãnh d·∫°ng pixel | `Rgba8UnormSrgb` |
| `usage` | C√°ch s·ª≠ d·ª•ng | `TEXTURE_BINDING \| COPY_DST` |
| `dimension` | Lo·∫°i texture | `D2` (2D) |

```rust
let texture_size = wgpu::Extent3d {
    width: dimensions.0,
    height: dimensions.1,
    depth_or_array_layers: 1, // 2D texture n√™n depth = 1
};

let diffuse_texture = device.create_texture(&wgpu::TextureDescriptor {
    size: texture_size,
    mip_level_count: 1,
    sample_count: 1,
    dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8UnormSrgb,
    usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
    label: Some("diffuse_texture"),
    view_formats: &[],
});
```

### 3.2 Ghi d·ªØ li·ªáu v√†o Texture

<div className="bg-green-50 border border-green-200 rounded-lg p-4 my-4">
  <h4 className="text-green-800 font-semibold mb-2">üí° M·∫πo quan tr·ªçng</h4>
  <p className="text-green-700">S·ª≠ d·ª•ng <code>write_texture</code> thay v√¨ t·∫°o buffer trung gian ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t!</p>
</div>

```rust
queue.write_texture(
    wgpu::TexelCopyTextureInfo {
        texture: &diffuse_texture,
        mip_level: 0,
        origin: wgpu::Origin3d::ZERO,
        aspect: wgpu::TextureAspect::All,
    },
    &diffuse_rgba,
    wgpu::TexelCopyBufferLayout {
        offset: 0,
        bytes_per_row: Some(4 * dimensions.0), // 4 bytes per pixel (RGBA)
        rows_per_image: Some(dimensions.1),
    },
    texture_size,
);
```

## 4. TextureView v√† Sampler

### 4.1 TextureView - "C·ª≠a s·ªï" nh√¨n v√†o Texture

```mermaid
graph LR
    A[Texture Data] --> B[TextureView]
    B --> C[Shader c√≥ th·ªÉ truy c·∫≠p]
    
    style A fill:#ffcccc
    style B fill:#ccccff
    style C fill:#ccffcc
```

```rust
let diffuse_texture_view = diffuse_texture.create_view(&wgpu::TextureViewDescriptor::default());
```

### 4.2 Sampler - B·ªô l·∫•y m·∫´u Texture

Sampler quy·∫øt ƒë·ªãnh c√°ch "l·∫•y m√†u" t·ª´ texture khi ƒë∆∞·ª£c y√™u c·∫ßu t·∫°i m·ªôt t·ªça ƒë·ªô c·ª• th·ªÉ.

#### B·∫£ng c√°c tham s·ªë Sampler quan tr·ªçng:

| Tham s·ªë | M√¥ t·∫£ | T√πy ch·ªçn |
|---------|-------|----------|
| **Address Mode** | X·ª≠ l√Ω t·ªça ƒë·ªô ngo√†i [0,1] | `ClampToEdge`, `Repeat`, `MirrorRepeat` |
| **Mag Filter** | L·ªçc khi texture l·ªõn h∆°n pixel | `Linear`, `Nearest` |
| **Min Filter** | L·ªçc khi texture nh·ªè h∆°n pixel | `Linear`, `Nearest` |

<div className="grid grid-cols-1 md:grid-cols-3 gap-4 my-6">
  <div className="bg-blue-50 p-4 rounded border">
    <h5 className="font-bold text-blue-900">ClampToEdge</h5>
    <p className="text-sm text-blue-700">L·∫∑p l·∫°i pixel bi√™n</p>
  </div>
  <div className="bg-green-50 p-4 rounded border">
    <h5 className="font-bold text-green-900">Repeat</h5>
    <p className="text-sm text-green-700">L·∫∑p l·∫°i texture</p>
  </div>
  <div className="bg-purple-50 p-4 rounded border">
    <h5 className="font-bold text-purple-900">MirrorRepeat</h5>
    <p className="text-sm text-purple-700">L·∫∑p l·∫°i v√† l·∫≠t ng∆∞·ª£c</p>
  </div>
</div>

```rust
let diffuse_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
    address_mode_u: wgpu::AddressMode::ClampToEdge,
    address_mode_v: wgpu::AddressMode::ClampToEdge,
    address_mode_w: wgpu::AddressMode::ClampToEdge,
    mag_filter: wgpu::FilterMode::Linear,    // M∆∞·ª£t m√† khi ph√≥ng to
    min_filter: wgpu::FilterMode::Nearest,   // S·∫Øc n√©t khi thu nh·ªè
    mipmap_filter: wgpu::FilterMode::Nearest,
    ..Default::default()
});
```

## 5. BindGroup - Nh√≥m t√†i nguy√™n

### 5.1 Kh√°i ni·ªám BindGroup

```mermaid
graph TB
    A[BindGroupLayout<br/>B·∫£n thi·∫øt k·∫ø] --> B[BindGroup<br/>Th·ª±c th·ªÉ]
    
    C[Texture] --> B
    D[Sampler] --> B
    E[Buffer] --> B
    
    B --> F[Shader c√≥ th·ªÉ s·ª≠ d·ª•ng]
    
    style A fill:#ffeb3b
    style B fill:#4caf50
    style F fill:#2196f3
```

### 5.2 T·∫°o BindGroupLayout

| Binding | Resource Type | Shader Stage | M·ª•c ƒë√≠ch |
|---------|---------------|--------------|----------|
| 0 | Texture | Fragment | L∆∞u tr·ªØ h√¨nh ·∫£nh |
| 1 | Sampler | Fragment | L·∫•y m·∫´u m√†u |

```rust
let texture_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
    entries: &[
        // Binding 0: Texture
        wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Texture {
                multisampled: false,
                view_dimension: wgpu::TextureViewDimension::D2,
                sample_type: wgpu::TextureSampleType::Float { filterable: true },
            },
            count: None,
        },
        // Binding 1: Sampler
        wgpu::BindGroupLayoutEntry {
            binding: 1,
            visibility: wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
            count: None,
        },
    ],
    label: Some("texture_bind_group_layout"),
});
```

### 5.3 T·∫°o BindGroup th·ª±c t·∫ø

```rust
let diffuse_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
    layout: &texture_bind_group_layout,
    entries: &[
        wgpu::BindGroupEntry {
            binding: 0,
            resource: wgpu::BindingResource::TextureView(&diffuse_texture_view),
        },
        wgpu::BindGroupEntry {
            binding: 1,
            resource: wgpu::BindingResource::Sampler(&diffuse_sampler),
        }
    ],
    label: Some("diffuse_bind_group"),
});
```

## 6. C·∫≠p nh·∫≠t Vertex Structure

### 6.1 Thay ƒë·ªïi t·ª´ color sang texture coordinates

| Thu·ªôc t√≠nh c≈© | Thu·ªôc t√≠nh m·ªõi | Lo·∫°i d·ªØ li·ªáu |
|---------------|----------------|--------------|
| `color: [f32; 3]` | `tex_coords: [f32; 2]` | 2D coordinates |

```rust
#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
struct Vertex {
    position: [f32; 3],
    tex_coords: [f32; 2], // Thay th·∫ø color
}
```

### 6.2 C·∫≠p nh·∫≠t VertexBufferLayout

```rust
impl Vertex {
    fn desc() -> wgpu::VertexBufferLayout<'static> {
        use std::mem;
        wgpu::VertexBufferLayout {
            array_stride: mem::size_of::<Vertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // Position
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                // Texture coordinates
                wgpu::VertexAttribute {
                    offset: mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x2, // 2D thay v√¨ 3D
                },
            ]
        }
    }
}
```

### 6.3 ƒê·ªãnh nghƒ©a vertices m·ªõi v·ªõi texture coordinates

<div className="bg-orange-50 border-l-4 border-orange-400 p-4 my-4">
  <p className="text-orange-800"><strong>‚ö†Ô∏è Ch√∫ √Ω v·ªÅ t·ªça ƒë·ªô texture:</strong></p>
  <ul className="list-disc list-inside text-orange-700 mt-2">
    <li>T·ªça ƒë·ªô (0,0) ·ªü g√≥c tr√™n-tr√°i c·ªßa texture</li>
    <li>T·ªça ƒë·ªô (1,1) ·ªü g√≥c d∆∞·ªõi-ph·∫£i c·ªßa texture</li>
    <li>Tr·ª•c Y c·ªßa texture ng∆∞·ª£c v·ªõi tr·ª•c Y c·ªßa world coordinate</li>
  </ul>
</div>

```rust
const VERTICES: &[Vertex] = &[
    Vertex { position: [-0.0868241, 0.49240386, 0.0], tex_coords: [0.4131759, 0.00759614], }, // A
    Vertex { position: [-0.49513406, 0.06958647, 0.0], tex_coords: [0.0048659444, 0.43041354], }, // B
    Vertex { position: [-0.21918549, -0.44939706, 0.0], tex_coords: [0.28081453, 0.949397], }, // C
    Vertex { position: [0.35966998, -0.3473291, 0.0], tex_coords: [0.85967, 0.84732914], }, // D
    Vertex { position: [0.44147372, 0.2347359, 0.0], tex_coords: [0.9414737, 0.2652641], }, // E
];
```

## 7. C·∫≠p nh·∫≠t Shader

### 7.1 Vertex Shader

```wgsl
// Vertex shader
struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) tex_coords: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex_coords: vec2<f32>,
}

@vertex
fn vs_main(model: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.tex_coords = model.tex_coords;
    out.clip_position = vec4<f32>(model.position, 1.0);
    return out;
}
```

### 7.2 Fragment Shader

```wgsl
// Fragment shader
@group(0) @binding(0)
var t_diffuse: texture_2d<f32>;
@group(0) @binding(1)
var s_diffuse: sampler;

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return textureSample(t_diffuse, s_diffuse, in.tex_coords);
}
```

### 7.3 Gi·∫£i th√≠ch c√°c decorator

| Decorator | √ù nghƒ©a |
|-----------|---------|
| `@group(0)` | T∆∞∆°ng ·ª©ng v·ªõi tham s·ªë ƒë·∫ßu ti√™n trong `set_bind_group(0, ...)` |
| `@binding(0)` | T∆∞∆°ng ·ª©ng v·ªõi `binding: 0` trong BindGroupLayout |
| `@binding(1)` | T∆∞∆°ng ·ª©ng v·ªõi `binding: 1` trong BindGroupLayout |

## 8. C·∫≠p nh·∫≠t Pipeline v√† Render

### 8.1 C·∫≠p nh·∫≠t PipelineLayout

```rust
let render_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
    label: Some("Render Pipeline Layout"),
    bind_group_layouts: &[&texture_bind_group_layout], // Th√™m bind group layout
    push_constant_ranges: &[],
});
```

### 8.2 S·ª≠ d·ª•ng BindGroup trong render

```rust
// Trong h√†m render()
render_pass.set_pipeline(&self.render_pipeline);
render_pass.set_bind_group(0, &self.diffuse_bind_group, &[]); // Thi·∫øt l·∫≠p bind group
render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
render_pass.draw_indexed(0..self.num_indices, 0, 0..1);
```

## 9. T·ªëi ∆∞u h√≥a: T·∫°o module Texture

### 9.1 C·∫•u tr√∫c module `texture.rs`

```mermaid
classDiagram
    class Texture {
        +texture: wgpu::Texture
        +view: wgpu::TextureView
        +sampler: wgpu::Sampler
        +from_bytes() Result~Texture~
        +from_image() Result~Texture~
    }
    
    Texture --> wgpu_Texture : contains
    Texture --> wgpu_TextureView : contains
    Texture --> wgpu_Sampler : contains
```

### 9.2 Implementation ho√†n ch·ªânh

```rust
// src/texture.rs
use image::GenericImageView;
use anyhow::*;

pub struct Texture {
    #[allow(unused)]
    pub texture: wgpu::Texture,
    pub view: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
}

impl Texture {
    pub fn from_bytes(
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        bytes: &[u8], 
        label: &str
    ) -> Result<Self> {
        let img = image::load_from_memory(bytes)?;
        Self::from_image(device, queue, &img, Some(label))
    }

    pub fn from_image(
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        img: &image::DynamicImage,
        label: Option<&str>
    ) -> Result<Self> {
        let rgba = img.to_rgba8();
        let dimensions = img.dimensions();

        let size = wgpu::Extent3d {
            width: dimensions.0,
            height: dimensions.1,
            depth_or_array_layers: 1,
        };
        
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label,
            size,
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        queue.write_texture(
            wgpu::TexelCopyTextureInfo {
                aspect: wgpu::TextureAspect::All,
                texture: &texture,
                mip_level: 0,
                origin: wgpu::Origin3d::ZERO,
            },
            &rgba,
            wgpu::TexelCopyBufferLayout {
                offset: 0,
                bytes_per_row: Some(4 * dimensions.0),
                rows_per_image: Some(dimensions.1),
            },
            size,
        );

        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Nearest,
            mipmap_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        Ok(Self { texture, view, sampler })
    }
}
```

## 10. B√†i t·∫≠p th·ª±c h√†nh

<div className="bg-indigo-50 border border-indigo-200 rounded-lg p-6 my-6">
  <h3 className="text-xl font-bold text-indigo-900 mb-4">üöÄ Th·ª≠ th√°ch cho b·∫°n</h3>
  <div className="space-y-3 text-indigo-800">
    <p><strong>C·∫•p ƒë·ªô C∆° b·∫£n:</strong></p>
    <ul className="list-disc list-inside ml-4 space-y-1">
      <li>T·∫°o th√™m m·ªôt texture kh√°c v√† chuy·ªÉn ƒë·ªïi gi·ªØa hai texture khi nh·∫•n ph√≠m Space</li>
      <li>Th·ª≠ nghi·ªám v·ªõi c√°c filter mode kh√°c nhau (Linear vs Nearest)</li>
    </ul>
    
    <p><strong>C·∫•p ƒë·ªô N√¢ng cao:</strong></p>
    <ul className="list-disc list-inside ml-4 space-y-1">
      <li>T·∫°o m·ªôt h·ªá th·ªëng qu·∫£n l√Ω nhi·ªÅu texture</li>
      <li>Th·ª≠ nghi·ªám v·ªõi address mode Repeat ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng l·∫∑p texture</li>
      <li>T·∫°o animation chuy·ªÉn ƒë·ªïi texture m∆∞·ª£t m√†</li>
    </ul>
  </div>
</div>

## 11. T√≥m t·∫Øt ki·∫øn th·ª©c

### Quy tr√¨nh ho√†n ch·ªânh s·ª≠ d·ª•ng Texture:

```mermaid
graph TD
    A[1. T·∫£i file h√¨nh ·∫£nh] --> B[2. Chuy·ªÉn ƒë·ªïi th√†nh RGBA8]
    B --> C[3. T·∫°o GPU Texture]
    C --> D[4. T·∫°o TextureView]
    D --> E[5. T·∫°o Sampler]
    E --> F[6. T·∫°o BindGroupLayout]
    F --> G[7. T·∫°o BindGroup]
    G --> H[8. C·∫≠p nh·∫≠t Pipeline]
    H --> I[9. S·ª≠ d·ª•ng trong Shader]
    
    style A fill:#ffcccc
    style I fill:#ccffcc
    style F fill:#ccccff
```

### C√°c kh√°i ni·ªám quan tr·ªçng c·∫ßn nh·ªõ:

| Kh√°i ni·ªám | Vai tr√≤ | Quan h·ªá |
|-----------|---------|---------|
| **Texture** | L∆∞u tr·ªØ d·ªØ li·ªáu h√¨nh ·∫£nh tr√™n GPU | D·ªØ li·ªáu th√¥ |
| **TextureView** | Cung c·∫•p c√°ch truy c·∫≠p Texture | Giao di·ªán truy c·∫≠p |
| **Sampler** | ƒê·ªãnh nghƒ©a c√°ch l·∫•y m·∫´u t·ª´ Texture | Ph∆∞∆°ng th·ª©c truy c·∫≠p |
| **BindGroup** | Nh√≥m t√†i nguy√™n ƒë·ªÉ shader s·ª≠ d·ª•ng | Container |
| **BindGroupLayout** | ƒê·ªãnh nghƒ©a c·∫•u tr√∫c BindGroup | B·∫£n thi·∫øt k·∫ø |

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mt-8">
  <h4 className="text-green-800 font-semibold mb-2">üéâ Ch√∫c m·ª´ng!</h4>
  <p className="text-green-700">B·∫°n ƒë√£ ho√†n th√†nh b√†i h·ªçc v·ªÅ Textures v√† BindGroups. B√¢y gi·ªù b·∫°n c√≥ th·ªÉ t·∫°o ra nh·ªØng ƒë·ªëi t∆∞·ª£ng 3D s·ªëng ƒë·ªông v·ªõi h√¨nh ·∫£nh th·ª±c t·∫ø!</p>
</div>

---

*B√†i h·ªçc ti·∫øp theo: Camera v√† Uniform Buffers - H·ªçc c√°ch ƒëi·ªÅu khi·ªÉn g√≥c nh√¨n trong kh√¥ng gian 3D*