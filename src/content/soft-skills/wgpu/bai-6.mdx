# B√†i 6: Uniform Buffers v√† Camera 3D trong WGPU

<div className="bg-gradient-to-r from-blue-100 to-purple-100 p-6 rounded-lg shadow-md mb-8">
  <h2 className="text-2xl font-bold text-gray-800 mb-4">üéØ M·ª•c ti√™u h·ªçc t·∫≠p</h2>
  <ul className="list-disc list-inside text-gray-700 space-y-2">
    <li>Hi·ªÉu v·ªÅ h·ªá th·ªëng camera 3D v√† ma tr·∫≠n view-projection</li>
    <li>H·ªçc c√°ch s·ª≠ d·ª•ng Uniform Buffers ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu v√†o shader</li>
    <li>T·∫°o v√† qu·∫£n l√Ω bind groups cho uniform buffers</li>
    <li>X√¢y d·ª±ng h·ªá th·ªëng ƒëi·ªÅu khi·ªÉn camera c∆° b·∫£n</li>
  </ul>
</div>

## üìö 1. Gi·ªõi thi·ªáu v·ªÅ Camera 3D

M·∫∑c d√π c√°c b√†i tr∆∞·ªõc c√≥ v·∫ª nh∆∞ l√†m vi·ªác trong kh√¥ng gian 2D, nh∆∞ng th·ª±c t·∫ø ch√∫ng ta ƒë√£ l√†m vi·ªác trong kh√¥ng gian 3D! ƒêi·ªÅu n√†y gi·∫£i th√≠ch t·∫°i sao c·∫•u tr√∫c `Vertex` c√≥ `position` l√† m·ªôt m·∫£ng 3 s·ªë float thay v√¨ ch·ªâ 2. Ch√∫ng ta kh√¥ng th·ªÉ nh√¨n th·∫•y t√≠nh ch·∫•t 3D v√¨ ƒëang nh√¨n t·ª´ ph√≠a tr∆∞·ªõc.

### Kh√°i ni·ªám c∆° b·∫£n v·ªÅ Camera

```mermaid
graph TD
    A[Camera 3D] --> B[Eye Position - V·ªã tr√≠ camera]
    A --> C[Target - ƒêi·ªÉm nh√¨n]
    A --> D[Up Vector - H∆∞·ªõng l√™n]
    A --> E[Projection Parameters]
    
    E --> F[Field of View - G√≥c nh√¨n]
    E --> G[Aspect Ratio - T·ªâ l·ªá khung h√¨nh]
    E --> H[Near/Far Plane - M·∫∑t ph·∫≥ng g·∫ßn/xa]
```

## üîß 2. C√†i ƒë·∫∑t th∆∞ vi·ªán to√°n h·ªçc

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, ch√∫ng ta c·∫ßn th√™m th∆∞ vi·ªán `cgmath` ƒë·ªÉ x·ª≠ l√Ω c√°c ph√©p to√°n ma tr·∫≠n:

```toml
[dependencies]
# c√°c dependency kh√°c...
cgmath = "0.18"
```

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-4">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-yellow-800 text-lg">‚ö†Ô∏è</span>
    </div>
    <div className="ml-3">
      <span className="text-sm text-yellow-800 block">
        <strong>L∆∞u √Ω:</strong> cgmath l√† th∆∞ vi·ªán to√°n h·ªçc ph·ªï bi·∫øn cho game development, 
        gi√∫p x·ª≠ l√Ω vector, ma tr·∫≠n v√† c√°c ph√©p bi·∫øn ƒë·ªïi 3D.
      </span>
    </div>
  </div>
</div>

## üé• 3. X√¢y d·ª±ng c·∫•u tr√∫c Camera

### 3.1. ƒê·ªãnh nghƒ©a Camera struct

```rust
struct Camera {
    eye: cgmath::Point3<f32>,      // V·ªã tr√≠ camera
    target: cgmath::Point3<f32>,   // ƒêi·ªÉm camera nh√¨n t·ªõi
    up: cgmath::Vector3<f32>,      // Vector h∆∞·ªõng l√™n
    aspect: f32,                   // T·ªâ l·ªá khung h√¨nh
    fovy: f32,                     // G√≥c nh√¨n theo chi·ªÅu d·ªçc
    znear: f32,                    // M·∫∑t ph·∫≥ng g·∫ßn
    zfar: f32,                     // M·∫∑t ph·∫≥ng xa
}
```

### 3.2. Ma tr·∫≠n chuy·ªÉn ƒë·ªïi h·ªá t·ªça ƒë·ªô

| H·ªá t·ªça ƒë·ªô | X | Y | Z | M√¥ t·∫£ |
|-----------|---|---|---|-------|
| OpenGL | -1 ƒë·∫øn +1 | -1 ƒë·∫øn +1 | -1 ƒë·∫øn +1 | H·ªá t·ªça ƒë·ªô chu·∫©n |
| WGPU/DirectX | -1 ƒë·∫øn +1 | -1 ƒë·∫øn +1 | 0 ƒë·∫øn +1 | H·ªá t·ªça ƒë·ªô WGPU |

```rust
#[rustfmt::skip]
pub const OPENGL_TO_WGPU_MATRIX: cgmath::Matrix4<f32> = cgmath::Matrix4::from_cols(
    cgmath::Vector4::new(1.0, 0.0, 0.0, 0.0),
    cgmath::Vector4::new(0.0, 1.0, 0.0, 0.0),
    cgmath::Vector4::new(0.0, 0.0, 0.5, 0.0),
    cgmath::Vector4::new(0.0, 0.0, 0.5, 1.0),
);
```

### 3.3. Ph∆∞∆°ng th·ª©c t·∫°o ma tr·∫≠n view-projection

```rust
impl Camera {
    fn build_view_projection_matrix(&self) -> cgmath::Matrix4<f32> {
        // 1. Ma tr·∫≠n view - di chuy·ªÉn th·∫ø gi·ªõi ƒë·∫øn v·ªã tr√≠ camera
        let view = cgmath::Matrix4::look_at_rh(self.eye, self.target, self.up);
        
        // 2. Ma tr·∫≠n projection - t·∫°o hi·ªáu ·ª©ng chi·ªÅu s√¢u
        let proj = cgmath::perspective(cgmath::Deg(self.fovy), self.aspect, self.znear, self.zfar);
        
        // 3. K·∫øt h·ª£p v√† chuy·ªÉn ƒë·ªïi h·ªá t·ªça ƒë·ªô
        return OPENGL_TO_WGPU_MATRIX * proj * view;
    }
}
```

## üì¶ 4. Uniform Buffers - Truy·ªÅn d·ªØ li·ªáu v√†o Shader

### 4.1. Kh√°i ni·ªám Uniform Buffer

```mermaid
flowchart LR
    A[CPU Data] --> B[Uniform Buffer]
    B --> C[Bind Group]
    C --> D[Shader]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 my-6">
  <h3 className="text-lg font-semibold text-blue-800 mb-2">üí° Uniform Buffer l√† g√¨?</h3>
  <div className="text-blue-700">
    Uniform Buffer l√† m·ªôt v√πng b·ªô nh·ªõ ch·ª©a d·ªØ li·ªáu m√† m·ªçi vertex shader v√† fragment shader 
    c√≥ th·ªÉ truy c·∫≠p. D·ªØ li·ªáu n√†y kh√¥ng thay ƒë·ªïi trong su·ªët qu√° tr√¨nh v·∫Ω m·ªôt primitive.
  </div>
</div>

### 4.2. T·∫°o CameraUniform struct

```rust
#[repr(C)]
#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct CameraUniform {
    // Chuy·ªÉn Matrix4 th√†nh m·∫£ng 4x4 f32 ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi bytemuck
    view_proj: [[f32; 4]; 4],
}

impl CameraUniform {
    fn new() -> Self {
        use cgmath::SquareMatrix;
        Self {
            view_proj: cgmath::Matrix4::identity().into(),
        }
    }

    fn update_view_proj(&mut self, camera: &Camera) {
        self.view_proj = camera.build_view_projection_matrix().into();
    }
}
```

### 4.3. B·∫£ng so s√°nh c√°c lo·∫°i Buffer

| Lo·∫°i Buffer | M·ª•c ƒë√≠ch | Usage Flags | T·∫ßn su·∫•t c·∫≠p nh·∫≠t |
|-------------|----------|-------------|-------------------|
| Vertex Buffer | L∆∞u tr·ªØ vertex data | `VERTEX` | √çt thay ƒë·ªïi |
| Index Buffer | L∆∞u tr·ªØ index data | `INDEX` | √çt thay ƒë·ªïi |
| Uniform Buffer | L∆∞u tr·ªØ uniform data | `UNIFORM \| COPY_DST` | Th∆∞·ªùng xuy√™n |

## üîó 5. Bind Groups v√† Bind Group Layouts

### 5.1. Quy tr√¨nh t·∫°o Bind Group

```mermaid
sequenceDiagram
    participant CPU
    participant Device
    participant Buffer
    participant Layout
    participant BindGroup
    
    CPU->>Device: T·∫°o buffer
    Device->>Buffer: Buffer ƒë∆∞·ª£c t·∫°o
    CPU->>Device: T·∫°o bind group layout
    Device->>Layout: Layout ƒë∆∞·ª£c t·∫°o
    CPU->>Device: T·∫°o bind group v·ªõi buffer v√† layout
    Device->>BindGroup: BindGroup ƒë∆∞·ª£c t·∫°o
```

### 5.2. T·∫°o Camera Buffer v√† Bind Group

```rust
// T·∫°o uniform buffer
let mut camera_uniform = CameraUniform::new();
camera_uniform.update_view_proj(&camera);

let camera_buffer = device.create_buffer_init(
    &wgpu::util::BufferInitDescriptor {
        label: Some("Camera Buffer"),
        contents: bytemuck::cast_slice(&[camera_uniform]),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    }
);

// T·∫°o bind group layout
let camera_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
    entries: &[
        wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }
    ],
    label: Some("camera_bind_group_layout"),
});

// T·∫°o bind group
let camera_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
    layout: &camera_bind_group_layout,
    entries: &[
        wgpu::BindGroupEntry {
            binding: 0,
            resource: camera_buffer.as_entire_binding(),
        }
    ],
    label: Some("camera_bind_group"),
});
```

## üéÆ 6. Shader Integration

### 6.1. C·∫≠p nh·∫≠t Vertex Shader

```wgsl
// Vertex shader
struct CameraUniform {
    view_proj: mat4x4<f32>,
};

@group(1) @binding(0) // group(1) v√¨ texture l√† group(0)
var<uniform> camera: CameraUniform;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) tex_coords: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex_coords: vec2<f32>,
}

@vertex
fn vs_main(model: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.tex_coords = model.tex_coords;
    // √Åp d·ª•ng ma tr·∫≠n view-projection
    out.clip_position = camera.view_proj * vec4<f32>(model.position, 1.0);
    return out;
}
```

### 6.2. B·∫£ng binding groups

| Group | Binding | Lo·∫°i | M·ª•c ƒë√≠ch |
|-------|---------|------|----------|
| 0 | 0 | Texture | Texture diffuse |
| 0 | 1 | Sampler | Sampler cho texture |
| 1 | 0 | Uniform Buffer | Camera data |

## üïπÔ∏è 7. Camera Controller

### 7.1. Thi·∫øt k·∫ø h·ªá th·ªëng ƒëi·ªÅu khi·ªÉn

<div className="bg-green-50 border border-green-200 rounded-lg p-4 my-6">
  <h3 className="text-lg font-semibold text-green-800 mb-2">üéØ M·ª•c ti√™u Camera Controller</h3>
  <ul className="text-green-700 space-y-1">
    <li>‚Ä¢ Di chuy·ªÉn camera trong kh√¥ng gian 3D</li>
    <li>‚Ä¢ Xoay camera quanh target</li>
    <li>‚Ä¢ Zoom in/out b·∫±ng c√°ch di chuy·ªÉn g·∫ßn/xa target</li>
    <li>‚Ä¢ X·ª≠ l√Ω input t·ª´ b√†n ph√≠m</li>
  </ul>
</div>

### 7.2. CameraController Implementation

```rust
struct CameraController {
    speed: f32,
    is_forward_pressed: bool,
    is_backward_pressed: bool,
    is_left_pressed: bool,
    is_right_pressed: bool,
}

impl CameraController {
    fn new(speed: f32) -> Self {
        Self {
            speed,
            is_forward_pressed: false,
            is_backward_pressed: false,
            is_left_pressed: false,
            is_right_pressed: false,
        }
    }

    fn process_events(&mut self, event: &WindowEvent) -> bool {
        match event {
            WindowEvent::KeyboardInput {
                event: KeyEvent {
                    state,
                    physical_key: PhysicalKey::Code(keycode),
                    ..
                },
                ..
            } => {
                let is_pressed = *state == ElementState::Pressed;
                match keycode {
                    KeyCode::KeyW | KeyCode::ArrowUp => {
                        self.is_forward_pressed = is_pressed;
                        true
                    }
                    KeyCode::KeyA | KeyCode::ArrowLeft => {
                        self.is_left_pressed = is_pressed;
                        true
                    }
                    KeyCode::KeyS | KeyCode::ArrowDown => {
                        self.is_backward_pressed = is_pressed;
                        true
                    }
                    KeyCode::KeyD | KeyCode::ArrowRight => {
                        self.is_right_pressed = is_pressed;
                        true
                    }
                    _ => false,
                }
            }
            _ => false,
        }
    }

    fn update_camera(&self, camera: &mut Camera) {
        use cgmath::InnerSpace;
        let forward = camera.target - camera.eye;
        let forward_norm = forward.normalize();
        let forward_mag = forward.magnitude();

        // Tr√°nh glitch khi camera qu√° g·∫ßn target
        if self.is_forward_pressed && forward_mag > self.speed {
            camera.eye += forward_norm * self.speed;
        }
        if self.is_backward_pressed {
            camera.eye -= forward_norm * self.speed;
        }

        let right = forward_norm.cross(camera.up);

        // T√≠nh to√°n l·∫°i sau khi di chuy·ªÉn forward/backward
        let forward = camera.target - camera.eye;
        let forward_mag = forward.magnitude();

        if self.is_right_pressed {
            // Gi·ªØ kho·∫£ng c√°ch ƒë·∫øn target kh√¥ng ƒë·ªïi khi xoay
            camera.eye = camera.target - (forward + right * self.speed).normalize() * forward_mag;
        }
        if self.is_left_pressed {
            camera.eye = camera.target - (forward - right * self.speed).normalize() * forward_mag;
        }
    }
}
```

### 7.3. B·∫£ng ƒëi·ªÅu khi·ªÉn

| Ph√≠m | H√†nh ƒë·ªông | M√¥ t·∫£ |
|------|-----------|-------|
| W / ‚Üë | Forward | Di chuy·ªÉn v·ªÅ ph√≠a target |
| S / ‚Üì | Backward | Di chuy·ªÉn ra xa target |
| A / ‚Üê | Left | Xoay camera sang tr√°i |
| D / ‚Üí | Right | Xoay camera sang ph·∫£i |

## üîÑ 8. Update Loop v√† Buffer Management

### 8.1. C√°c ph∆∞∆°ng ph√°p c·∫≠p nh·∫≠t buffer

```mermaid
graph TD
    A[C·∫≠p nh·∫≠t Uniform Buffer] --> B[Staging Buffer]
    A --> C[Mapping Methods]
    A --> D[write_buffer]
    
    B --> E[T·∫°o buffer t·∫°m]
    B --> F[Copy sang buffer ch√≠nh]
    
    C --> G[map_read_async]
    C --> H[map_write_async]
    
    D --> I[Ghi tr·ª±c ti·∫øp v√†o buffer]
    
    style D fill:#90EE90
    style I fill:#90EE90
```

### 8.2. Implementation update loop

```rust
fn update(&mut self) {
    // C·∫≠p nh·∫≠t camera d·ª±a tr√™n input
    self.camera_controller.update_camera(&mut self.camera);
    
    // C·∫≠p nh·∫≠t uniform buffer
    self.camera_uniform.update_view_proj(&self.camera);
    
    // Ghi d·ªØ li·ªáu v√†o buffer
    self.queue.write_buffer(
        &self.camera_buffer, 
        0, 
        bytemuck::cast_slice(&[self.camera_uniform])
    );
}
```

### 8.3. So s√°nh c√°c ph∆∞∆°ng ph√°p c·∫≠p nh·∫≠t buffer

| Ph∆∞∆°ng ph√°p | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm | Khi n√†o d√πng |
|-------------|---------|------------|--------------|
| Staging Buffer | Hi·ªáu su·∫•t cao, GPU optimized | Ph·ª©c t·∫°p, c·∫ßn copy | D·ªØ li·ªáu l·ªõn, √≠t c·∫≠p nh·∫≠t |
| Mapping | Ki·ªÉm so√°t t·ªët | Async, ph·ª©c t·∫°p | C·∫ßn ƒë·ªçc/ghi ƒë·∫∑c bi·ªát |
| write_buffer | ƒê∆°n gi·∫£n, tr·ª±c ti·∫øp | K√©m hi·ªáu su·∫•t cho d·ªØ li·ªáu l·ªõn | D·ªØ li·ªáu nh·ªè, th∆∞·ªùng c·∫≠p nh·∫≠t |

## üéØ 9. Render Pass Integration

### 9.1. C·∫≠p nh·∫≠t render pass

```rust
// Trong h√†m render()
render_pass.set_pipeline(&self.render_pipeline);
render_pass.set_bind_group(0, &self.diffuse_bind_group, &[]); // Texture
render_pass.set_bind_group(1, &self.camera_bind_group, &[]);  // Camera - M·ªöI!
render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);

render_pass.draw_indexed(0..self.num_indices, 0, 0..1);
```

### 9.2. Pipeline Layout Update

```rust
let render_pipeline_layout = device.create_pipeline_layout(
    &wgpu::PipelineLayoutDescriptor {
        label: Some("Render Pipeline Layout"),
        bind_group_layouts: &[
            &texture_bind_group_layout,  // group(0)
            &camera_bind_group_layout,   // group(1) - M·ªöI!
        ],
        push_constant_ranges: &[],
    }
);
```

## üèÅ 10. K·∫øt qu·∫£ v√† Demo

<div className="bg-gradient-to-r from-green-100 to-blue-100 p-6 rounded-lg shadow-md">
  <h3 className="text-xl font-bold text-gray-800 mb-4">‚úÖ K·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c</h3>
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <h4 className="font-semibold text-gray-700">Tr∆∞·ªõc khi c√≥ Camera:</h4>
      <ul className="text-sm text-gray-600 mt-2">
        <li>‚Ä¢ H√¨nh ·∫£nh ph·∫≥ng, kh√¥ng c√≥ chi·ªÅu s√¢u</li>
        <li>‚Ä¢ Kh√¥ng th·ªÉ thay ƒë·ªïi g√≥c nh√¨n</li>
        <li>‚Ä¢ T·ªâ l·ªá b·ªã m√©o</li>
      </ul>
    </div>
    <div>
      <h4 className="font-semibold text-gray-700">Sau khi c√≥ Camera:</h4>
      <ul className="text-sm text-gray-600 mt-2">
        <li>‚Ä¢ H√¨nh ·∫£nh 3D c√≥ chi·ªÅu s√¢u</li>
        <li>‚Ä¢ C√≥ th·ªÉ di chuy·ªÉn v√† xoay camera</li>
        <li>‚Ä¢ T·ªâ l·ªá ch√≠nh x√°c</li>
        <li>‚Ä¢ Tr·∫£i nghi·ªám t∆∞∆°ng t√°c</li>
      </ul>
    </div>
  </div>
</div>

## üéØ 11. Th·ª≠ th√°ch (Challenge)

<div className="bg-orange-50 border-l-4 border-orange-400 p-4">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-orange-800 text-xl">üèÜ</span>
    </div>
    <div className="ml-3">
      <h3 className="text-lg font-medium text-orange-800">Th·ª≠ th√°ch: Model t·ª± xoay</h3>
      <p className="mt-2 text-sm text-orange-700">
        L√†m cho model t·ª± ƒë·ªông xoay ƒë·ªôc l·∫≠p v·ªõi camera. 
        <strong>G·ª£i √Ω:</strong> B·∫°n s·∫Ω c·∫ßn m·ªôt ma tr·∫≠n kh√°c cho vi·ªác n√†y.
      </p>
      <div className="mt-3">
        <strong className="text-orange-800">H∆∞·ªõng d·∫´n:</strong>
        <ol className="list-decimal list-inside text-sm text-orange-700 mt-1">
          <li>T·∫°o m·ªôt ma tr·∫≠n model ri√™ng bi·ªát</li>
          <li>C·∫≠p nh·∫≠t ma tr·∫≠n n√†y theo th·ªùi gian</li>
          <li>Nh√¢n ma tr·∫≠n model v·ªõi view-projection trong shader</li>
        </ol>
      </div>
    </div>
  </div>
</div>

## üìã 12. T√≥m t·∫Øt ki·∫øn th·ª©c

### 12.1. C√°c kh√°i ni·ªám ch√≠nh ƒë√£ h·ªçc

| Kh√°i ni·ªám | ƒê·ªãnh nghƒ©a | ·ª®ng d·ª•ng |
|-----------|------------|----------|
| Camera 3D | ƒê·ªãnh nghƒ©a ƒëi·ªÉm nh√¨n trong kh√¥ng gian 3D | T·∫°o g√≥c nh√¨n cho scene |
| View Matrix | Ma tr·∫≠n bi·∫øn ƒë·ªïi t·ª´ world space sang camera space | ƒê·∫∑t camera ·ªü v·ªã tr√≠ mong mu·ªën |
| Projection Matrix | Ma tr·∫≠n t·∫°o hi·ªáu ·ª©ng chi·ªÅu s√¢u | T·∫°o perspective ho·∫∑c orthographic |
| Uniform Buffer | V√πng b·ªô nh·ªõ ch·ª©a d·ªØ li·ªáu cho shader | Truy·ªÅn d·ªØ li·ªáu t·ª´ CPU sang GPU |
| Bind Group | Nh√≥m c√°c resource ƒë∆∞·ª£c bind v√†o shader | T·ªï ch·ª©c v√† qu·∫£n l√Ω resource |

### 12.2. Workflow t·ªïng quan

```mermaid
flowchart TD
    A[Input Handler] --> B[Camera Controller]
    B --> C[Update Camera]
    C --> D[Calculate View-Projection Matrix]
    D --> E[Update Uniform Buffer]
    E --> F[Bind to Shader]
    F --> G[Render]
    
    style A fill:#e3f2fd
    style G fill:#e8f5e8
```

<div className="bg-gray-50 border border-gray-200 rounded-lg p-6 mt-8">
  <h3 className="text-lg font-semibold text-gray-800 mb-4">üéì B√†i h·ªçc ti·∫øp theo</h3>
  <p className="text-gray-700">
    Trong b√†i ti·∫øp theo, ch√∫ng ta s·∫Ω h·ªçc v·ªÅ <strong>Instance Rendering</strong> - 
    k·ªπ thu·∫≠t v·∫Ω nhi·ªÅu object gi·ªëng nhau m·ªôt c√°ch hi·ªáu qu·∫£, v√† <strong>Depth Testing</strong> 
    ƒë·ªÉ x·ª≠ l√Ω ƒë√∫ng th·ª© t·ª± c√°c object trong kh√¥ng gian 3D.
  </p>
</div>