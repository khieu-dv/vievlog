# B√†i 3: Pipeline trong WebGPU - H∆∞·ªõng d·∫´n chi ti·∫øt

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-gray-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <ul className="list-disc pl-6 text-gray-700">
    <li>Hi·ªÉu kh√°i ni·ªám Pipeline trong WebGPU</li>
    <li>N·∫Øm v·ªØng c√°ch ho·∫°t ƒë·ªông c·ªßa Vertex Shader v√† Fragment Shader</li>
    <li>H·ªçc c√°ch vi·∫øt shader b·∫±ng ng√¥n ng·ªØ WGSL</li>
    <li>T·∫°o v√† s·ª≠ d·ª•ng RenderPipeline ƒë·ªÉ v·∫Ω h√¨nh tam gi√°c ƒë·∫ßu ti√™n</li>
  </ul>
</div>

## 1. Pipeline l√† g√¨?

<div className="bg-yellow-50 p-4 rounded-lg border border-yellow-200 mb-6">
  <p className="text-gray-800"><strong>üí° Kh√°i ni·ªám:</strong> Pipeline trong WebGPU gi·ªëng nh∆∞ m·ªôt d√¢y chuy·ªÅn s·∫£n xu·∫•t trong nh√† m√°y. N√≥ m√¥ t·∫£ t·∫•t c·∫£ c√°c b∆∞·ªõc m√† GPU s·∫Ω th·ª±c hi·ªán khi x·ª≠ l√Ω d·ªØ li·ªáu c·ªßa b·∫°n.</p>
</div>

N·∫øu b·∫°n ƒë√£ t·ª´ng l√†m vi·ªác v·ªõi OpenGL v√† shader programs, th√¨ Pipeline ch√≠nh l√† phi√™n b·∫£n m·∫°nh m·∫Ω v√† ho√†n thi·ªán h∆°n c·ªßa kh√°i ni·ªám ƒë√≥.

### So s√°nh Pipeline vs Shader Program

| ƒê·∫∑c ƒëi·ªÉm | OpenGL Shader Program | WebGPU Pipeline |
|----------|----------------------|-----------------|
| **T√≠nh nƒÉng** | Ch·ªâ ƒë·ªãnh nghƒ©a vertex & fragment shader | ƒê·ªãnh nghƒ©a to√†n b·ªô qu√° tr√¨nh render |
| **C·∫•u h√¨nh** | H·∫°n ch·∫ø | T√πy ch·ªânh chi ti·∫øt m·ªçi b∆∞·ªõc |
| **Hi·ªáu su·∫•t** | T·ªët | T·ªëi ∆∞u h∆°n |
| **ƒê·ªô ph·ª©c t·∫°p** | ƒê∆°n gi·∫£n | Ph·ª©c t·∫°p nh∆∞ng m·∫°nh m·∫Ω |

## 2. Shader - Nh·ªØng ch∆∞∆°ng tr√¨nh mini tr√™n GPU

```mermaid
graph TD
    A[D·ªØ li·ªáu ƒë·∫ßu v√†o] --> B[Vertex Shader]
    B --> C[Primitive Assembly]
    C --> D[Rasterization]
    D --> E[Fragment Shader]
    E --> F[Framebuffer]
    
    style B fill:#e1f5fe
    style E fill:#fff3e0
    style F fill:#e8f5e8
```

### C√°c lo·∫°i Shader ch√≠nh

| Lo·∫°i Shader | M·ª•c ƒë√≠ch | D·ªØ li·ªáu x·ª≠ l√Ω |
|-------------|----------|---------------|
| **Vertex Shader** | X·ª≠ l√Ω c√°c ƒë·ªânh (vertices) | T·ªça ƒë·ªô 3D, m√†u s·∫Øc, texture coordinates |
| **Fragment Shader** | X√°c ƒë·ªãnh m√†u s·∫Øc pixel | M√†u s·∫Øc cu·ªëi c√πng c·ªßa m·ªói pixel |
| **Compute Shader** | T√≠nh to√°n t·ªïng qu√°t | B·∫•t k·ª≥ d·ªØ li·ªáu n√†o |

<div className="bg-red-50 p-4 rounded-lg border border-red-200 mb-6">
  <p className="text-red-800"><strong>‚ö†Ô∏è L∆∞u √Ω:</strong> WebGL kh√¥ng h·ªó tr·ª£ Geometry Shader v√† Tessellation Shader. Ch√∫ng th∆∞·ªùng l√†m gi·∫£m hi·ªáu su·∫•t n√™n n√™n tr√°nh s·ª≠ d·ª•ng.</p>
</div>

## 3. Vertex v√† Fragment - Kh√°i ni·ªám c∆° b·∫£n

### 3.1 Vertex (ƒê·ªânh)

<div className="bg-green-50 p-4 rounded-lg border border-green-200 mb-4">
  <p className="text-green-800"><strong>Vertex</strong> l√† m·ªôt ƒëi·ªÉm trong kh√¥ng gian 3D (ho·∫∑c 2D). C√°c vertex ƒë∆∞·ª£c nh√≥m l·∫°i ƒë·ªÉ t·∫°o th√†nh:</p>
  <ul className="list-disc pl-6 mt-2">
    <li><strong>ƒê∆∞·ªùng th·∫≥ng:</strong> 2 vertex</li>
    <li><strong>Tam gi√°c:</strong> 3 vertex</li>
  </ul>
</div>

```mermaid
graph LR
    A[Vertex 1] --> D[Triangle]
    B[Vertex 2] --> D
    C[Vertex 3] --> D
    
    style A fill:#ffcdd2
    style B fill:#ffcdd2
    style C fill:#ffcdd2
    style D fill:#c8e6c9
```

### 3.2 Qu√° tr√¨nh Rendering

| B∆∞·ªõc | M√¥ t·∫£ | Shader li√™n quan |
|------|-------|------------------|
| 1. **Vertex Processing** | Bi·∫øn ƒë·ªïi t·ªça ƒë·ªô vertex | Vertex Shader |
| 2. **Primitive Assembly** | Gh√©p vertex th√†nh tam gi√°c | GPU t·ª± ƒë·ªông |
| 3. **Rasterization** | Chuy·ªÉn tam gi√°c th√†nh pixel | GPU t·ª± ƒë·ªông |
| 4. **Fragment Processing** | T√¥ m√†u t·ª´ng pixel | Fragment Shader |

## 4. WGSL - WebGPU Shading Language

<div className="bg-blue-50 p-4 rounded-lg border border-blue-200 mb-6">
  <p className="text-blue-800"><strong>WGSL (WebGPU Shading Language)</strong> l√† ng√¥n ng·ªØ shader ch√≠nh th·ª©c c·ªßa WebGPU. N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ d·ªÖ d√†ng chuy·ªÉn ƒë·ªïi sang c√°c ng√¥n ng·ªØ shader kh√°c nh∆∞ SPIR-V, MSL, HLSL, v√† GLSL.</p>
</div>

### ∆Øu ƒëi·ªÉm c·ªßa WGSL

| ∆Øu ƒëi·ªÉm | M√¥ t·∫£ |
|---------|-------|
| **ƒêa n·ªÅn t·∫£ng** | Chuy·ªÉn ƒë·ªïi t·ª± ƒë·ªông sang ng√¥n ng·ªØ shader c·ªßa t·ª´ng platform |
| **Hi·ªáu su·∫•t cao** | ƒê∆∞·ª£c t·ªëi ∆∞u h√≥a b·ªüi th∆∞ vi·ªán Naga |
| **C√∫ ph√°p r√µ r√†ng** | D·ªÖ h·ªçc, d·ªÖ ƒë·ªçc |
| **H·ªó tr·ª£ t·ªët** | L√† ng√¥n ng·ªØ shader ch√≠nh th·ª©c c·ªßa WebGPU |

## 5. Vi·∫øt Shader ƒë·∫ßu ti√™n

T·∫°o file `shader.wgsl` trong c√πng th∆∞ m·ª•c v·ªõi `main.rs`:

### 5.1 Vertex Shader

```wgsl
// Vertex shader
struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
};

@vertex
fn vs_main(
    @builtin(vertex_index) in_vertex_index: u32,
) -> VertexOutput {
    var out: VertexOutput;
    let x = f32(1 - i32(in_vertex_index)) * 0.5;
    let y = f32(i32(in_vertex_index & 1u) * 2 - 1) * 0.5;
    out.clip_position = vec4<f32>(x, y, 0.0, 1.0);
    return out;
}
```

#### Ph√¢n t√≠ch t·ª´ng ph·∫ßn:

| Ph·∫ßn | M·ª•c ƒë√≠ch | Gi·∫£i th√≠ch |
|------|----------|------------|
| `struct VertexOutput` | ƒê·ªãnh nghƒ©a output c·ªßa vertex shader | Ch·ª©a t·ªça ƒë·ªô clip_position |
| `@builtin(position)` | Ch·ªâ ƒë·ªãnh t·ªça ƒë·ªô vertex | T∆∞∆°ng ƒë∆∞∆°ng `gl_Position` trong GLSL |
| `@vertex` | ƒê√°nh d·∫•u entry point | X√°c ƒë·ªãnh h√†m vertex shader |
| `@builtin(vertex_index)` | Index c·ªßa vertex hi·ªán t·∫°i | GPU t·ª± ƒë·ªông cung c·∫•p |

<div className="bg-cyan-50 p-4 rounded-lg border border-cyan-200 mb-6">
  <h4 className="font-bold text-cyan-800 mb-2">üîç Ph√¢n t√≠ch thu·∫≠t to√°n t·∫°o tam gi√°c:</h4>
  <div className="text-cyan-700">
    <p><strong>Vertex 0:</strong> x = 0.5, y = -0.5 (g√≥c d∆∞·ªõi ph·∫£i)</p>
    <p><strong>Vertex 1:</strong> x = -0.5, y = -0.5 (g√≥c d∆∞·ªõi tr√°i)</p>
    <p><strong>Vertex 2:</strong> x = 0.5, y = 0.5 (g√≥c tr√™n ph·∫£i)</p>
  </div>
</div>

### 5.2 Fragment Shader

```wgsl
// Fragment shader
@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(0.3, 0.2, 0.1, 1.0);
}
```

#### Ph√¢n t√≠ch Fragment Shader:

| Th√†nh ph·∫ßn | Gi√° tr·ªã | √ù nghƒ©a |
|------------|---------|---------|
| `@fragment` | - | ƒê√°nh d·∫•u entry point cho fragment shader |
| `@location(0)` | - | Xu·∫•t ra color target ƒë·∫ßu ti√™n |
| `vec4<f32>(0.3, 0.2, 0.1, 1.0)` | RGBA | M√†u n√¢u (Red=0.3, Green=0.2, Blue=0.1, Alpha=1.0) |

## 6. T·∫°o RenderPipeline

### 6.1 C·∫≠p nh·∫≠t struct State

```rust
pub struct State {
    surface: wgpu::Surface<'static>,
    device: wgpu::Device,
    queue: wgpu::Queue,
    config: wgpu::SurfaceConfiguration,
    is_surface_configured: bool,
    // M·ªöI!
    render_pipeline: wgpu::RenderPipeline,
    window: Arc<Window>,
}
```

### 6.2 Load Shader Module

```rust
let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
    label: Some("Shader"),
    source: wgpu::ShaderSource::Wgsl(include_str!("shader.wgsl").into()),
});

// Ho·∫∑c s·ª≠ d·ª•ng macro ng·∫Øn g·ªçn h∆°n:
// let shader = device.create_shader_module(wgpu::include_wgsl!("shader.wgsl"));
```

### 6.3 T·∫°o Pipeline Layout

```rust
let render_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
    label: Some("Render Pipeline Layout"),
    bind_group_layouts: &[],
    push_constant_ranges: &[],
});
```

### 6.4 T·∫°o RenderPipeline

```mermaid
flowchart TD
    A[ShaderModule] --> B[PipelineLayout]
    B --> C[RenderPipeline]
    D[VertexState] --> C
    E[FragmentState] --> C
    F[PrimitiveState] --> C
    G[MultisampleState] --> C
    
    style C fill:#e8f5e8
```

#### Vertex State Configuration

```rust
vertex: wgpu::VertexState {
    module: &shader,
    entry_point: Some("vs_main"),
    buffers: &[],
    compilation_options: wgpu::PipelineCompilationOptions::default(),
},
```

| Tham s·ªë | Gi√° tr·ªã | M·ª•c ƒë√≠ch |
|---------|---------|----------|
| `module` | `&shader` | Shader module ch·ª©a vertex shader |
| `entry_point` | `"vs_main"` | T√™n h√†m vertex shader |
| `buffers` | `&[]` | Danh s√°ch vertex buffer (ƒë·ªÉ tr·ªëng v√¨ d√πng built-in) |

#### Fragment State Configuration

```rust
fragment: Some(wgpu::FragmentState {
    module: &shader,
    entry_point: Some("fs_main"),
    targets: &[Some(wgpu::ColorTargetState {
        format: config.format,
        blend: Some(wgpu::BlendState::REPLACE),
        write_mask: wgpu::ColorWrites::ALL,
    })],
    compilation_options: wgpu::PipelineCompilationOptions::default(),
}),
```

##### Color Target State - B·∫£ng c·∫•u h√¨nh

| Thu·ªôc t√≠nh | Gi√° tr·ªã | √ù nghƒ©a |
|------------|---------|---------|
| `format` | `config.format` | ƒê·ªãnh d·∫°ng pixel gi·ªëng surface |
| `blend` | `REPLACE` | Thay th·∫ø ho√†n to√†n pixel c≈© |
| `write_mask` | `ALL` | Ghi t·∫•t c·∫£ k√™nh m√†u (RGBA) |

#### Primitive State Configuration

```rust
primitive: wgpu::PrimitiveState {
    topology: wgpu::PrimitiveTopology::TriangleList,
    strip_index_format: None,
    front_face: wgpu::FrontFace::Ccw,
    cull_mode: Some(wgpu::Face::Back),
    polygon_mode: wgpu::PolygonMode::Fill,
    unclipped_depth: false,
    conservative: false,
},
```

##### Primitive State - B·∫£ng chi ti·∫øt

| Thu·ªôc t√≠nh | Gi√° tr·ªã | M√¥ t·∫£ |
|------------|---------|-------|
| `topology` | `TriangleList` | M·ªói 3 vertex t·∫°o th√†nh 1 tam gi√°c |
| `front_face` | `Ccw` | Tam gi√°c c√≥ vertex x·∫øp ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì l√† m·∫∑t tr∆∞·ªõc |
| `cull_mode` | `Back` | Lo·∫°i b·ªè m·∫∑t sau |
| `polygon_mode` | `Fill` | T√¥ ƒë·∫ßy tam gi√°c |

#### C·∫•u h√¨nh c√≤n l·∫°i

```rust
depth_stencil: None,
multisample: wgpu::MultisampleState {
    count: 1,
    mask: !0,
    alpha_to_coverage_enabled: false,
},
multiview: None,
cache: None,
```

| C·∫•u h√¨nh | M·ª•c ƒë√≠ch | Gi√° tr·ªã hi·ªán t·∫°i |
|----------|----------|------------------|
| `depth_stencil` | Depth testing | `None` (ch∆∞a d√πng) |
| `multisample.count` | S·ªë l∆∞·ª£ng sample | 1 (kh√¥ng multisampling) |
| `multiview` | Array texture layers | `None` |
| `cache` | Cache shader compilation | `None` |

## 7. S·ª≠ d·ª•ng Pipeline trong Render

### 7.1 C·∫≠p nh·∫≠t h√†m render()

```rust
// render()
{
    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("Render Pass"),
        color_attachments: &[
            Some(wgpu::RenderPassColorAttachment {
                view: &view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Clear(wgpu::Color {
                        r: 0.1,
                        g: 0.2,
                        b: 0.3,
                        a: 1.0,
                    }),
                    store: wgpu::StoreOp::Store,
                }
            })
        ],
        depth_stencil_attachment: None,
    });

    // S·ª¨ D·ª§NG PIPELINE
    render_pass.set_pipeline(&self.render_pipeline);
    render_pass.draw(0..3, 0..1);
}
```

### 7.2 Ph√¢n t√≠ch l·ªánh draw

```mermaid
graph LR
    A[render_pass.draw] --> B[Vertex range: 0..3]
    A --> C[Instance range: 0..1]
    B --> D[3 vertices ‚Üí 1 triangle]
    C --> E[1 instance]
```

| Tham s·ªë | Gi√° tr·ªã | √ù nghƒ©a |
|---------|---------|---------|
| Vertex range | `0..3` | V·∫Ω 3 vertex (index 0, 1, 2) |
| Instance range | `0..1` | V·∫Ω 1 instance c·ªßa geometry |

<div className="bg-green-50 p-6 rounded-lg border border-green-200 mt-8">
  <h3 className="text-xl font-bold text-green-800 mb-4">üéâ K·∫øt qu·∫£</h3>
  <p className="text-green-700">Sau khi ch·∫°y code, b·∫°n s·∫Ω th·∫•y m·ªôt tam gi√°c m√†u n√¢u xu·∫•t hi·ªán tr√™n m√†n h√¨nh!</p>
</div>

## 8. B√†i t·∫≠p th·ª≠ th√°ch

<div className="bg-orange-50 p-6 rounded-lg border border-orange-200 mt-8">
  <h3 className="text-xl font-bold text-orange-800 mb-4">üöÄ Th·ª≠ th√°ch</h3>
  <p className="text-orange-700 mb-4">T·∫°o m·ªôt pipeline th·ª© hai s·ª≠ d·ª•ng d·ªØ li·ªáu v·ªã tr√≠ c·ªßa tam gi√°c ƒë·ªÉ t·∫°o m√†u s·∫Øc, sau ƒë√≥ g·ª≠i m√†u n√†y ƒë·∫øn fragment shader. Cho ph√©p ·ª©ng d·ª•ng chuy·ªÉn ƒë·ªïi gi·ªØa hai pipeline khi nh·∫•n ph√≠m space.</p>
  
  <div className="bg-white p-4 rounded border-l-4 border-orange-400 mt-4">
    <p className="font-semibold text-orange-800">üí° G·ª£i √Ω:</p>
    <ul className="list-disc pl-6 text-orange-700">
      <li>B·∫°n c·∫ßn s·ª≠a ƒë·ªïi struct <code>VertexOutput</code></li>
      <li>Th√™m tr∆∞·ªùng m·ªõi ƒë·ªÉ truy·ªÅn m√†u s·∫Øc t·ª´ vertex shader sang fragment shader</li>
      <li>S·ª≠ d·ª•ng <code>@location(n)</code> ƒë·ªÉ ƒë·ªãnh nghƒ©a c√°c tr∆∞·ªùng t√πy ch·ªânh</li>
    </ul>
  </div>
</div>

### C·∫•u tr√∫c VertexOutput m·ªü r·ªông:

```rust
struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) vert_pos: vec3<f32>,  // V·ªã tr√≠ vertex
    @location(1) color: vec3<f32>,     // M√†u s·∫Øc
}
```

## 9. T·ªïng k·∫øt

### Nh·ªØng ki·∫øn th·ª©c ƒë√£ h·ªçc:

- ‚úÖ **Pipeline:** Chu·ªói x·ª≠ l√Ω d·ªØ li·ªáu tr√™n GPU  
- ‚úÖ **WGSL:** Ng√¥n ng·ªØ shader c·ªßa WebGPU  
- ‚úÖ **Vertex Shader:** X·ª≠ l√Ω t·ªça ƒë·ªô vertex  
- ‚úÖ **Fragment Shader:** X√°c ƒë·ªãnh m√†u s·∫Øc pixel  
- ‚úÖ **RenderPipeline:** C·∫•u h√¨nh complete pipeline  
- ‚úÖ **Render Pass:** S·ª≠ d·ª•ng pipeline ƒë·ªÉ v·∫Ω  

### B∆∞·ªõc ti·∫øp theo:

Trong b√†i h·ªçc ti·∫øp theo, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ **Buffer** - c√°ch l∆∞u tr·ªØ v√† truy·ªÅn d·ªØ li·ªáu vertex t·ª´ CPU sang GPU m·ªôt c√°ch hi·ªáu qu·∫£.

<div className="bg-gray-50 p-4 rounded-lg border border-gray-200 mt-8 text-center">
  <span className="text-gray-600 italic">
    "M·ªói tam gi√°c ƒë·ªÅu b·∫Øt ƒë·∫ßu t·ª´ ba ƒëi·ªÉm. H√†nh tr√¨nh graphics programming c·ªßa b·∫°n c≈©ng v·∫≠y!" üî∫
  </span>
</div>