# B√†i 3: Uniforms v√† Bindings trong Bevy

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <p className="text-blue-700">
    Hi·ªÉu v√† th√†nh th·∫°o c√°ch truy·ªÅn d·ªØ li·ªáu t·ª´ CPU sang GPU th√¥ng qua uniform buffers, 
    t·∫°o Material trait t√πy ch·ªânh v√† implement uniform binding trong WGSL ƒë·ªÉ t·∫°o shader ƒë·ªông.
  </p>
</div>

## üìö Ki·∫øn th·ª©c c·∫ßn √¥n t·∫≠p

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu b√†i n√†y, h√£y ƒë·∫£m b·∫£o b·∫°n ƒë√£ n·∫Øm v·ªØng:

| Kh√°i ni·ªám | M√¥ t·∫£ | T·ª´ b√†i h·ªçc |
|-----------|--------|-------------|
| **WGSL Syntax** | C√∫ ph√°p c∆° b·∫£n, types, functions | B√†i 2 |
| **Vertex/Fragment** | Hi·ªÉu v·ªÅ vertex input v√† fragment output | B√†i 2 |
| **Bevy Materials** | Kh√°i ni·ªám c∆° b·∫£n v·ªÅ Material system | B√†i 2 |

## üîç Kh√°i ni·ªám Uniforms v√† √Ω nghƒ©a

### Uniforms l√† g√¨?

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-6">
  <div className="flex">
    <div className="ml-3">
      <p className="text-sm text-yellow-700">
        <strong>Uniform</strong> l√† d·ªØ li·ªáu ƒë∆∞·ª£c truy·ªÅn t·ª´ CPU sang GPU v√† c√≥ gi√° tr·ªã <em>ƒë·ªìng nh·∫•t</em> 
        (uniform) cho t·∫•t c·∫£ c√°c vertices ho·∫∑c fragments trong m·ªôt draw call.
      </p>
    </div>
  </div>
</div>

**ƒê·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa Uniforms:**

| ƒê·∫∑c ƒëi·ªÉm | M√¥ t·∫£ | V√≠ d·ª• |
|----------|--------|-------|
| **Gi√° tr·ªã kh√¥ng ƒë·ªïi** | Trong m·ªôt draw call, uniform c√≥ c√πng gi√° tr·ªã cho m·ªçi shader invocation | `time: 1.25` cho t·∫•t c·∫£ pixels |
| **CPU ‚Üí GPU** | ƒê∆∞·ª£c c·∫≠p nh·∫≠t t·ª´ ph√≠a CPU | Rust code ‚Üí WGSL shader |
| **Hi·ªáu su·∫•t cao** | ƒê∆∞·ª£c cache v√† optimize b·ªüi GPU | Truy c·∫≠p nhanh h∆°n textures |
| **K√≠ch th∆∞·ªõc h·∫°n ch·∫ø** | C√≥ gi·ªõi h·∫°n v·ªÅ dung l∆∞·ª£ng buffer | Th∆∞·ªùng 64KB - 256KB |

### So s√°nh v·ªõi c√°c lo·∫°i d·ªØ li·ªáu kh√°c

```mermaid
graph TD
    A[GPU Data Types] --> B[Vertex Attributes]
    A --> C[Uniforms]
    A --> D[Textures]
    A --> E[Storage Buffers]
    
    B --> B1[Kh√°c nhau m·ªói vertex<br/>Position, Normal, UV]
    C --> C1[Gi·ªëng nhau m·ªçi shader<br/>Time, Camera matrix]
    D --> D1[D·ªØ li·ªáu 2D/3D l·ªõn<br/>Images, Lookup tables]
    E --> E2[D·ªØ li·ªáu l·ªõn c√≥ th·ªÉ ghi<br/>Compute shader output]
```

## üèóÔ∏è C·∫•u tr√∫c Uniform Buffer trong WGSL

### Khai b√°o c∆° b·∫£n

```rust
// WGSL - Shader code
struct TimeUniform {
    time: f32,
    delta_time: f32,
    frame_count: u32,
    _padding: u32,  // Alignment padding
}

@group(1) @binding(0)
var<uniform> time_uniform: TimeUniform;
```

### Memory Alignment Rules

<div className="bg-red-50 border-l-4 border-red-400 p-4 my-6">
  <p className="text-red-700">
    <strong>‚ö†Ô∏è Quan tr·ªçng:</strong> WGSL tu√¢n theo std140 layout rules. 
    M·ªói field ph·∫£i ƒë∆∞·ª£c align theo size c·ªßa n√≥ v√† struct size ph·∫£i l√† b·ªôi s·ªë c·ªßa 16 bytes.
  </p>
</div>

| Type | Size (bytes) | Alignment | Padding c·∫ßn thi·∫øt |
|------|-------------|-----------|-------------------|
| `f32` | 4 | 4 | Kh√¥ng c·∫ßn |
| `vec2<f32>` | 8 | 8 | Kh√¥ng c·∫ßn |
| `vec3<f32>` | 12 | 16 | +4 bytes padding |
| `vec4<f32>` | 16 | 16 | Kh√¥ng c·∫ßn |
| `mat4x4<f32>` | 64 | 16 | Kh√¥ng c·∫ßn |

### V√≠ d·ª• v·ªÅ Alignment

```rust
// ‚ùå Sai - kh√¥ng ƒë√∫ng alignment
struct BadUniform {
    time: f32,          // offset: 0, size: 4
    position: vec3<f32>, // offset: 4, size: 12 (sai!)
    color: vec4<f32>,   // offset: 16, size: 16
}

// ‚úÖ ƒê√∫ng - c√≥ padding
struct GoodUniform {
    time: f32,          // offset: 0, size: 4
    _padding1: f32,     // offset: 4, size: 4 (padding)
    _padding2: f32,     // offset: 8, size: 4 (padding)  
    _padding3: f32,     // offset: 12, size: 4 (padding)
    position: vec3<f32>, // offset: 16, size: 12
    _padding4: f32,     // offset: 28, size: 4 (padding)
    color: vec4<f32>,   // offset: 32, size: 16
}
```

## üîß Implement Material Trait trong Bevy

### B∆∞·ªõc 1: T·∫°o Custom Material Struct

```rust
use bevy::prelude::*;
use bevy::render::render_resource::*;
use bevy::reflect::TypeUuid;

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct AnimatedMaterial {
    #[uniform(0)]
    pub time: f32,
    
    #[uniform(0)]  
    pub speed: f32,
    
    #[uniform(0)]
    pub amplitude: f32,
    
    #[uniform(0)]
    pub color: Color,
}
```

### B∆∞·ªõc 2: Implement Material Trait

```rust
impl Material for AnimatedMaterial {
    fn fragment_shader() -> ShaderRef {
        "shaders/animated_material.wgsl".into()
    }
    
    fn vertex_shader() -> ShaderRef {
        "shaders/animated_material.wgsl".into()
    }
    
    fn alpha_mode(&self) -> AlphaMode {
        AlphaMode::Blend
    }
}
```

### B∆∞·ªõc 3: Shader Implementation

```rust
// assets/shaders/animated_material.wgsl

struct AnimatedMaterial {
    time: f32,
    speed: f32, 
    amplitude: f32,
    color: vec4<f32>,
}

@group(1) @binding(0)
var<uniform> material: AnimatedMaterial;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_position: vec4<f32>,
    @location(1) uv: vec2<f32>,
}

@vertex
fn vertex(vertex: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    
    // T·∫°o wave effect
    let wave = sin(material.time * material.speed + vertex.position.x * 2.0) * material.amplitude;
    let displaced_pos = vertex.position + vec3<f32>(0.0, wave, 0.0);
    
    out.clip_position = mesh_position_local_to_clip(
        get_model_matrix(0u),
        vec4<f32>(displaced_pos, 1.0)
    );
    
    out.world_position = mesh_position_local_to_world(
        get_model_matrix(0u), 
        vec4<f32>(displaced_pos, 1.0)
    );
    
    out.uv = vertex.uv;
    
    return out;
}

@fragment  
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    // T·∫°o color animation
    let time_color = vec3<f32>(
        sin(material.time * 2.0) * 0.5 + 0.5,
        sin(material.time * 2.0 + 2.0) * 0.5 + 0.5,
        sin(material.time * 2.0 + 4.0) * 0.5 + 0.5
    );
    
    let final_color = material.color.rgb * time_color;
    
    return vec4<f32>(final_color, material.color.a);
}
```

## üéÆ T·∫°o System ƒë·ªÉ c·∫≠p nh·∫≠t Uniforms

### Time System

```rust
fn update_animated_materials(
    time: Res<Time>,
    mut materials: ResMut<Assets<AnimatedMaterial>>,
) {
    for (_, material) in materials.iter_mut() {
        material.time = time.elapsed_seconds();
    }
}
```

### Interactive System

```rust
fn control_material_properties(
    keyboard: Res<Input<KeyCode>>,
    mut materials: ResMut<Assets<AnimatedMaterial>>,
) {
    for (_, material) in materials.iter_mut() {
        // ƒêi·ªÅu khi·ªÉn speed
        if keyboard.pressed(KeyCode::Up) {
            material.speed += 0.1;
        }
        if keyboard.pressed(KeyCode::Down) {
            material.speed -= 0.1;
        }
        
        // ƒêi·ªÅu khi·ªÉn amplitude  
        if keyboard.pressed(KeyCode::Right) {
            material.amplitude += 0.01;
        }
        if keyboard.pressed(KeyCode::Left) {
            material.amplitude -= 0.01;
        }
        
        // Clamp values
        material.speed = material.speed.clamp(0.1, 10.0);
        material.amplitude = material.amplitude.clamp(0.0, 1.0);
    }
}
```

## üé® V√≠ d·ª• th·ª±c t·∫ø: Rainbow Wave Effect

### Complete Example

```rust
use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MaterialPlugin::<AnimatedMaterial>::default())
        .add_systems(Startup, setup)
        .add_systems(Update, (
            update_animated_materials,
            control_material_properties,
        ))
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<AnimatedMaterial>>,
) {
    // Camera
    commands.spawn(Camera3dBundle {
        transform: Transform::from_xyz(0.0, 2.0, 5.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    // Light
    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            shadows_enabled: true,
            ..default()
        },
        transform: Transform::from_rotation(Quat::from_euler(EulerRot::ZYX, 0.0, 1.0, -std::f32::consts::FRAC_PI_4)),
        ..default()
    });

    // Animated plane
    commands.spawn(MaterialMeshBundle {
        mesh: meshes.add(Mesh::from(shape::Plane::from_size(4.0))),
        material: materials.add(AnimatedMaterial {
            time: 0.0,
            speed: 2.0,
            amplitude: 0.2,
            color: Color::WHITE,
        }),
        ..default()
    });
}
```

## üìä Bind Groups v√† Resource Layout

### Hi·ªÉu v·ªÅ Bind Groups

```mermaid
graph LR
    A[CPU Data] --> B[Buffer]
    B --> C[Bind Group]
    C --> D[Shader @binding]
    
    subgraph "Bind Group 0 - Built-in"
        E[Camera matrices]
        F[Mesh transforms]
    end
    
    subgraph "Bind Group 1 - Material" 
        G[Custom uniforms]
        H[Textures]
    end
```

### Binding Layout Table

| Group | Binding | Type | M√¥ t·∫£ |
|-------|---------|------|--------|
| 0 | 0 | uniform | View transforms (camera) |
| 0 | 1 | uniform | Model transforms (mesh) |
| 1 | 0 | uniform | Material properties |
| 1 | 1 | texture | Diffuse texture |
| 1 | 2 | sampler | Texture sampler |

### Advanced Binding Example

```rust
#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct AdvancedMaterial {
    // Binding 0 - uniforms
    #[uniform(0)]
    pub properties: MaterialProperties,
    
    // Binding 1 - main texture
    #[texture(1)]
    #[sampler(2)]
    pub diffuse_texture: Option<Handle<Image>>,
    
    // Binding 3 - normal map  
    #[texture(3)]
    #[sampler(4)]
    pub normal_map: Option<Handle<Image>>,
}

#[derive(ShaderType, Debug, Clone)]
pub struct MaterialProperties {
    pub time: f32,
    pub metallic: f32,
    pub roughness: f32, 
    pub _padding: f32,  // Alignment
    pub base_color: Vec4,
    pub emissive: Vec3,
    pub _padding2: f32, // Alignment
}
```

## üîß Debug v√† Troubleshooting

### Common Issues v√† Solutions

<div className="overflow-x-auto">
  <table className="min-w-full bg-white border border-gray-200">
    <thead className="bg-gray-100">
      <tr>
        <th className="px-4 py-2 text-left">L·ªói</th>
        <th className="px-4 py-2 text-left">Nguy√™n nh√¢n</th>
        <th className="px-4 py-2 text-left">Gi·∫£i ph√°p</th>
      </tr>
    </thead>
    <tbody>
      <tr className="border-t">
        <td className="px-4 py-2 font-mono text-red-600">Alignment error</td>
        <td className="px-4 py-2">Struct kh√¥ng tu√¢n theo std140</td>
        <td className="px-4 py-2">Th√™m padding fields</td>
      </tr>
      <tr className="border-t bg-gray-50">
        <td className="px-4 py-2 font-mono text-red-600">Binding not found</td>
        <td className="px-4 py-2">Sai group/binding index</td>
        <td className="px-4 py-2">Ki·ªÉm tra @group/@binding numbers</td>
      </tr>
      <tr className="border-t">
        <td className="px-4 py-2 font-mono text-red-600">Buffer too large</td>
        <td className="px-4 py-2">Uniform buffer qu√° l·ªõn</td>
        <td className="px-4 py-2">D√πng storage buffer thay th·∫ø</td>
      </tr>
    </tbody>
  </table>
</div>

### Debug Tools

```rust
// Enable shader validation
fn setup_debug() {
    std::env::set_var("RUST_LOG", "wgpu_core=debug");
}

// Print uniform layout
impl MaterialProperties {
    pub fn print_layout() {
        println!("MaterialProperties layout:");
        println!("  time: offset={}, size={}", 0, 4);
        println!("  metallic: offset={}, size={}", 4, 4);
        println!("  roughness: offset={}, size={}", 8, 4);
        println!("  _padding: offset={}, size={}", 12, 4);
        println!("  base_color: offset={}, size={}", 16, 16);
        println!("  Total size: {}", 32);
    }
}
```

## üèãÔ∏è B√†i t·∫≠p th·ª±c h√†nh

<div className="bg-green-50 border-l-4 border-green-400 p-4 my-6">
  <h3 className="font-bold text-green-800">B√†i t·∫≠p 1: Pulsing Sphere</h3>
  <p className="text-green-700">
    T·∫°o m·ªôt material l√†m cho sphere thay ƒë·ªïi k√≠ch th∆∞·ªõc theo th·ªùi gian v·ªõi hi·ªáu ·ª©ng pulse.
    S·ª≠ d·ª•ng uniform ƒë·ªÉ ƒëi·ªÅu khi·ªÉn t·∫ßn s·ªë v√† amplitude.
  </p>
</div>

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 my-6">
  <h3 className="font-bold text-blue-800">B√†i t·∫≠p 2: Interactive Color Mixer</h3>
  <p className="text-blue-700">
    T·∫°o material cho ph√©p thay ƒë·ªïi m√†u s·∫Øc b·∫±ng c√°ch tr·ªôn 3 m√†u c∆° b·∫£n th√¥ng qua 
    keyboard input. S·ª≠ d·ª•ng uniform ƒë·ªÉ truy·ªÅn weight c·ªßa t·ª´ng m√†u.
  </p>
</div>

<div className="bg-purple-50 border-l-4 border-purple-400 p-4 my-6">
  <h3 className="font-bold text-purple-800">B√†i t·∫≠p 3: Multi-object Animation</h3>
  <p className="text-purple-700">
    T·∫°o nhi·ªÅu objects v·ªõi c√πng material nh∆∞ng c√°c tham s·ªë uniform kh√°c nhau 
    (offset phase, speed, amplitude) ƒë·ªÉ t·∫°o animation kh√¥ng ƒë·ªìng b·ªô.
  </p>
</div>

## üìà Performance Tips

### Best Practices

| Nguy√™n t·∫Øc | M√¥ t·∫£ | V√≠ d·ª• |
|------------|-------|--------|
| **Minimize Updates** | Ch·ªâ update uniform khi c·∫ßn thi·∫øt | Cache values, dirty flags |
| **Pack Data** | S·ª≠ d·ª•ng h·∫øt kh√¥ng gian uniform | vec4 thay v√¨ 4 float ri√™ng |
| **Constant Folding** | GPU c√≥ th·ªÉ optimize constants | `const PI: f32 = 3.14159;` |
| **Reduce Branching** | Tr√°nh if/else trong shader | D√πng mix(), step(), smoothstep() |

### Memory Usage Monitoring

```rust
fn monitor_uniform_usage(
    materials: Res<Assets<AnimatedMaterial>>,
) {
    let count = materials.iter().count();
    let size_per_material = std::mem::size_of::<MaterialProperties>();
    let total_uniform_memory = count * size_per_material;
    
    if total_uniform_memory > 1024 * 1024 {  // 1MB
        warn!("High uniform memory usage: {}KB", total_uniform_memory / 1024);
    }
}
```

## üéØ T√≥m t·∫Øt

<div className="bg-gray-50 p-6 rounded-lg">
  <h3 className="text-lg font-bold mb-4">Key Takeaways:</h3>
  
  <ul className="space-y-2 list-disc list-inside">
    <li><strong>Uniforms</strong> l√† c·∫ßu n·ªëi quan tr·ªçng gi·ªØa CPU v√† GPU</li>
    <li><strong>Memory alignment</strong> l√† y·∫øu t·ªë then ch·ªët trong WGSL</li>
    <li><strong>AsBindGroup derive macro</strong> ƒë∆°n gi·∫£n h√≥a binding setup</li>
    <li><strong>Performance</strong> ph·ª• thu·ªôc v√†o c√°ch t·ªï ch·ª©c v√† c·∫≠p nh·∫≠t data</li>
    <li><strong>Debug tools</strong> gi√∫p troubleshoot alignment v√† binding issues</li>
  </ul>
</div>

---

<div className="text-center py-8">
  <div className="inline-flex items-center px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white font-semibold rounded-lg shadow-lg">
    <span className="mr-2">üöÄ</span>
    B√†i ti·∫øp theo: Vertex Transformation c∆° b·∫£n
  </div>
</div>