# B√†i 17: B-Trees v√† Advanced Tree Structures

<div className="border-l-4 border-blue-500 bg-blue-50 p-4 mb-6 rounded-r-lg">
  <h2 className="text-xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <p className="text-blue-700">Hi·ªÉu v√† c√†i ƒë·∫∑t c√°c c·∫•u tr√∫c c√¢y n√¢ng cao: B-Tree, B+ Tree, Trie v√† Segment Tree ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu l·ªõn hi·ªáu qu·∫£.</p>
</div>

## 1. B-Trees - C√¢y t√¨m ki·∫øm c√¢n b·∫±ng cho d·ªØ li·ªáu l·ªõn

### 1.1 Kh√°i ni·ªám c∆° b·∫£n

**B-Tree** l√† m·ªôt c√¢y t√¨m ki·∫øm c√¢n b·∫±ng ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·∫∑c bi·ªát ƒë·ªÉ l∆∞u tr·ªØ v√† truy xu·∫•t d·ªØ li·ªáu tr√™n c√°c thi·∫øt b·ªã l∆∞u tr·ªØ c√≥ t·ªëc ƒë·ªô truy c·∫≠p ch·∫≠m nh∆∞ ·ªï c·ª©ng.

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
  <h3 className="font-semibold text-yellow-800 mb-2">üîë ƒê·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa B-Tree</h3>
  <ul className="text-yellow-700 space-y-1">
    <li>‚Ä¢ M·ªói node c√≥ th·ªÉ ch·ª©a nhi·ªÅu key (kh√¥ng ch·ªâ 1 nh∆∞ BST)</li>
    <li>‚Ä¢ T·∫•t c·∫£ leaf nodes ·ªü c√πng level (perfectly balanced)</li>
    <li>‚Ä¢ Minimizes disk I/O operations</li>
    <li>‚Ä¢ Self-balancing structure</li>
  </ul>
</div>

### 1.2 C·∫•u tr√∫c B-Tree

```mermaid
graph TD
    A["[10, 20]"] --> B["[5, 7]"]
    A --> C["[15, 17]"] 
    A --> D["[25, 30]"]
    B --> E["[1, 3]"]
    B --> F["[6]"]
    B --> G["[8, 9]"]
    C --> H["[12, 14]"]
    C --> I["[16]"]
    C --> J["[18, 19]"]
    D --> K["[22, 24]"]
    D --> L["[27, 28]"]
    D --> M["[35, 40]"]
```

### 1.3 Properties c·ªßa B-Tree

| Property | M√¥ t·∫£ | Gi√° tr·ªã |
|----------|-------|---------|
| **Order (m)** | S·ªë con t·ªëi ƒëa c·ªßa m·ªôt node | Th∆∞·ªùng l√† s·ªë ch·∫µn |
| **Min keys** | S·ªë key t·ªëi thi·ªÉu trong internal node | ‚åàm/2‚åâ - 1 |
| **Max keys** | S·ªë key t·ªëi ƒëa trong m·ªôt node | m - 1 |
| **Min children** | S·ªë con t·ªëi thi·ªÉu c·ªßa internal node | ‚åàm/2‚åâ |
| **Max children** | S·ªë con t·ªëi ƒëa c·ªßa m·ªôt node | m |

### 1.4 C√†i ƒë·∫∑t B-Tree trong Rust

```rust
use std::fmt::Debug;

#[derive(Debug, Clone)]
pub struct BTreeNode<T: Ord + Clone + Debug> {
    keys: Vec<T>,
    children: Vec<Box<BTreeNode<T>>>,
    is_leaf: bool,
}

#[derive(Debug)]
pub struct BTree<T: Ord + Clone + Debug> {
    root: Option<Box<BTreeNode<T>>>,
    min_degree: usize, // t trong ƒë·ªãnh nghƒ©a B-Tree
}

impl<T: Ord + Clone + Debug> BTreeNode<T> {
    fn new(is_leaf: bool) -> Self {
        Self {
            keys: Vec::new(),
            children: Vec::new(),
            is_leaf,
        }
    }
    
    // T√¨m ki·∫øm key trong node
    fn search(&self, key: &T) -> bool {
        let mut i = 0;
        
        // T√¨m v·ªã tr√≠ ƒë·∫ßu ti√™n m√† key[i] >= key
        while i < self.keys.len() && key > &self.keys[i] {
            i += 1;
        }
        
        // N·∫øu t√¨m th·∫•y key
        if i < self.keys.len() && key == &self.keys[i] {
            return true;
        }
        
        // N·∫øu l√† leaf node v√† kh√¥ng t√¨m th·∫•y
        if self.is_leaf {
            return false;
        }
        
        // T√¨m ki·∫øm trong subtree
        self.children[i].search(key)
    }
    
    // Ch√®n key khi node ch∆∞a full
    fn insert_non_full(&mut self, key: T, min_degree: usize) {
        let mut i = self.keys.len() as i32 - 1;
        
        if self.is_leaf {
            // Ch√®n v√†o leaf node
            self.keys.push(key.clone());
            
            // D·ªãch chuy·ªÉn c√°c key l·ªõn h∆°n
            while i >= 0 && self.keys[i as usize] > key {
                self.keys.swap(i as usize, (i + 1) as usize);
                i -= 1;
            }
        } else {
            // T√¨m child ƒë·ªÉ ch√®n
            while i >= 0 && self.keys[i as usize] > key {
                i -= 1;
            }
            i += 1;
            
            // Ki·ªÉm tra xem child c√≥ full kh√¥ng
            if self.children[i as usize].keys.len() == 2 * min_degree - 1 {
                self.split_child(i as usize, min_degree);
                
                // Sau khi split, x√°c ƒë·ªãnh child n√†o ƒë·ªÉ ch√®n
                if self.keys[i as usize] < key {
                    i += 1;
                }
            }
            
            self.children[i as usize].insert_non_full(key, min_degree);
        }
    }
    
    // Split child node khi full
    fn split_child(&mut self, index: usize, min_degree: usize) {
        let full_child = &mut self.children[index];
        let mut new_child = Box::new(BTreeNode::new(full_child.is_leaf));
        
        // Copy second half c·ªßa keys
        new_child.keys = full_child.keys.split_off(min_degree);
        
        // Copy second half c·ªßa children n·∫øu kh√¥ng ph·∫£i leaf
        if !full_child.is_leaf {
            new_child.children = full_child.children.split_off(min_degree);
        }
        
        // L·∫•y middle key l√™n parent
        let middle_key = full_child.keys.pop().unwrap();
        
        // Ch√®n middle key v√†o parent
        self.keys.insert(index, middle_key);
        self.children.insert(index + 1, new_child);
    }
}

impl<T: Ord + Clone + Debug> BTree<T> {
    pub fn new(min_degree: usize) -> Self {
        Self {
            root: None,
            min_degree,
        }
    }
    
    pub fn search(&self, key: &T) -> bool {
        match &self.root {
            Some(root) => root.search(key),
            None => false,
        }
    }
    
    pub fn insert(&mut self, key: T) {
        if self.root.is_none() {
            let mut root = BTreeNode::new(true);
            root.keys.push(key);
            self.root = Some(Box::new(root));
            return;
        }
        
        let root = self.root.as_ref().unwrap();
        
        // N·∫øu root full, c·∫ßn t·∫°o root m·ªõi
        if root.keys.len() == 2 * self.min_degree - 1 {
            let mut new_root = BTreeNode::new(false);
            new_root.children.push(self.root.take().unwrap());
            new_root.split_child(0, self.min_degree);
            
            self.root = Some(Box::new(new_root));
        }
        
        self.root.as_mut().unwrap().insert_non_full(key, self.min_degree);
    }
}
```

### 1.5 V√≠ d·ª• v·ªÅ B-Tree Operations

<div className="overflow-x-auto">
  <table className="min-w-full border-collapse border border-gray-300">
    <thead className="bg-gray-100">
      <tr>
        <th className="border border-gray-300 px-4 py-2">Operation</th>
        <th className="border border-gray-300 px-4 py-2">Time Complexity</th>
        <th className="border border-gray-300 px-4 py-2">Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="border border-gray-300 px-4 py-2">Search</td>
        <td className="border border-gray-300 px-4 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">T√¨m ki·∫øm key trong c√¢y</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-4 py-2">Insert</td>
        <td className="border border-gray-300 px-4 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">Ch√®n key m·ªõi, c√≥ th·ªÉ c·∫ßn split nodes</td>
      </tr>
      <tr>
        <td className="border border-gray-300 px-4 py-2">Delete</td>
        <td className="border border-gray-300 px-4 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">X√≥a key, c√≥ th·ªÉ c·∫ßn merge nodes</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-4 py-2">Split</td>
        <td className="border border-gray-300 px-4 py-2 font-mono">O(t)</td>
        <td className="border border-gray-300 px-4 py-2">Chia node khi qu√° ƒë·∫ßy</td>
      </tr>
    </tbody>
  </table>
</div>

## 2. B+ Trees - C·∫£i ti·∫øn c·ªßa B-Tree

### 2.1 S·ª± kh√°c bi·ªát gi·ªØa B-Tree v√† B+ Tree

```mermaid
graph TD
    subgraph "B+ Tree Structure"
        A1["[10, 20]<br/>Internal Node"] --> B1["[5, 10]<br/>Internal Node"]
        A1 --> C1["[15, 20]<br/>Internal Node"]
        A1 --> D1["[25, 30]<br/>Internal Node"]
        B1 --> E1["[1,3,5,7] ‚Üí [10,12,15] ‚Üí [17,18,20] ‚Üí [22,24,25] ‚Üí [27,28,30]<br/>Leaf Level (Linked)"]
    end
```

### 2.2 So s√°nh B-Tree vs B+ Tree

| ƒê·∫∑c ƒëi·ªÉm | B-Tree | B+ Tree |
|----------|---------|----------|
| **Data Storage** | C·∫£ internal v√† leaf nodes | Ch·ªâ leaf nodes |
| **Internal Nodes** | Ch·ª©a keys v√† data | Ch·ªâ ch·ª©a keys (index) |
| **Leaf Connections** | Kh√¥ng li√™n k·∫øt | Linked list |
| **Range Queries** | C·∫ßn traversal | Sequential scan |
| **Storage Efficiency** | Th·∫•p h∆°n | Cao h∆°n |

## 3. Trie (Prefix Tree) - C√¢y ti·ªÅn t·ªë

### 3.1 C·∫•u tr√∫c v√† ·ª©ng d·ª•ng

**Trie** l√† c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ v√† t√¨m ki·∫øm strings hi·ªáu qu·∫£.

```mermaid
graph TD
    ROOT["Root"] --> A["a"]
    ROOT --> B["b"]
    ROOT --> C["c"]
    A --> A1["n"]
    A --> A2["p"]
    A1 --> A11["d"] 
    A2 --> A21["p"]
    A21 --> A211["l"]
    A211 --> A2111["e*"]
    B --> B1["a"]
    B1 --> B11["t*"]
    C --> C1["a"]
    C1 --> C11["r*"]
    C1 --> C12["t*"]
```

### 3.2 C√†i ƒë·∫∑t Trie

```rust
use std::collections::HashMap;

#[derive(Debug)]
struct TrieNode {
    children: HashMap<char, Box<TrieNode>>,
    is_end_of_word: bool,
}

impl TrieNode {
    fn new() -> Self {
        Self {
            children: HashMap::new(),
            is_end_of_word: false,
        }
    }
}

#[derive(Debug)]
pub struct Trie {
    root: TrieNode,
}

impl Trie {
    pub fn new() -> Self {
        Self {
            root: TrieNode::new(),
        }
    }
    
    // Ch√®n word v√†o Trie
    pub fn insert(&mut self, word: &str) {
        let mut current = &mut self.root;
        
        for ch in word.chars() {
            current = current.children
                .entry(ch)
                .or_insert_with(|| Box::new(TrieNode::new()));
        }
        
        current.is_end_of_word = true;
    }
    
    // T√¨m ki·∫øm word trong Trie
    pub fn search(&self, word: &str) -> bool {
        let mut current = &self.root;
        
        for ch in word.chars() {
            match current.children.get(&ch) {
                Some(node) => current = node,
                None => return false,
            }
        }
        
        current.is_end_of_word
    }
    
    // Ki·ªÉm tra prefix c√≥ t·ªìn t·∫°i kh√¥ng
    pub fn starts_with(&self, prefix: &str) -> bool {
        let mut current = &self.root;
        
        for ch in prefix.chars() {
            match current.children.get(&ch) {
                Some(node) => current = node,
                None => return false,
            }
        }
        
        true
    }
    
    // T√¨m t·∫•t c·∫£ words v·ªõi prefix cho tr∆∞·ªõc
    pub fn find_words_with_prefix(&self, prefix: &str) -> Vec<String> {
        let mut result = Vec::new();
        let mut current = &self.root;
        
        // Navigate to prefix
        for ch in prefix.chars() {
            match current.children.get(&ch) {
                Some(node) => current = node,
                None => return result,
            }
        }
        
        // Collect all words from this point
        self.collect_words(current, prefix.to_string(), &mut result);
        result
    }
    
    fn collect_words(&self, node: &TrieNode, current_word: String, result: &mut Vec<String>) {
        if node.is_end_of_word {
            result.push(current_word.clone());
        }
        
        for (ch, child_node) in &node.children {
            let mut new_word = current_word.clone();
            new_word.push(*ch);
            self.collect_words(child_node, new_word, result);
        }
    }
}
```

## 4. Segment Tree - C√¢y ph√¢n ƒëo·∫°n

### 4.1 Kh√°i ni·ªám v√† ·ª©ng d·ª•ng

**Segment Tree** ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ tr·∫£ l·ªùi c√°c range queries hi·ªáu qu·∫£ nh∆∞: t·ªïng ƒëo·∫°n, min/max ƒëo·∫°n, etc.

```mermaid
graph TD
    A["sum(0,7) = 36"] --> B["sum(0,3) = 10"]
    A --> C["sum(4,7) = 26"]
    B --> D["sum(0,1) = 3"]
    B --> E["sum(2,3) = 7"]
    C --> F["sum(4,5) = 11"]
    C --> G["sum(6,7) = 15"]
    D --> H["arr[0] = 1"]
    D --> I["arr[1] = 2"]
    E --> J["arr[2] = 3"]
    E --> K["arr[3] = 4"]
    F --> L["arr[4] = 5"]
    F --> M["arr[5] = 6"]
    G --> N["arr[6] = 7"]
    G --> O["arr[7] = 8"]
```

### 4.2 C√†i ƒë·∫∑t Segment Tree

```rust
pub struct SegmentTree {
    tree: Vec<i64>,
    n: usize,
}

impl SegmentTree {
    pub fn new(arr: &[i64]) -> Self {
        let n = arr.len();
        let mut tree = vec![0; 4 * n]; // 4*n ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªß space
        
        let mut seg_tree = Self { tree, n };
        seg_tree.build(arr, 0, 0, n - 1);
        seg_tree
    }
    
    // Build segment tree
    fn build(&mut self, arr: &[i64], node: usize, start: usize, end: usize) {
        if start == end {
            // Leaf node
            self.tree[node] = arr[start];
        } else {
            let mid = (start + end) / 2;
            let left_child = 2 * node + 1;
            let right_child = 2 * node + 2;
            
            // Build left v√† right subtrees
            self.build(arr, left_child, start, mid);
            self.build(arr, right_child, mid + 1, end);
            
            // Internal node value = sum of children
            self.tree[node] = self.tree[left_child] + self.tree[right_child];
        }
    }
    
    // Query range sum
    pub fn query(&self, l: usize, r: usize) -> i64 {
        self.query_helper(0, 0, self.n - 1, l, r)
    }
    
    fn query_helper(&self, node: usize, start: usize, end: usize, l: usize, r: usize) -> i64 {
        // No overlap
        if r < start || end < l {
            return 0;
        }
        
        // Complete overlap
        if l <= start && end <= r {
            return self.tree[node];
        }
        
        // Partial overlap
        let mid = (start + end) / 2;
        let left_sum = self.query_helper(2 * node + 1, start, mid, l, r);
        let right_sum = self.query_helper(2 * node + 2, mid + 1, end, l, r);
        
        left_sum + right_sum
    }
    
    // Update single element
    pub fn update(&mut self, idx: usize, val: i64) {
        self.update_helper(0, 0, self.n - 1, idx, val);
    }
    
    fn update_helper(&mut self, node: usize, start: usize, end: usize, idx: usize, val: i64) {
        if start == end {
            // Leaf node
            self.tree[node] = val;
        } else {
            let mid = (start + end) / 2;
            let left_child = 2 * node + 1;
            let right_child = 2 * node + 2;
            
            if idx <= mid {
                self.update_helper(left_child, start, mid, idx, val);
            } else {
                self.update_helper(right_child, mid + 1, end, idx, val);
            }
            
            // Update internal node
            self.tree[node] = self.tree[left_child] + self.tree[right_child];
        }
    }
}
```

## 5. So s√°nh c√°c Advanced Tree Structures

<div className="overflow-x-auto">
  <table className="min-w-full border-collapse border border-gray-300">
    <thead className="bg-blue-100">
      <tr>
        <th className="border border-gray-300 px-3 py-2">Structure</th>
        <th className="border border-gray-300 px-3 py-2">Primary Use</th>
        <th className="border border-gray-300 px-3 py-2">Search</th>
        <th className="border border-gray-300 px-3 py-2">Insert/Delete</th>
        <th className="border border-gray-300 px-3 py-2">Space</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="border border-gray-300 px-3 py-2 font-semibold">B-Tree</td>
        <td className="border border-gray-300 px-3 py-2">Database indexing</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(n)</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-3 py-2 font-semibold">B+ Tree</td>
        <td className="border border-gray-300 px-3 py-2">File systems, Range queries</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(n)</td>
      </tr>
      <tr>
        <td className="border border-gray-300 px-3 py-2 font-semibold">Trie</td>
        <td className="border border-gray-300 px-3 py-2">String operations, Autocomplete</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(m)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(m)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(ALPHABET_SIZE * N * M)</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-3 py-2 font-semibold">Segment Tree</td>
        <td className="border border-gray-300 px-3 py-2">Range queries, Updates</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(log n)</td>
        <td className="border border-gray-300 px-3 py-2 font-mono">O(4n)</td>
      </tr>
    </tbody>
  </table>
</div>

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mt-6">
  <h3 className="font-semibold text-green-800 mb-2">üí° Khi n√†o s·ª≠ d·ª•ng c·∫•u tr√∫c n√†o?</h3>
  <div className="text-green-700 space-y-2">
    <p><strong>B-Trees:</strong> Database systems, file systems khi c·∫ßn minimize disk I/O</p>
    <p><strong>B+ Trees:</strong> Khi c·∫ßn range queries th∆∞·ªùng xuy√™n v√† sequential access</p>
    <p><strong>Trie:</strong> Autocomplete, spell checkers, IP routing tables</p>
    <p><strong>Segment Tree:</strong> Range sum/min/max queries v·ªõi frequent updates</p>
  </div>
</div>

## 6. B√†i t·∫≠p LeetCode li√™n quan

### Danh s√°ch b√†i t·∫≠p ƒë∆∞·ª£c khuy·∫øn ngh·ªã:

| Problem | Difficulty | Concept | LeetCode ID |
|---------|-----------|---------|-------------|
| Implement Trie (Prefix Tree) | Medium | Trie Implementation | #208 |
| Word Search II | Hard | Trie + Backtracking | #212 |
| Replace Words | Medium | Trie Applications | #648 |
| Map Sum Pairs | Medium | Trie with Values | #677 |
| Range Sum Query - Mutable | Medium | Segment Tree | #307 |
| Range Sum Query 2D - Mutable | Hard | 2D Segment Tree | #308 |
| Count of Smaller Numbers After Self | Hard | Advanced Segment Tree | #315 |
| Design Add and Search Words Data Structure | Medium | Trie with Wildcards | #211 |

### B√†i t·∫≠p th·ª±c h√†nh n√¢ng cao:

1. **Trie v·ªõi Auto-complete**: C√†i ƒë·∫∑t system g·ª£i √Ω t·ª´ kh√≥a
2. **B-Tree Visualization**: T·∫°o tool visualization cho B-Tree operations  
3. **Range Query System**: X√¢y d·ª±ng system tr·∫£ l·ªùi multiple types of range queries
4. **String Matching Engine**: S·ª≠ d·ª•ng Trie ƒë·ªÉ implement efficient string matching

<div className="border-t-4 border-purple-500 bg-purple-50 p-4 mt-8 rounded-b-lg">
  <h3 className="font-bold text-purple-800 mb-2">üìö T·ªïng k·∫øt</h3>
  <p className="text-purple-700">Advanced Tree Structures l√† foundation cho nhi·ªÅu ·ª©ng d·ª•ng th·ª±c t·∫ø. B-Trees optimize disk operations, Tries excel at string processing, v√† Segment Trees handle range queries efficiently. Hi·ªÉu r√µ trade-offs c·ªßa t·ª´ng structure gi√∫p ch·ªçn ƒë∆∞·ª£c gi·∫£i ph√°p t·ªëi ∆∞u cho t·ª´ng b√†i to√°n c·ª• th·ªÉ.</p>
</div>