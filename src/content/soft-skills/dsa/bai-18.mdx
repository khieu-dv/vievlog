# BÃ i 18: Graph Data Structures - Cáº¥u trÃºc dá»¯ liá»‡u Ä‘á»“ thá»‹

<div className="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-800 mb-3">ğŸ¯ Má»¥c tiÃªu bÃ i há»c</h2>
  <ul className="list-disc list-inside text-blue-700 space-y-2">
    <li>Hiá»ƒu Ä‘á»‹nh nghÄ©a vÃ  khÃ¡i niá»‡m cÆ¡ báº£n vá» Graph</li>
    <li>Náº¯m vá»¯ng cÃ¡c cÃ¡ch biá»ƒu diá»…n Graph trong bá»™ nhá»›</li>
    <li>So sÃ¡nh Æ°u nhÆ°á»£c Ä‘iá»ƒm cá»§a tá»«ng phÆ°Æ¡ng phÃ¡p biá»ƒu diá»…n</li>
    <li>CÃ i Ä‘áº·t Graph class vá»›i cÃ¡c thao tÃ¡c cÆ¡ báº£n báº±ng Rust</li>
  </ul>
</div>

## ğŸ“š 1. Äá»‹nh nghÄ©a Graph

**Graph** lÃ  má»™t cáº¥u trÃºc dá»¯ liá»‡u phi tuyáº¿n tÃ­nh bao gá»“m:
- **Vertices (Äá»‰nh)**: CÃ¡c nÃºt trong Ä‘á»“ thá»‹, kÃ½ hiá»‡u lÃ  V
- **Edges (Cáº¡nh)**: CÃ¡c káº¿t ná»‘i giá»¯a cÃ¡c Ä‘á»‰nh, kÃ½ hiá»‡u lÃ  E

**KÃ½ hiá»‡u toÃ¡n há»c**: G = (V, E)

### ğŸ” PhÃ¢n loáº¡i Graph

| Loáº¡i Graph | MÃ´ táº£ | VÃ­ dá»¥ á»©ng dá»¥ng |
|------------|-------|----------------|
| **Directed Graph (Äá»“ thá»‹ cÃ³ hÆ°á»›ng)** | CÃ¡c cáº¡nh cÃ³ hÆ°á»›ng tá»« Ä‘á»‰nh nÃ y Ä‘áº¿n Ä‘á»‰nh khÃ¡c | Máº¡ng xÃ£ há»™i (follow), Web links |
| **Undirected Graph (Äá»“ thá»‹ vÃ´ hÆ°á»›ng)** | CÃ¡c cáº¡nh khÃ´ng cÃ³ hÆ°á»›ng, káº¿t ná»‘i hai chiá»u | Máº¡ng báº¡n bÃ¨, ÄÆ°á»ng giao thÃ´ng |
| **Weighted Graph (Äá»“ thá»‹ cÃ³ trá»ng sá»‘)** | Má»—i cáº¡nh cÃ³ má»™t giÃ¡ trá»‹ trá»ng sá»‘ | Báº£n Ä‘á»“ vá»›i khoáº£ng cÃ¡ch, Chi phÃ­ váº­n chuyá»ƒn |
| **Unweighted Graph (Äá»“ thá»‹ khÃ´ng trá»ng sá»‘)** | Táº¥t cáº£ cáº¡nh cÃ³ trá»ng sá»‘ báº±ng nhau | MÃª cung, Cáº¥u trÃºc tá»• chá»©c |

```mermaid
graph TB
    subgraph "Directed Graph"
        A1 --> B1
        B1 --> C1
        C1 --> A1
        A1 --> C1
    end
    
    subgraph "Undirected Graph"
        A2 --- B2
        B2 --- C2
        C2 --- A2
    end
    
    subgraph "Weighted Graph"
        A3 ---|5| B3
        B3 ---|3| C3
        C3 ---|7| A3
    end
```

## ğŸ—ï¸ 2. CÃ¡c thuá»™c tÃ­nh quan trá»ng cá»§a Graph

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
  <div className="bg-green-50 p-4 rounded-lg border border-green-200">
    <h3 className="font-bold text-green-800 mb-2">Degree (Báº­c)</h3>
    <p className="text-green-700">Sá»‘ cáº¡nh káº¿t ná»‘i vá»›i má»™t Ä‘á»‰nh</p>
    <ul className="text-sm text-green-600 mt-2">
      <li>â€¢ In-degree: Sá»‘ cáº¡nh Ä‘i vÃ o (directed)</li>
      <li>â€¢ Out-degree: Sá»‘ cáº¡nh Ä‘i ra (directed)</li>
    </ul>
  </div>
  
  <div className="bg-purple-50 p-4 rounded-lg border border-purple-200">
    <h3 className="font-bold text-purple-800 mb-2">Path (ÄÆ°á»ng Ä‘i)</h3>
    <p className="text-purple-700">Chuá»—i cÃ¡c Ä‘á»‰nh káº¿t ná»‘i liÃªn tiáº¿p</p>
    <ul className="text-sm text-purple-600 mt-2">
      <li>â€¢ Simple path: KhÃ´ng láº·p láº¡i Ä‘á»‰nh</li>
      <li>â€¢ Cycle: ÄÆ°á»ng Ä‘i khÃ©p kÃ­n</li>
    </ul>
  </div>
</div>

### ğŸ“Š Báº£ng tÃ­nh cháº¥t Graph

| TÃ­nh cháº¥t | Directed Graph | Undirected Graph |
|-----------|----------------|------------------|
| **Sá»‘ cáº¡nh tá»‘i Ä‘a** | V Ã— (V-1) | V Ã— (V-1) / 2 |
| **Degree tá»•ng** | 2E | 2E |
| **Connected** | Weakly/Strongly | Simply connected |
| **Cycle detection** | DFS vá»›i 3 mÃ u | DFS vá»›i parent tracking |

## ğŸ’¾ 3. CÃ¡c phÆ°Æ¡ng phÃ¡p biá»ƒu diá»…n Graph

### 3.1 Adjacency Matrix (Ma tráº­n ká»)

Ma tráº­n 2D kÃ­ch thÆ°á»›c VÃ—V, trong Ä‘Ã³:
- `matrix[i][j] = 1` náº¿u cÃ³ cáº¡nh tá»« Ä‘á»‰nh i Ä‘áº¿n Ä‘á»‰nh j
- `matrix[i][j] = weight` náº¿u lÃ  weighted graph

```rust
#[derive(Debug, Clone)]
pub struct AdjacencyMatrix {
    matrix: Vec<Vec<i32>>,
    vertices: usize,
    is_directed: bool,
}

impl AdjacencyMatrix {
    pub fn new(vertices: usize, is_directed: bool) -> Self {
        Self {
            matrix: vec![vec![0; vertices]; vertices],
            vertices,
            is_directed,
        }
    }
    
    pub fn add_edge(&mut self, from: usize, to: usize, weight: i32) {
        if from < self.vertices && to < self.vertices {
            self.matrix[from][to] = weight;
            if !self.is_directed {
                self.matrix[to][from] = weight;
            }
        }
    }
    
    pub fn has_edge(&self, from: usize, to: usize) -> bool {
        if from < self.vertices && to < self.vertices {
            return self.matrix[from][to] != 0;
        }
        false
    }
    
    pub fn get_neighbors(&self, vertex: usize) -> Vec<usize> {
        let mut neighbors = Vec::new();
        if vertex < self.vertices {
            for i in 0..self.vertices {
                if self.matrix[vertex][i] != 0 {
                    neighbors.push(i);
                }
            }
        }
        neighbors
    }
}
```

### 3.2 Adjacency List (Danh sÃ¡ch ká»)

Má»—i Ä‘á»‰nh cÃ³ má»™t danh sÃ¡ch chá»©a cÃ¡c Ä‘á»‰nh ká» vá»›i nÃ³.

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct AdjacencyList {
    graph: HashMap<usize, Vec<(usize, i32)>>, // (neighbor, weight)
    vertices: usize,
    is_directed: bool,
}

impl AdjacencyList {
    pub fn new(vertices: usize, is_directed: bool) -> Self {
        let mut graph = HashMap::new();
        for i in 0..vertices {
            graph.insert(i, Vec::new());
        }
        
        Self {
            graph,
            vertices,
            is_directed,
        }
    }
    
    pub fn add_edge(&mut self, from: usize, to: usize, weight: i32) {
        if from < self.vertices && to < self.vertices {
            self.graph.get_mut(&from).unwrap().push((to, weight));
            if !self.is_directed {
                self.graph.get_mut(&to).unwrap().push((from, weight));
            }
        }
    }
    
    pub fn remove_edge(&mut self, from: usize, to: usize) {
        if let Some(neighbors) = self.graph.get_mut(&from) {
            neighbors.retain(|(neighbor, _)| *neighbor != to);
        }
        
        if !self.is_directed {
            if let Some(neighbors) = self.graph.get_mut(&to) {
                neighbors.retain(|(neighbor, _)| *neighbor != from);
            }
        }
    }
    
    pub fn get_neighbors(&self, vertex: usize) -> Vec<(usize, i32)> {
        self.graph.get(&vertex).cloned().unwrap_or_default()
    }
    
    pub fn has_edge(&self, from: usize, to: usize) -> bool {
        if let Some(neighbors) = self.graph.get(&from) {
            return neighbors.iter().any(|(neighbor, _)| *neighbor == to);
        }
        false
    }
    
    pub fn get_degree(&self, vertex: usize) -> usize {
        self.graph.get(&vertex).map_or(0, |neighbors| neighbors.len())
    }
}
```

## âš–ï¸ 4. So sÃ¡nh Adjacency Matrix vs Adjacency List

| TiÃªu chÃ­ | Adjacency Matrix | Adjacency List |
|----------|------------------|----------------|
| **Space Complexity** | O(VÂ²) | O(V + E) |
| **Add Edge** | O(1) | O(1) |
| **Check Edge** | O(1) | O(degree) |
| **Get Neighbors** | O(V) | O(degree) |
| **Remove Edge** | O(1) | O(degree) |

<div className="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-400 my-6">
  <h3 className="font-bold text-yellow-800">ğŸ’¡ Khi nÃ o sá»­ dá»¥ng?</h3>
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
    <div>
      <h4 className="font-semibold text-yellow-700">Adjacency Matrix</h4>
      <ul className="text-sm text-yellow-600 mt-1">
        <li>â€¢ Dense graphs (nhiá»u cáº¡nh)</li>
        <li>â€¢ Cáº§n kiá»ƒm tra edge nhanh</li>
        <li>â€¢ Graph operations toÃ¡n há»c</li>
      </ul>
    </div>
    <div>
      <h4 className="font-semibold text-yellow-700">Adjacency List</h4>
      <ul className="text-sm text-yellow-600 mt-1">
        <li>â€¢ Sparse graphs (Ã­t cáº¡nh)</li>
        <li>â€¢ Tiáº¿t kiá»‡m bá»™ nhá»›</li>
        <li>â€¢ Duyá»‡t neighbors thÆ°á»ng xuyÃªn</li>
      </ul>
    </div>
  </div>
</div>

## ğŸ”¨ 5. CÃ i Ä‘áº·t Graph tá»•ng quÃ¡t

```rust
use std::fmt::Debug;

#[derive(Debug)]
pub enum GraphRepresentation<T: Clone + Debug> {
    Matrix(AdjacencyMatrix),
    List(AdjacencyList),
}

#[derive(Debug)]
pub struct Graph<T: Clone + Debug> {
    representation: GraphRepresentation<T>,
    vertex_data: Vec<T>,
    is_directed: bool,
}

impl<T: Clone + Debug> Graph<T> {
    pub fn new_with_matrix(vertices: usize, is_directed: bool) -> Self {
        Self {
            representation: GraphRepresentation::Matrix(
                AdjacencyMatrix::new(vertices, is_directed)
            ),
            vertex_data: Vec::with_capacity(vertices),
            is_directed,
        }
    }
    
    pub fn new_with_list(vertices: usize, is_directed: bool) -> Self {
        Self {
            representation: GraphRepresentation::List(
                AdjacencyList::new(vertices, is_directed)
            ),
            vertex_data: Vec::with_capacity(vertices),
            is_directed,
        }
    }
    
    pub fn add_vertex(&mut self, data: T) {
        self.vertex_data.push(data);
    }
    
    pub fn add_edge(&mut self, from: usize, to: usize, weight: i32) {
        match &mut self.representation {
            GraphRepresentation::Matrix(ref mut matrix) => {
                matrix.add_edge(from, to, weight);
            },
            GraphRepresentation::List(ref mut list) => {
                list.add_edge(from, to, weight);
            }
        }
    }
    
    pub fn has_edge(&self, from: usize, to: usize) -> bool {
        match &self.representation {
            GraphRepresentation::Matrix(matrix) => matrix.has_edge(from, to),
            GraphRepresentation::List(list) => list.has_edge(from, to),
        }
    }
    
    pub fn get_vertex_count(&self) -> usize {
        self.vertex_data.len()
    }
    
    pub fn print_graph(&self) {
        println!("Graph ({}directed):", if self.is_directed { "" } else { "un" });
        
        match &self.representation {
            GraphRepresentation::Matrix(matrix) => {
                println!("Adjacency Matrix:");
                for i in 0..matrix.vertices {
                    for j in 0..matrix.vertices {
                        print!("{:3} ", matrix.matrix[i][j]);
                    }
                    println!();
                }
            },
            GraphRepresentation::List(list) => {
                println!("Adjacency List:");
                for i in 0..list.vertices {
                    print!("Vertex {}: ", i);
                    let neighbors = list.get_neighbors(i);
                    for (neighbor, weight) in neighbors {
                        print!("({}, {}) ", neighbor, weight);
                    }
                    println!();
                }
            }
        }
    }
}
```

## ğŸ“‹ 6. VÃ­ dá»¥ sá»­ dá»¥ng thá»±c táº¿

```rust
fn main() {
    // Táº¡o undirected graph vá»›i adjacency list
    let mut graph = Graph::<&str>::new_with_list(5, false);
    
    // ThÃªm vertices
    let cities = ["HÃ  Ná»™i", "TP.HCM", "ÄÃ  Náºµng", "Háº£i PhÃ²ng", "Cáº§n ThÆ¡"];
    for city in cities.iter() {
        graph.add_vertex(*city);
    }
    
    // ThÃªm edges (khoáº£ng cÃ¡ch giáº£ Ä‘á»‹nh)
    graph.add_edge(0, 1, 1760); // HÃ  Ná»™i - TP.HCM
    graph.add_edge(0, 2, 760);  // HÃ  Ná»™i - ÄÃ  Náºµng
    graph.add_edge(0, 3, 120);  // HÃ  Ná»™i - Háº£i PhÃ²ng
    graph.add_edge(1, 4, 160);  // TP.HCM - Cáº§n ThÆ¡
    graph.add_edge(2, 1, 960);  // ÄÃ  Náºµng - TP.HCM
    
    graph.print_graph();
    
    // Kiá»ƒm tra káº¿t ná»‘i
    println!("CÃ³ Ä‘Æ°á»ng tá»« HÃ  Ná»™i Ä‘áº¿n TP.HCM? {}", graph.has_edge(0, 1));
    println!("CÃ³ Ä‘Æ°á»ng tá»« Háº£i PhÃ²ng Ä‘áº¿n Cáº§n ThÆ¡? {}", graph.has_edge(3, 4));
}
```

## ğŸ¯ 7. Äá»™ phá»©c táº¡p tÃ­nh toÃ¡n

```mermaid
graph TD
    A[Graph Operations] --> B[Adjacency Matrix]
    A --> C[Adjacency List]
    
    B --> B1[Space: O V^2]
    B --> B2[Add Edge: O 1]
    B --> B3[Check Edge: O 1]
    B --> B4[Get Neighbors: O V]
    
    C --> C1[Space: O V + E]
    C --> C2[Add Edge: O 1]
    C --> C3[Check Edge: O degree]
    C --> C4[Get Neighbors: O degree]
```

<div className="bg-red-50 p-4 rounded-lg border-l-4 border-red-400 my-6">
  <h3 className="font-bold text-red-800">âš ï¸ LÆ°u Ã½ quan trá»ng</h3>
  <ul className="text-red-700 space-y-1">
    <li>â€¢ Chá»n representation phÃ¹ há»£p vá»›i density cá»§a graph</li>
    <li>â€¢ Dense graph (E â‰ˆ VÂ²): dÃ¹ng Adjacency Matrix</li>
    <li>â€¢ Sparse graph (E &lt;&lt; VÂ²): dÃ¹ng Adjacency List</li>
    <li>â€¢ CÃ¢n nháº¯c trade-off giá»¯a space vÃ  time complexity</li>
  </ul>
</div>

## ğŸ“ 8. BÃ i táº­p thá»±c hÃ nh trÃªn LeetCode

| BÃ i táº­p | Äá»™ khÃ³ | Link | Ká»¹ thuáº­t chÃ­nh |
|---------|--------|------|----------------|
| **Graph Valid Tree** | Medium | [LeetCode 261](https://leetcode.com/problems/graph-valid-tree/) | Union-Find, DFS |
| **Number of Islands** | Medium | [LeetCode 200](https://leetcode.com/problems/number-of-islands/) | DFS/BFS |
| **Clone Graph** | Medium | [LeetCode 133](https://leetcode.com/problems/clone-graph/) | DFS/BFS + HashMap |
| **Course Schedule** | Medium | [LeetCode 207](https://leetcode.com/problems/course-schedule/) | Topological Sort |
| **Network Delay Time** | Medium | [LeetCode 743](https://leetcode.com/problems/network-delay-time/) | Dijkstra's Algorithm |
| **Find if Path Exists** | Easy | [LeetCode 1971](https://leetcode.com/problems/find-if-path-exists-in-graph/) | DFS/BFS/Union-Find |

## ğŸš€ 9. Tá»•ng káº¿t

Graph lÃ  cáº¥u trÃºc dá»¯ liá»‡u máº¡nh máº½ Ä‘á»ƒ mÃ´ hÃ¬nh hÃ³a cÃ¡c má»‘i quan há»‡ phá»©c táº¡p trong tháº¿ giá»›i thá»±c. Viá»‡c lá»±a chá»n phÆ°Æ¡ng phÃ¡p biá»ƒu diá»…n (Matrix vs List) phá»¥ thuá»™c vÃ o:

1. **Máº­t Ä‘á»™ graph** (dense vs sparse)
2. **Loáº¡i operations** thÆ°á»ng xuyÃªn sá»­ dá»¥ng
3. **Constraints vá» memory** vÃ  performance

Trong bÃ i tiáº¿p theo, chÃºng ta sáº½ há»c vá» cÃ¡c thuáº­t toÃ¡n duyá»‡t Graph (DFS, BFS) Ä‘á»ƒ khai thÃ¡c sá»©c máº¡nh cá»§a cáº¥u trÃºc dá»¯ liá»‡u nÃ y.

---

<div className="text-center text-sm text-gray-500 mt-8">
  <p>ğŸ“š <strong>BÃ i tiáº¿p theo:</strong> BÃ i 19 - Graph Search Algorithms (DFS & BFS)</p>
</div>