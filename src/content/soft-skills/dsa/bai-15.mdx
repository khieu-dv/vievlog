# B√†i 15: Binary Search Trees (BST)

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p

<div className="bg-blue-50 border-l-4 border-blue-500 p-4 my-4">
  <h3 className="text-lg font-semibold text-blue-800">Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:</h3>
  <ul className="text-blue-700 mt-2">
    <li>‚úÖ Hi·ªÉu ƒë∆∞·ª£c BST property v√† c√°ch duy tr√¨ th·ª© t·ª±</li>
    <li>‚úÖ Th√†nh th·∫°o c√°c thao t√°c insertion, search v√† deletion</li>
    <li>‚úÖ Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p v√† tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t</li>
    <li>‚úÖ C√†i ƒë·∫∑t BST ho√†n ch·ªânh b·∫±ng Rust</li>
  </ul>
</div>

## üìö 1. Kh√°i ni·ªám Binary Search Tree

**Binary Search Tree (BST)** l√† m·ªôt c√¢y nh·ªã ph√¢n ƒë·∫∑c bi·ªát c√≥ t√≠nh ch·∫•t:
- T·∫•t c·∫£ gi√° tr·ªã ·ªü c√¢y con tr√°i < gi√° tr·ªã node g·ªëc
- T·∫•t c·∫£ gi√° tr·ªã ·ªü c√¢y con ph·∫£i > gi√° tr·ªã node g·ªëc
- C√¢y con tr√°i v√† ph·∫£i c≈©ng l√† BST

### üîÑ Minh h·ªça BST Property

```mermaid
graph TD
    A[50] --> B[30]
    A --> C[70]
    B --> D[20]
    B --> E[40]
    C --> F[60]
    C --> G[80]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style D fill:#fff3e0
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#fff3e0
```

## üèóÔ∏è 2. C·∫•u tr√∫c d·ªØ li·ªáu BST

### ƒê·ªãnh nghƒ©a Node trong Rust

```rust
#[derive(Debug, Clone)]
pub struct TreeNode {
    pub val: i32,
    pub left: Option<Box<TreeNode>>,
    pub right: Option<Box<TreeNode>>,
}

impl TreeNode {
    pub fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}

pub struct BST {
    root: Option<Box<TreeNode>>,
}

impl BST {
    pub fn new() -> Self {
        BST { root: None }
    }
}
```

## üîç 3. Thao t√°c Search (T√¨m ki·∫øm)

### Thu·∫≠t to√°n Search

| B∆∞·ªõc | M√¥ t·∫£ | Complexity |
|------|-------|------------|
| 1 | So s√°nh key v·ªõi node hi·ªán t·∫°i | O(1) |
| 2 | N·∫øu b·∫±ng nhau ‚Üí T√¨m th·∫•y | O(1) |
| 3 | N·∫øu nh·ªè h∆°n ‚Üí T√¨m ·ªü c√¢y con tr√°i | O(log n) |
| 4 | N·∫øu l·ªõn h∆°n ‚Üí T√¨m ·ªü c√¢y con ph·∫£i | O(log n) |

### C√†i ƒë·∫∑t Search

```rust
impl BST {
    pub fn search(&self, target: i32) -> bool {
        Self::search_recursive(&self.root, target)
    }
    
    fn search_recursive(node: &Option<Box<TreeNode>>, target: i32) -> bool {
        match node {
            None => false,
            Some(n) => {
                if target == n.val {
                    true
                } else if target < n.val {
                    Self::search_recursive(&n.left, target)
                } else {
                    Self::search_recursive(&n.right, target)
                }
            }
        }
    }
}
```

## ‚ûï 4. Thao t√°c Insertion (Ch√®n)

### Quy tr√¨nh Insertion

<div className="bg-green-50 border border-green-200 rounded-lg p-4 my-4">
  <h4 className="text-green-800 font-semibold">Quy t·∫Øc ch√®n:</h4>
  <ol className="text-green-700 mt-2">
    <li><strong>B∆∞·ªõc 1:</strong> B·∫Øt ƒë·∫ßu t·ª´ root</li>
    <li><strong>B∆∞·ªõc 2:</strong> So s√°nh gi√° tr·ªã c·∫ßn ch√®n</li>
    <li><strong>B∆∞·ªõc 3:</strong> ƒêi tr√°i n·∫øu nh·ªè h∆°n, ph·∫£i n·∫øu l·ªõn h∆°n</li>
    <li><strong>B∆∞·ªõc 4:</strong> Ch√®n v√†o v·ªã tr√≠ null ƒë·∫ßu ti√™n</li>
  </ol>
</div>

```mermaid
graph TD
    subgraph "Insertion Process"
        A1[Insert 45] --> B1[Start at 50]
        B1 --> C1[45 < 50: Go Left]
        C1 --> D1[45 > 30: Go Right]
        D1 --> E1[45 > 40: Go Right]
        E1 --> F1[Insert at null position]
    end
```

### C√†i ƒë·∫∑t Insertion

```rust
impl BST {
    pub fn insert(&mut self, val: i32) {
        self.root = Self::insert_recursive(self.root.take(), val);
    }
    
    fn insert_recursive(node: Option<Box<TreeNode>>, val: i32) -> Option<Box<TreeNode>> {
        match node {
            None => Some(Box::new(TreeNode::new(val))),
            Some(mut n) => {
                if val < n.val {
                    n.left = Self::insert_recursive(n.left.take(), val);
                } else if val > n.val {
                    n.right = Self::insert_recursive(n.right.take(), val);
                }
                // Kh√¥ng ch√®n n·∫øu gi√° tr·ªã ƒë√£ t·ªìn t·∫°i
                Some(n)
            }
        }
    }
}
```

## ‚ùå 5. Thao t√°c Deletion (X√≥a)

### Ba tr∆∞·ªùng h·ª£p khi x√≥a node

| Tr∆∞·ªùng h·ª£p | M√¥ t·∫£ | C√°ch x·ª≠ l√Ω |
|------------|-------|------------|
| **Case 1** | Node kh√¥ng c√≥ con | X√≥a tr·ª±c ti·∫øp |
| **Case 2** | Node c√≥ 1 con | Thay th·∫ø b·∫±ng con duy nh·∫•t |
| **Case 3** | Node c√≥ 2 con | Thay th·∫ø b·∫±ng successor ho·∫∑c predecessor |

### Minh h·ªça 3 tr∆∞·ªùng h·ª£p deletion

```mermaid
graph LR
    subgraph "Case 1: No Children"
        A1[20] --> B1[NULL]
        A1 --> C1[NULL]
    end
    
    subgraph "Case 2: One Child"
        A2[30] --> B2[25]
        A2 --> C2[NULL]
    end
    
    subgraph "Case 3: Two Children"
        A3[50] --> B3[30]
        A3 --> C3[70]
        B3 --> D3[20]
        B3 --> E3[40]
    end
```

### C√†i ƒë·∫∑t Deletion

```rust
impl BST {
    pub fn delete(&mut self, val: i32) {
        self.root = Self::delete_recursive(self.root.take(), val);
    }
    
    fn delete_recursive(node: Option<Box<TreeNode>>, val: i32) -> Option<Box<TreeNode>> {
        match node {
            None => None,
            Some(mut n) => {
                if val < n.val {
                    n.left = Self::delete_recursive(n.left.take(), val);
                    Some(n)
                } else if val > n.val {
                    n.right = Self::delete_recursive(n.right.take(), val);
                    Some(n)
                } else {
                    // Node c·∫ßn x√≥a ƒë∆∞·ª£c t√¨m th·∫•y
                    match (n.left.take(), n.right.take()) {
                        // Case 1: Kh√¥ng c√≥ con
                        (None, None) => None,
                        // Case 2: C√≥ 1 con
                        (Some(left), None) => Some(left),
                        (None, Some(right)) => Some(right),
                        // Case 3: C√≥ 2 con
                        (Some(left), Some(right)) => {
                            // T√¨m successor (gi√° tr·ªã nh·ªè nh·∫•t ·ªü c√¢y con ph·∫£i)
                            let min_val = Self::find_min(&right);
                            let mut new_node = TreeNode::new(min_val);
                            new_node.left = Some(left);
                            new_node.right = Self::delete_recursive(Some(right), min_val);
                            Some(Box::new(new_node))
                        }
                    }
                }
            }
        }
    }
    
    fn find_min(node: &Box<TreeNode>) -> i32 {
        match &node.left {
            None => node.val,
            Some(left) => Self::find_min(left),
        }
    }
}
```

## üöÄ 6. C√°c thao t√°c b·ªï sung

### Validate BST

```rust
impl BST {
    pub fn is_valid_bst(&self) -> bool {
        Self::validate(&self.root, i32::MIN, i32::MAX)
    }
    
    fn validate(node: &Option<Box<TreeNode>>, min: i32, max: i32) -> bool {
        match node {
            None => true,
            Some(n) => {
                n.val > min && n.val < max
                    && Self::validate(&n.left, min, n.val)
                    && Self::validate(&n.right, n.val, max)
            }
        }
    }
}
```

### T√¨m Min/Max

```rust
impl BST {
    pub fn find_min(&self) -> Option<i32> {
        Self::find_min_node(&self.root)
    }
    
    pub fn find_max(&self) -> Option<i32> {
        Self::find_max_node(&self.root)
    }
    
    fn find_min_node(node: &Option<Box<TreeNode>>) -> Option<i32> {
        match node {
            None => None,
            Some(n) => match &n.left {
                None => Some(n.val),
                Some(_) => Self::find_min_node(&n.left),
            }
        }
    }
    
    fn find_max_node(node: &Option<Box<TreeNode>>) -> Option<i32> {
        match node {
            None => None,
            Some(n) => match &n.right {
                None => Some(n.val),
                Some(_) => Self::find_max_node(&n.right),
            }
        }
    }
}
```

## üìä 7. Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

<div className="overflow-x-auto">
  <table className="min-w-full border border-gray-300">
    <thead className="bg-gray-50">
      <tr>
        <th className="border border-gray-300 px-4 py-2">Thao t√°c</th>
        <th className="border border-gray-300 px-4 py-2">Best Case</th>
        <th className="border border-gray-300 px-4 py-2">Average Case</th>
        <th className="border border-gray-300 px-4 py-2">Worst Case</th>
        <th className="border border-gray-300 px-4 py-2">Space</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="border border-gray-300 px-4 py-2 font-semibold">Search</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2 text-red-600">O(n)</td>
        <td className="border border-gray-300 px-4 py-2">O(1)</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-4 py-2 font-semibold">Insert</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2 text-red-600">O(n)</td>
        <td className="border border-gray-300 px-4 py-2">O(1)</td>
      </tr>
      <tr>
        <td className="border border-gray-300 px-4 py-2 font-semibold">Delete</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2">O(log n)</td>
        <td className="border border-gray-300 px-4 py-2 text-red-600">O(n)</td>
        <td className="border border-gray-300 px-4 py-2">O(1)</td>
      </tr>
    </tbody>
  </table>
</div>

### Tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t (Degenerate Tree)

```mermaid
graph TD
    A[1] --> B[NULL]
    A --> C[2]
    C --> D[NULL]
    C --> E[3]
    E --> F[NULL]
    E --> G[4]
    G --> H[NULL]
    G --> I[5]
    
    style A fill:#ffebee
    style C fill:#ffebee
    style E fill:#ffebee
    style G fill:#ffebee
    style I fill:#ffebee
```

<div className="bg-red-50 border border-red-200 rounded-lg p-4 my-4">
  <p className="text-red-800"><strong>‚ö†Ô∏è L∆∞u √Ω:</strong> BST c√≥ th·ªÉ tho√°i h√≥a th√†nh danh s√°ch li√™n k·∫øt n·∫øu d·ªØ li·ªáu ƒë∆∞·ª£c ch√®n theo th·ª© t·ª± tƒÉng d·∫ßn ho·∫∑c gi·∫£m d·∫ßn, d·∫´n ƒë·∫øn complexity O(n).</p>
</div>

## üõ†Ô∏è 8. V√≠ d·ª• s·ª≠ d·ª•ng ho√†n ch·ªânh

```rust
fn main() {
    let mut bst = BST::new();
    
    // Ch√®n d·ªØ li·ªáu
    let values = [50, 30, 70, 20, 40, 60, 80];
    for val in values.iter() {
        bst.insert(*val);
        println!("Inserted: {}", val);
    }
    
    // T√¨m ki·∫øm
    println!("Search 40: {}", bst.search(40)); // true
    println!("Search 25: {}", bst.search(25)); // false
    
    // T√¨m min/max
    println!("Min: {:?}", bst.find_min()); // Some(20)
    println!("Max: {:?}", bst.find_max()); // Some(80)
    
    // X√≥a node
    bst.delete(30);
    println!("After deleting 30:");
    println!("Search 30: {}", bst.search(30)); // false
    
    // Validate BST
    println!("Is valid BST: {}", bst.is_valid_bst()); // true
}
```

## üìù 9. B√†i t·∫≠p th·ª±c h√†nh tr√™n LeetCode

### B√†i t·∫≠p c∆° b·∫£n:
1. **[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)**
2. **[700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)**
3. **[701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)**
4. **[450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)**

### B√†i t·∫≠p n√¢ng cao:
5. **[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)**
6. **[235. Lowest Common Ancestor of a BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)**
7. **[108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)**
8. **[96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)**

## üéØ 10. T√≥m t·∫Øt

<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 my-4">
  <h4 className="text-blue-800 font-semibold mb-2">ƒêi·ªÉm quan tr·ªçng c·∫ßn nh·ªõ:</h4>
  <ul className="text-blue-700 space-y-1">
    <li>üî∏ BST property: tr√°i nh·ªè h∆°n, ph·∫£i l·ªõn h∆°n</li>
    <li>üî∏ In-order traversal cho k·∫øt qu·∫£ sorted</li>
    <li>üî∏ Average case O(log n), worst case O(n)</li>
    <li>üî∏ Deletion c√≥ 3 tr∆∞·ªùng h·ª£p c·∫ßn x·ª≠ l√Ω</li>
    <li>üî∏ C·∫ßn c√¢n b·∫±ng ƒë·ªÉ tr√°nh degenerate tree</li>
  </ul>
</div>

**B√†i ti·∫øp theo:** Ch√∫ng ta s·∫Ω h·ªçc v·ªÅ **AVL Trees** - c√°ch c√¢n b·∫±ng BST ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªáu su·∫•t O(log n) trong m·ªçi tr∆∞·ªùng h·ª£p!