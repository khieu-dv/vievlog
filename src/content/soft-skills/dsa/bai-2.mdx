# B√†i 2: Introduction to Data Structures
## Gi·ªõi thi·ªáu v·ªÅ C·∫•u tr√∫c D·ªØ li·ªáu

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
  <h3 className="text-lg font-semibold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h3>
  <ul className="text-blue-700">
    <li>‚úÖ Hi·ªÉu ƒë·ªãnh nghƒ©a v√† t·∫ßm quan tr·ªçng c·ªßa Data Structure</li>
    <li>‚úÖ Ph√¢n lo·∫°i c√°c lo·∫°i Data Structure c∆° b·∫£n</li>
    <li>‚úÖ So s√°nh ∆∞u nh∆∞·ª£c ƒëi·ªÉm c·ªßa t·ª´ng lo·∫°i</li>
    <li>‚úÖ Hi·ªÉu m·ªëi quan h·ªá gi·ªØa Data Structure v√† hi·ªáu su·∫•t</li>
    <li>‚úÖ Th·ª±c h√†nh ph√¢n t√≠ch b√†i to√°n ƒë·ªÉ ch·ªçn c·∫•u tr√∫c ph√π h·ª£p</li>
  </ul>
</div>

## 1. Data Structure l√† g√¨?

**Data Structure (C·∫•u tr√∫c D·ªØ li·ªáu)** l√† c√°ch t·ªï ch·ª©c v√† l∆∞u tr·ªØ d·ªØ li·ªáu trong m√°y t√≠nh sao cho c√≥ th·ªÉ s·ª≠ d·ª•ng hi·ªáu qu·∫£. N√≥ ƒë·ªãnh nghƒ©a m·ªëi quan h·ªá gi·ªØa c√°c d·ªØ li·ªáu v√† c√°c operations c√≥ th·ªÉ th·ª±c hi·ªán tr√™n ch√∫ng.

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
  <h4 className="text-green-800 font-semibold mb-2">üí° T·∫°i sao Data Structure quan tr·ªçng?</h4>
  <div className="text-green-700">
    <p><strong>1. T·ªëi ∆∞u h√≥a hi·ªáu su·∫•t:</strong> Ch·ªçn ƒë√∫ng c·∫•u tr√∫c d·ªØ li·ªáu c√≥ th·ªÉ gi·∫£m th·ªùi gian x·ª≠ l√Ω t·ª´ O(n¬≤) xu·ªëng O(log n)</p>
    <p><strong>2. Qu·∫£n l√Ω b·ªô nh·ªõ:</strong> S·ª≠ d·ª•ng b·ªô nh·ªõ hi·ªáu qu·∫£ h∆°n</p>
    <p><strong>3. Gi·∫£i quy·∫øt b√†i to√°n:</strong> M·ªói c·∫•u tr√∫c ph√π h·ª£p v·ªõi t·ª´ng lo·∫°i b√†i to√°n c·ª• th·ªÉ</p>
  </div>
</div>

## 2. Ph√¢n lo·∫°i Data Structures

```mermaid
graph TD
    A[Data Structures] --> B[Primitive]
    A --> C[Non-Primitive]
    
    B --> D[Integer]
    B --> E[Float]
    B --> F[Character]
    B --> G[Boolean]
    
    C --> H[Linear]
    C --> I[Non-Linear]
    
    H --> J[Static<br/>Array]
    H --> K[Dynamic<br/>Linked List<br/>Stack<br/>Queue]
    
    I --> L[Tree<br/>Binary Tree<br/>BST<br/>AVL]
    I --> M[Graph<br/>Directed<br/>Undirected]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style H fill:#e8f5e8
    style I fill:#fff3e0
```

### 2.1 Primitive Data Types

| Lo·∫°i | K√≠ch th∆∞·ªõc | Ph·∫°m vi gi√° tr·ªã | Rust Example |
|------|------------|-----------------|-------------|
| `bool` | 1 byte | true, false | `let flag: bool = true;` |
| `i32` | 4 bytes | -2¬≥¬π to 2¬≥¬π-1 | `let num: i32 = 42;` |
| `f64` | 8 bytes | IEEE 754 double | `let pi: f64 = 3.14159;` |
| `char` | 4 bytes | Unicode scalar | `let letter: char = 'A';` |

### 2.2 Linear Data Structures

<div className="overflow-x-auto mb-6">

| Structure | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm | Complexity | Use Cases |
|-----------|---------|------------|------------|-----------|
| **Array** | Random access O(1)<br/>Memory efficient | Fixed size<br/>Insert/Delete expensive | Access: O(1)<br/>Insert: O(n) | Database records<br/>Mathematical operations |
| **Linked List** | Dynamic size<br/>Easy insert/delete | Sequential access<br/>Extra memory overhead | Access: O(n)<br/>Insert: O(1) | Implementation of stacks<br/>Undo functionality |
| **Stack** | LIFO operations<br/>Simple implementation | Limited access pattern<br/>Only top element | Push/Pop: O(1)<br/>Search: O(n) | Function calls<br/>Expression parsing |
| **Queue** | FIFO operations<br/>Fair scheduling | Limited access pattern<br/>Only front/rear | Enqueue/Dequeue: O(1)<br/>Search: O(n) | Task scheduling<br/>BFS algorithm |

</div>

### 2.3 Non-Linear Data Structures

```mermaid
graph TB
    subgraph "Tree Structure"
        T1[Root] --> T2[Left Child]
        T1 --> T3[Right Child]
        T2 --> T4[Leaf]
        T2 --> T5[Leaf]
        T3 --> T6[Leaf]
    end
    
    subgraph "Graph Structure"
        G1[Node A] --- G2[Node B]
        G1 --- G3[Node C]
        G2 --- G4[Node D]
        G3 --- G4
        G4 --- G5[Node E]
    end
```

| Structure | ƒê·∫∑c ƒëi·ªÉm | Complexity | Applications |
|-----------|----------|------------|--------------|
| **Tree** | Hierarchical structure<br/>No cycles | Search: O(log n) - O(n)<br/>Insert: O(log n) - O(n) | File systems<br/>Decision trees<br/>Database indexing |
| **Graph** | Network of nodes<br/>Can have cycles | Varies by algorithm<br/>DFS/BFS: O(V + E) | Social networks<br/>Route planning<br/>Web crawling |

## 3. C√°ch ch·ªçn Data Structure ph√π h·ª£p

### 3.1 Decision Tree cho vi·ªác ch·ªçn Data Structure

```mermaid
flowchart TD
    A[B·∫Øt ƒë·∫ßu ph√¢n t√≠ch b√†i to√°n] --> B{C·∫ßn truy c·∫≠p ng·∫´u nhi√™n?}
    B -->|C√≥| C[Array/Vector]
    B -->|Kh√¥ng| D{C·∫ßn LIFO?}
    D -->|C√≥| E[Stack]
    D -->|Kh√¥ng| F{C·∫ßn FIFO?}
    F -->|C√≥| G[Queue]
    F -->|Kh√¥ng| H{C·∫ßn t√¨m ki·∫øm nhanh?}
    H -->|C√≥| I[Hash Table]
    H -->|Kh√¥ng| J{C√≥ c·∫•u tr√∫c ph√¢n c·∫•p?}
    J -->|C√≥| K[Tree]
    J -->|Kh√¥ng| L[Linked List]
    
    style A fill:#ffeb3b
    style C fill:#4caf50
    style E fill:#ff9800
    style G fill:#2196f3
    style I fill:#9c27b0
    style K fill:#f44336
    style L fill:#795548
```

### 3.2 Performance Comparison

<div className="overflow-x-auto mb-6">

| Operation | Array | Linked List | Stack | Queue | Hash Table | BST |
|-----------|-------|-------------|-------|-------|------------|-----|
| **Access** | O(1) | O(n) | O(1)* | O(1)* | O(1) avg | O(log n) |
| **Search** | O(n) | O(n) | O(n) | O(n) | O(1) avg | O(log n) |
| **Insert** | O(n) | O(1)** | O(1) | O(1) | O(1) avg | O(log n) |
| **Delete** | O(n) | O(1)** | O(1) | O(1) | O(1) avg | O(log n) |

</div>

<div className="text-sm text-gray-600 mb-4">
<em>* Ch·ªâ access ph·∫ßn t·ª≠ top/front<br/>
** Khi c√≥ reference ƒë·∫øn node</em>
</div>

## 4. V√≠ d·ª• th·ª±c t·∫ø v·ªõi Rust

### 4.1 So s√°nh hi·ªáu su·∫•t Array vs LinkedList

```rust
use std::time::Instant;
use std::collections::LinkedList;

fn main() {
    const SIZE: usize = 100_000;
    
    // Array (Vec) performance
    let start = Instant::now();
    let mut vec = Vec::with_capacity(SIZE);
    for i in 0..SIZE {
        vec.push(i);
    }
    let vec_time = start.elapsed();
    
    // LinkedList performance
    let start = Instant::now();
    let mut list = LinkedList::new();
    for i in 0..SIZE {
        list.push_back(i);
    }
    let list_time = start.elapsed();
    
    println!("Vec creation: {:?}", vec_time);
    println!("LinkedList creation: {:?}", list_time);
    
    // Random access test
    let start = Instant::now();
    let _val = vec[SIZE/2];  // O(1)
    let vec_access = start.elapsed();
    
    let start = Instant::now();
    let _val = list.iter().nth(SIZE/2);  // O(n)
    let list_access = start.elapsed();
    
    println!("Vec access: {:?}", vec_access);
    println!("LinkedList access: {:?}", list_access);
}
```

### 4.2 V√≠ d·ª• ch·ªçn c·∫•u tr√∫c ph√π h·ª£p

```rust
// V√≠ d·ª• 1: L·ªãch s·ª≠ tr√¨nh duy·ªát - Stack
struct BrowserHistory {
    history: Vec<String>,
    current: i32,
}

impl BrowserHistory {
    fn new() -> Self {
        BrowserHistory {
            history: Vec::new(),
            current: -1,
        }
    }
    
    fn visit(&mut self, url: String) {
        // Remove forward history
        self.history.truncate((self.current + 1) as usize);
        self.history.push(url);
        self.current += 1;
    }
    
    fn back(&mut self) -> Option<&String> {
        if self.current > 0 {
            self.current -= 1;
            Some(&self.history[self.current as usize])
        } else {
            None
        }
    }
}

// V√≠ d·ª• 2: Task Queue - Queue
use std::collections::VecDeque;

struct TaskScheduler {
    tasks: VecDeque<String>,
}

impl TaskScheduler {
    fn new() -> Self {
        TaskScheduler {
            tasks: VecDeque::new(),
        }
    }
    
    fn add_task(&mut self, task: String) {
        self.tasks.push_back(task);  // O(1)
    }
    
    fn process_next(&mut self) -> Option<String> {
        self.tasks.pop_front()  // O(1)
    }
}
```

## 5. B√†i t·∫≠p th·ª±c h√†nh

### 5.1 Ph√¢n t√≠ch v√† l·ª±a ch·ªçn

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4">
<h4 className="font-semibold text-yellow-800 mb-2">üìù B√†i t·∫≠p 1: Ph√¢n t√≠ch b√†i to√°n</h4>
<p className="text-yellow-700">Cho c√°c t√¨nh hu·ªëng sau, h√£y ch·ªçn Data Structure ph√π h·ª£p nh·∫•t v√† gi·∫£i th√≠ch l√Ω do:</p>

<ol className="text-yellow-700 mt-2">
<li><strong>a)</strong> L∆∞u tr·ªØ danh s√°ch sinh vi√™n trong l·ªõp, th∆∞·ªùng xuy√™n t√¨m ki·∫øm theo MSSV</li>
<li><strong>b)</strong> Implement ch·ª©c nƒÉng Undo/Redo trong text editor</li>
<li><strong>c)</strong> Qu·∫£n l√Ω h√†ng ƒë·ª£i in ·∫•n trong m√°y t√≠nh</li>
<li><strong>d)</strong> Bi·ªÉu di·ªÖn c·∫•u tr√∫c th∆∞ m·ª•c trong h·ªá ƒëi·ªÅu h√†nh</li>
<li><strong>e)</strong> L∆∞u tr·ªØ network c·ªßa ng∆∞·ªùi b·∫°n tr√™n m·∫°ng x√£ h·ªôi</li>
</ol>
</div>

### 5.2 Coding Exercise v·ªõi Rust

```rust
// B√†i t·∫≠p 2: Implement Simple Data Structure Manager
use std::collections::{HashMap, VecDeque};

struct DataManager {
    // Stack cho recent searches (LIFO)
    recent_searches: Vec<String>,      
    // Queue cho pending tasks (FIFO)  
    pending_tasks: VecDeque<String>,   
    // HashMap cho user scores (fast lookup)
    user_scores: HashMap<String, i32>, 
}

impl DataManager {
    fn new() -> Self {
        DataManager {
            recent_searches: Vec::new(),
            pending_tasks: VecDeque::new(),
            user_scores: HashMap::new(),
        }
    }
    
    // Stack operations cho search history
    fn add_search(&mut self, query: String) {
        // Gi·ªõi h·∫°n 10 searches g·∫ßn nh·∫•t
        if self.recent_searches.len() >= 10 {
            self.recent_searches.remove(0); // Remove oldest
        }
        self.recent_searches.push(query); // Add to top
    }
    
    fn get_last_search(&mut self) -> Option<String> {
        self.recent_searches.pop() // LIFO - Last In, First Out
    }
    
    // Queue operations cho task management
    fn add_task(&mut self, task: String) {
        self.pending_tasks.push_back(task); // Enqueue
    }
    
    fn process_next_task(&mut self) -> Option<String> {
        self.pending_tasks.pop_front() // Dequeue - FIFO
    }
    
    // HashMap operations cho user scores
    fn update_score(&mut self, user: String, score: i32) {
        self.user_scores.insert(user, score); // O(1) average
    }
    
    fn get_score(&self, user: &str) -> Option<&i32> {
        self.user_scores.get(user) // O(1) average lookup
    }
    
    // Utility functions
    fn search_count(&self) -> usize {
        self.recent_searches.len()
    }
    
    fn pending_task_count(&self) -> usize {
        self.pending_tasks.len()
    }
}

// Test function ƒë·ªÉ verify implementation
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_data_manager() {
        let mut dm = DataManager::new();
        
        // Test search history (Stack behavior)
        dm.add_search("rust programming".to_string());
        dm.add_search("data structures".to_string());
        
        assert_eq!(dm.get_last_search(), Some("data structures".to_string()));
        assert_eq!(dm.get_last_search(), Some("rust programming".to_string()));
        
        // Test task queue (Queue behavior)  
        dm.add_task("task1".to_string());
        dm.add_task("task2".to_string());
        
        assert_eq!(dm.process_next_task(), Some("task1".to_string()));
        assert_eq!(dm.process_next_task(), Some("task2".to_string()));
        
        // Test user scores (HashMap)
        dm.update_score("alice".to_string(), 95);
        dm.update_score("bob".to_string(), 87);
        
        assert_eq!(dm.get_score("alice"), Some(&95));
        assert_eq!(dm.get_score("charlie"), None);
    }
}
```

## 6. LeetCode Problems li√™n quan

<div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
<h4 className="font-semibold text-gray-800 mb-3">üèÜ B√†i t·∫≠p LeetCode li√™n quan ƒë·∫øn Data Structures</h4>

### üü¢ Easy Level:
| Problem | Difficulty | Concept | Link |
|---------|------------|---------|------|
| Two Sum | Easy | Hash Table | [Problem 1](https://leetcode.com/problems/two-sum/) |
| Valid Parentheses | Easy | Stack | [Problem 20](https://leetcode.com/problems/valid-parentheses/) |
| Implement Queue using Stacks | Easy | Stack & Queue | [Problem 232](https://leetcode.com/problems/implement-queue-using-stacks/) |
| Remove Duplicates from Sorted Array | Easy | Array | [Problem 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) |

### üü° Medium Level:
| Problem | Difficulty | Concept | Link |
|---------|------------|---------|------|
| LRU Cache | Medium | Hash + LinkedList | [Problem 146](https://leetcode.com/problems/lru-cache/) |
| Implement Stack using Queues | Medium | Queue & Stack | [Problem 225](https://leetcode.com/problems/implement-stack-using-queues/) |
| Design Circular Queue | Medium | Array-based Queue | [Problem 622](https://leetcode.com/problems/design-circular-queue/) |
| Top K Frequent Elements | Medium | Hash + Heap | [Problem 347](https://leetcode.com/problems/top-k-frequent-elements/) |

### üîç Pattern Recognition cho Data Structures:
- **Array problems:** Linear scan, two pointers, sliding window
- **Stack problems:** Matching patterns, monotonic stack, expression evaluation  
- **Queue problems:** Level-order processing, BFS traversal
- **Hash problems:** Frequency counting, fast lookups, caching
- **Linked List:** Two pointers, cycle detection, merging
</div>

## 7. T√≥m t·∫Øt v√† ƒêi·ªÉm c·∫ßn nh·ªõ

<div className="bg-indigo-50 border border-indigo-200 rounded-lg p-4 mt-6">
<h4 className="text-indigo-800 font-semibold mb-3">üéØ Key Takeaways</h4>

<div className="text-indigo-700 space-y-2">
<p><strong>1. Kh√¥ng c√≥ c·∫•u tr√∫c d·ªØ li·ªáu "t·ªët nh·∫•t":</strong> M·ªói c·∫•u tr√∫c c√≥ ∆∞u nh∆∞·ª£c ƒëi·ªÉm ri√™ng</p>
<p><strong>2. Ph√¢n t√≠ch b√†i to√°n tr∆∞·ªõc:</strong> Hi·ªÉu requirements v·ªÅ access pattern, frequency of operations</p>
<p><strong>3. Trade-offs:</strong> Time vs Space, Simplicity vs Performance</p>
<p><strong>4. Big-O Analysis:</strong> Lu√¥n c√¢n nh·∫Øc complexity c·ªßa c√°c operations ch√≠nh</p>
<p><strong>5. Real-world context:</strong> Consider memory constraints, concurrent access, data size</p>
</div>
</div>

---

<div className="text-center mt-8 p-4 bg-blue-100 rounded-lg">
<p className="text-blue-800 font-medium">üöÄ <strong>B√†i ti·∫øp theo:</strong> Arrays - C·∫•u tr√∫c d·ªØ li·ªáu ƒë·∫ßu ti√™n</p>
<p className="text-blue-600 text-sm mt-1">Ch√∫ng ta s·∫Ω ƒëi s√¢u v√†o implementation v√† optimization c·ªßa Arrays</p>
</div>