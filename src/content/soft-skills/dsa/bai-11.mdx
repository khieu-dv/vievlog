# B√†i 11: Heap Sort & Priority Queue

<div className="bg-gradient-to-r from-blue-50 to-purple-50 p-6 rounded-lg border-l-4 border-blue-500 mb-6">
  <h2 className="text-2xl font-bold text-gray-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <ul className="text-gray-700 space-y-2">
    <li>‚Ä¢ Hi·ªÉu c·∫•u tr√∫c d·ªØ li·ªáu Heap v√† t√≠nh ch·∫•t c·ªßa n√≥</li>
    <li>‚Ä¢ N·∫Øm v·ªØng c√°c thu·∫≠t to√°n heapify v√† heap operations</li>
    <li>‚Ä¢ C√†i ƒë·∫∑t thu·∫≠t to√°n Heap Sort ho√†n ch·ªânh</li>
    <li>‚Ä¢ X√¢y d·ª±ng Priority Queue s·ª≠ d·ª•ng heap</li>
    <li>‚Ä¢ √Åp d·ª•ng v√†o c√°c b√†i to√°n th·ª±c t·∫ø</li>
  </ul>
</div>

## 1. Gi·ªõi thi·ªáu v·ªÅ Heap

Heap l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y nh·ªã ph√¢n ho√†n ch·ªânh c√≥ t√≠nh ch·∫•t ƒë·∫∑c bi·ªát v·ªÅ th·ª© t·ª± c√°c ph·∫ßn t·ª≠.

### 1.1. ƒê·ªãnh nghƒ©a v√† T√≠nh ch·∫•t

| Thu·ªôc t√≠nh | Max-Heap | Min-Heap |
|------------|----------|----------|
| **T√≠nh ch·∫•t ch√≠nh** | Parent ‚â• Children | Parent ‚â§ Children |
| **Root element** | Ph·∫ßn t·ª≠ l·ªõn nh·∫•t | Ph·∫ßn t·ª≠ nh·ªè nh·∫•t |
| **·ª®ng d·ª•ng** | Heap Sort gi·∫£m d·∫ßn | Priority Queue |
| **Complexity insert** | O(log n) | O(log n) |
| **Complexity extract** | O(log n) | O(log n) |

### 1.2. Bi·ªÉu di·ªÖn Heap trong Array

```mermaid
graph TD
    A[16] --> B[14]
    A --> C[10]
    B --> D[8]
    B --> E[7]
    C --> F[9]
    C --> G[3]
    D --> H[2]
    D --> I[4]
    E --> J[1]
```

<div className="bg-gray-50 p-4 rounded-lg mt-4">
  <h4 className="font-semibold text-gray-800 mb-2">Array Representation:</h4>
  <div className="grid grid-cols-10 gap-2 text-center">
    <div className="bg-blue-100 p-2 rounded">Index</div>
    <div className="bg-blue-100 p-2 rounded">0</div>
    <div className="bg-blue-100 p-2 rounded">1</div>
    <div className="bg-blue-100 p-2 rounded">2</div>
    <div className="bg-blue-100 p-2 rounded">3</div>
    <div className="bg-blue-100 p-2 rounded">4</div>
    <div className="bg-blue-100 p-2 rounded">5</div>
    <div className="bg-blue-100 p-2 rounded">6</div>
    <div className="bg-blue-100 p-2 rounded">7</div>
    <div className="bg-blue-100 p-2 rounded">8</div>
    <div className="bg-yellow-100 p-2 rounded">Value</div>
    <div className="bg-yellow-100 p-2 rounded">16</div>
    <div className="bg-yellow-100 p-2 rounded">14</div>
    <div className="bg-yellow-100 p-2 rounded">10</div>
    <div className="bg-yellow-100 p-2 rounded">8</div>
    <div className="bg-yellow-100 p-2 rounded">7</div>
    <div className="bg-yellow-100 p-2 rounded">9</div>
    <div className="bg-yellow-100 p-2 rounded">3</div>
    <div className="bg-yellow-100 p-2 rounded">2</div>
    <div className="bg-yellow-100 p-2 rounded">4</div>
  </div>
</div>

### 1.3. C√¥ng th·ª©c quan h·ªá Parent-Child

| Quan h·ªá | C√¥ng th·ª©c |
|---------|-----------|
| **Parent c·ªßa node i** | `(i - 1) / 2` |
| **Left child c·ªßa node i** | `2 * i + 1` |
| **Right child c·ªßa node i** | `2 * i + 2` |

## 2. C√†i ƒë·∫∑t Heap b·∫±ng Rust

### 2.1. C·∫•u tr√∫c d·ªØ li·ªáu c∆° b·∫£n

```rust
pub struct MaxHeap {
    data: Vec<i32>,
}

impl MaxHeap {
    pub fn new() -> Self {
        MaxHeap {
            data: Vec::new(),
        }
    }
    
    pub fn with_capacity(capacity: usize) -> Self {
        MaxHeap {
            data: Vec::with_capacity(capacity),
        }
    }
    
    pub fn len(&self) -> usize {
        self.data.len()
    }
    
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
    
    // Helper functions
    fn parent_index(&self, index: usize) -> Option<usize> {
        if index == 0 { None } else { Some((index - 1) / 2) }
    }
    
    fn left_child_index(&self, index: usize) -> usize {
        2 * index + 1
    }
    
    fn right_child_index(&self, index: usize) -> usize {
        2 * index + 2
    }
}
```

### 2.2. Thu·∫≠t to√°n Heapify

#### Heapify Up (Bubble Up)
```rust
impl MaxHeap {
    fn heapify_up(&mut self, mut index: usize) {
        while let Some(parent_idx) = self.parent_index(index) {
            if self.data[index] <= self.data[parent_idx] {
                break;
            }
            self.data.swap(index, parent_idx);
            index = parent_idx;
        }
    }
}
```

#### Heapify Down (Bubble Down)
```rust
impl MaxHeap {
    fn heapify_down(&mut self, mut index: usize) {
        loop {
            let mut largest = index;
            let left = self.left_child_index(index);
            let right = self.right_child_index(index);
            
            // T√¨m ph·∫ßn t·ª≠ l·ªõn nh·∫•t trong 3 node: parent, left, right
            if left < self.len() && self.data[left] > self.data[largest] {
                largest = left;
            }
            
            if right < self.len() && self.data[right] > self.data[largest] {
                largest = right;
            }
            
            if largest == index {
                break;
            }
            
            self.data.swap(index, largest);
            index = largest;
        }
    }
}
```

### 2.3. Heap Operations

```rust
impl MaxHeap {
    // Ch√®n ph·∫ßn t·ª≠ m·ªõi
    pub fn push(&mut self, value: i32) {
        self.data.push(value);
        let last_index = self.len() - 1;
        self.heapify_up(last_index);
    }
    
    // L·∫•y ph·∫ßn t·ª≠ l·ªõn nh·∫•t (root)
    pub fn peek(&self) -> Option<&i32> {
        self.data.first()
    }
    
    // Lo·∫°i b·ªè v√† tr·∫£ v·ªÅ ph·∫ßn t·ª≠ l·ªõn nh·∫•t
    pub fn pop(&mut self) -> Option<i32> {
        if self.is_empty() {
            return None;
        }
        
        if self.len() == 1 {
            return self.data.pop();
        }
        
        let max = self.data[0];
        self.data[0] = self.data.pop().unwrap();
        self.heapify_down(0);
        Some(max)
    }
}
```

## 3. Heap Sort Algorithm

### 3.1. Quy tr√¨nh Heap Sort

```mermaid
graph TD
    A[Unsorted Array] --> B[Build Max Heap]
    B --> C[Extract Max to End]
    C --> D[Heapify Remaining]
    D --> E{More Elements?}
    E -->|Yes| C
    E -->|No| F[Sorted Array]
```

### 3.2. C√†i ƒë·∫∑t Heap Sort

```rust
pub fn heap_sort(arr: &mut [i32]) {
    let len = arr.len();
    if len <= 1 {
        return;
    }
    
    // B∆∞·ªõc 1: X√¢y d·ª±ng max heap
    build_max_heap(arr);
    
    // B∆∞·ªõc 2: Tr√≠ch xu·∫•t t·ª´ng ph·∫ßn t·ª≠
    for i in (1..len).rev() {
        arr.swap(0, i);  // Di chuy·ªÉn max v·ªÅ cu·ªëi
        heapify_down_range(arr, 0, i);  // Heapify ph·∫ßn c√≤n l·∫°i
    }
}

fn build_max_heap(arr: &mut [i32]) {
    let len = arr.len();
    // B·∫Øt ƒë·∫ßu t·ª´ node kh√¥ng ph·∫£i l√° cu·ªëi c√πng
    for i in (0..len/2).rev() {
        heapify_down_range(arr, i, len);
    }
}

fn heapify_down_range(arr: &mut [i32], mut index: usize, heap_size: usize) {
    loop {
        let mut largest = index;
        let left = 2 * index + 1;
        let right = 2 * index + 2;
        
        if left < heap_size && arr[left] > arr[largest] {
            largest = left;
        }
        
        if right < heap_size && arr[right] > arr[largest] {
            largest = right;
        }
        
        if largest == index {
            break;
        }
        
        arr.swap(index, largest);
        index = largest;
    }
}
```

### 3.3. Ph√¢n t√≠ch Complexity

| Thao t√°c | Time Complexity | Space Complexity |
|----------|-----------------|------------------|
| **Build Heap** | O(n) | O(1) |
| **Heapify Down** | O(log n) | O(1) |
| **Heap Sort** | O(n log n) | O(1) |
| **Best Case** | O(n log n) | O(1) |
| **Worst Case** | O(n log n) | O(1) |

## 4. Priority Queue v·ªõi Heap

### 4.1. Kh√°i ni·ªám Priority Queue

<div className="bg-green-50 p-4 rounded-lg border-l-4 border-green-500">
  <h4 className="font-semibold text-green-800">Priority Queue</h4>
  <p className="text-green-700">C·∫•u tr√∫c d·ªØ li·ªáu cho ph√©p th√™m ph·∫ßn t·ª≠ v√† l·∫•y ra ph·∫ßn t·ª≠ c√≥ ƒë·ªô ∆∞u ti√™n cao nh·∫•t.</p>
</div>

### 4.2. C√†i ƒë·∫∑t Priority Queue

```rust
use std::cmp::Ordering;

#[derive(Debug, Clone)]
pub struct PriorityItem<T> {
    pub priority: i32,
    pub data: T,
}

impl<T> PartialEq for PriorityItem<T> {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl<T> Eq for PriorityItem<T> {}

impl<T> PartialOrd for PriorityItem<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<T> Ord for PriorityItem<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.priority.cmp(&other.priority)
    }
}

pub struct PriorityQueue<T> {
    heap: Vec<PriorityItem<T>>,
}

impl<T> PriorityQueue<T> {
    pub fn new() -> Self {
        PriorityQueue {
            heap: Vec::new(),
        }
    }
    
    pub fn push(&mut self, priority: i32, data: T) {
        let item = PriorityItem { priority, data };
        self.heap.push(item);
        self.bubble_up(self.heap.len() - 1);
    }
    
    pub fn pop(&mut self) -> Option<PriorityItem<T>> {
        if self.heap.is_empty() {
            return None;
        }
        
        if self.heap.len() == 1 {
            return self.heap.pop();
        }
        
        let result = self.heap.swap_remove(0);
        self.bubble_down(0);
        Some(result)
    }
    
    pub fn peek(&self) -> Option<&PriorityItem<T>> {
        self.heap.first()
    }
    
    pub fn len(&self) -> usize {
        self.heap.len()
    }
    
    pub fn is_empty(&self) -> bool {
        self.heap.is_empty()
    }
}
```

## 5. ·ª®ng d·ª•ng th·ª±c t·∫ø

### 5.1. So s√°nh thu·∫≠t to√°n s·∫Øp x·∫øp

| Algorithm | Time Complexity | Space | Stable | In-place |
|-----------|----------------|--------|---------|----------|
| **Heap Sort** | O(n log n) | O(1) | No | Yes |
| **Merge Sort** | O(n log n) | O(n) | Yes | No |
| **Quick Sort** | O(n log n)* | O(log n) | No | Yes |
| **Bubble Sort** | O(n¬≤) | O(1) | Yes | Yes |

*Average case, worst case O(n¬≤)

### 5.2. Khi n√†o s·ª≠ d·ª•ng Heap Sort?

<div className="grid grid-cols-1 md:grid-cols-2 gap-4">
  <div className="bg-blue-50 p-4 rounded-lg">
    <h4 className="font-semibold text-blue-800 mb-2">‚úÖ ∆Øu ƒëi·ªÉm</h4>
    <ul className="text-blue-700 space-y-1">
      <li>‚Ä¢ Complexity ·ªïn ƒë·ªãnh O(n log n)</li>
      <li>‚Ä¢ In-place sorting (O(1) space)</li>
      <li>‚Ä¢ Kh√¥ng c√≥ worst case nh∆∞ Quick Sort</li>
      <li>‚Ä¢ T·ªët cho embedded systems</li>
    </ul>
  </div>
  <div className="bg-red-50 p-4 rounded-lg">
    <h4 className="font-semibold text-red-800 mb-2">‚ùå Nh∆∞·ª£c ƒëi·ªÉm</h4>
    <ul className="text-red-700 space-y-1">
      <li>‚Ä¢ Kh√¥ng stable</li>
      <li>‚Ä¢ Cache performance k√©m</li>
      <li>‚Ä¢ Ch·∫≠m h∆°n Quick Sort trung b√¨nh</li>
      <li>‚Ä¢ Implementation ph·ª©c t·∫°p</li>
    </ul>
  </div>
</div>

## 6. B√†i t·∫≠p th·ª±c h√†nh

### 6.1. B√†i t·∫≠p c∆° b·∫£n

```rust
fn main() {
    // Test heap operations
    let mut heap = MaxHeap::new();
    let numbers = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];
    
    // Insert all numbers
    for num in numbers {
        heap.push(num);
        println!("Inserted {}, heap top: {:?}", num, heap.peek());
    }
    
    // Extract all numbers
    while !heap.is_empty() {
        println!("Extracted: {:?}", heap.pop());
    }
    
    // Test heap sort
    let mut arr = vec![64, 34, 25, 12, 22, 11, 90];
    println!("Original: {:?}", arr);
    heap_sort(&mut arr);
    println!("Sorted: {:?}", arr);
}
```

### 6.2. LeetCode Problems

| Problem | Difficulty | Topic |
|---------|------------|-------|
| [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) | Medium | Heap |
| [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | Hard | Priority Queue |
| [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | Medium | Heap |
| [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | Hard | Two Heaps |
| [703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | Easy | Min Heap |
| [973. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/) | Medium | Heap |
| [1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight/) | Easy | Max Heap |

<div className="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-500 mt-6">
  <h4 className="font-semibold text-yellow-800 mb-2">üí° M·∫πo gi·∫£i b√†i t·∫≠p</h4>
  <ul className="text-yellow-700 space-y-1">
    <li>‚Ä¢ S·ª≠ d·ª•ng Min Heap khi c·∫ßn t√¨m K largest elements</li>
    <li>‚Ä¢ S·ª≠ d·ª•ng Max Heap khi c·∫ßn t√¨m K smallest elements</li>
    <li>‚Ä¢ Two heaps technique cho median problems</li>
    <li>‚Ä¢ Priority Queue cho scheduling problems</li>
  </ul>
</div>

## 7. T√≥m t·∫Øt

### 7.1. Key Takeaways

- **Heap** l√† c·∫•u tr√∫c c√¢y nh·ªã ph√¢n ho√†n ch·ªânh v·ªõi t√≠nh ch·∫•t th·ª© t·ª± ƒë·∫∑c bi·ªát
- **Heap Sort** c√≥ complexity O(n log n) ·ªïn ƒë·ªãnh v√† s·∫Øp x·∫øp in-place  
- **Priority Queue** ƒë∆∞·ª£c implement hi·ªáu qu·∫£ b·∫±ng heap
- **Applications**: Dijkstra's algorithm, task scheduling, top-K problems

### 7.2. Next Steps

Trong b√†i ti·∫øp theo, ch√∫ng ta s·∫Ω h·ªçc v·ªÅ **Searching Algorithms** ƒë·ªÉ ho√†n th√†nh ph·∫ßn thu·∫≠t to√°n s·∫Øp x·∫øp v√† t√¨m ki·∫øm c∆° b·∫£n.

---

<div className="text-center mt-6 p-4 bg-gray-50 rounded-lg">
  <p className="text-gray-600">üöÄ <strong>Th√†nh th·∫°o Heap Sort l√† b∆∞·ªõc quan tr·ªçng ƒë·ªÉ hi·ªÉu c√°c thu·∫≠t to√°n graph ph·ª©c t·∫°p!</strong></p>
</div>