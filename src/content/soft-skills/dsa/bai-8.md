# BÃ i 8: Big-O, Big-Î¸, Big-Î© Notation - KÃ½ hiá»‡u tiá»‡m cáº­n

<div className="border-l-4 border-blue-400 p-4 mb-6">
<h2 className="text-xl font-bold text-blue-800 mb-2">ğŸ¯ Má»¥c tiÃªu há»c táº­p</h2>
<ul className="text-blue-700">
<li>Hiá»ƒu sÃ¢u vá» cÃ¡c kÃ½ hiá»‡u tiá»‡m cáº­n Big-O, Big-Î¸, Big-Î©</li>
<li>PhÃ¢n biá»‡t worst-case, average-case, best-case</li>
<li>Thá»±c hÃ nh viáº¿t mathematical proof cho Big-O</li>
<li>PhÃ¢n tÃ­ch space complexity cá»§a cÃ¡c data structure</li>
</ul>
</div>

## 1. Tá»•ng quan vá» Asymptotic Notation

### 1.1 KhÃ¡i niá»‡m cÆ¡ báº£n

**Asymptotic Notation** lÃ  há»‡ thá»‘ng kÃ½ hiá»‡u toÃ¡n há»c dÃ¹ng Ä‘á»ƒ mÃ´ táº£ hÃ nh vi cá»§a má»™t hÃ m khi Ä‘áº§u vÃ o tiáº¿n Ä‘áº¿n vÃ´ cÃ¹ng. Trong Computer Science, chÃºng ta sá»­ dá»¥ng Ä‘á»ƒ phÃ¢n tÃ­ch hiá»‡u suáº¥t thuáº­t toÃ¡n.

```mermaid
graph LR
    A[Input Size n] --> B[Algorithm]
    B --> C[Time/Space Usage]
    C --> D[Asymptotic Analysis]
    D --> E[Big-O Notation]
```

### 1.2 Táº¡i sao cáº§n Asymptotic Analysis?

<div className="border border-yellow-200 p-4 rounded mb-4">
<p className="font-semibold text-yellow-800">ğŸ’¡ LÃ½ do quan trá»ng:</p>
<ul className="text-yellow-700 mt-2">
<li>Äá»™c láº­p vá»›i pháº§n cá»©ng vÃ  ngÃ´n ngá»¯ láº­p trÃ¬nh</li>
<li>Táº­p trung vÃ o growth rate cá»§a thuáº­t toÃ¡n</li>
<li>GiÃºp so sÃ¡nh thuáº­t toÃ¡n má»™t cÃ¡ch khÃ¡ch quan</li>
<li>Dá»± Ä‘oÃ¡n hiá»‡u suáº¥t vá»›i input lá»›n</li>
</ul>
</div>

## 2. Ba loáº¡i Asymptotic Notation

### 2.1 Big-O Notation (ÎŸ) - Upper Bound

**Äá»‹nh nghÄ©a toÃ¡n há»c:**
f(n) = O(g(n)) náº¿u tá»“n táº¡i cÃ¡c háº±ng sá»‘ dÆ°Æ¡ng c vÃ  nâ‚€ sao cho:
**0 â‰¤ f(n) â‰¤ cÂ·g(n)** vá»›i má»i n â‰¥ nâ‚€

| Ã nghÄ©a           | MÃ´ táº£                                     |
| ----------------- | ----------------------------------------- |
| **Upper Bound**   | Giá»›i háº¡n trÃªn cá»§a growth rate             |
| **Worst Case**    | ThÆ°á»ng dÃ¹ng Ä‘á»ƒ mÃ´ táº£ trÆ°á»ng há»£p xáº¥u nháº¥t  |
| **Practical Use** | Äáº£m báº£o thuáº­t toÃ¡n khÃ´ng cháº­m hÆ¡n má»©c nÃ y |

### 2.2 Big-Î© Notation (Î©) - Lower Bound

**Äá»‹nh nghÄ©a toÃ¡n há»c:**
f(n) = Î©(g(n)) náº¿u tá»“n táº¡i cÃ¡c háº±ng sá»‘ dÆ°Æ¡ng c vÃ  nâ‚€ sao cho:
**0 â‰¤ cÂ·g(n) â‰¤ f(n)** vá»›i má»i n â‰¥ nâ‚€

| Ã nghÄ©a             | MÃ´ táº£                                             |
| ------------------- | ------------------------------------------------- |
| **Lower Bound**     | Giá»›i háº¡n dÆ°á»›i cá»§a growth rate                     |
| **Best Case**       | ThÆ°á»ng dÃ¹ng Ä‘á»ƒ mÃ´ táº£ trÆ°á»ng há»£p tá»‘t nháº¥t          |
| **Theoretical Use** | Chá»©ng minh thuáº­t toÃ¡n khÃ´ng thá»ƒ nhanh hÆ¡n má»©c nÃ y |

### 2.3 Big-Î¸ Notation (Î˜) - Tight Bound

**Äá»‹nh nghÄ©a toÃ¡n há»c:**
f(n) = Î˜(g(n)) náº¿u tá»“n táº¡i cÃ¡c háº±ng sá»‘ dÆ°Æ¡ng câ‚, câ‚‚ vÃ  nâ‚€ sao cho:
**0 â‰¤ câ‚Â·g(n) â‰¤ f(n) â‰¤ câ‚‚Â·g(n)** vá»›i má»i n â‰¥ nâ‚€

| Ã nghÄ©a              | MÃ´ táº£                                  |
| -------------------- | -------------------------------------- |
| **Tight Bound**      | Giá»›i háº¡n cháº·t cháº½ cá»§a growth rate      |
| **Average Case**     | f(n) = O(g(n)) VÃ€ f(n) = Î©(g(n))       |
| **Precise Analysis** | MÃ´ táº£ chÃ­nh xÃ¡c hÃ nh vi cá»§a thuáº­t toÃ¡n |

```mermaid
graph TB
    A["f(n) = Theta(g(n))"] --> B["f(n) = O(g(n))"]
    A --> C["f(n) = Omega(g(n))"]
    B --> D["Upper Bound: f(n) <= c2*g(n)"]
    C --> E["Lower Bound: c1*g(n) <= f(n)"]
```

## 3. So sÃ¡nh cÃ¡c Case Analysis

### 3.1 Báº£ng so sÃ¡nh Best, Average, Worst Case

| Algorithm         | Best Case  | Average Case | Worst Case |
| ----------------- | ---------- | ------------ | ---------- |
| **Linear Search** | Î©(1)       | Î˜(n)         | O(n)       |
| **Binary Search** | Î©(1)       | Î˜(log n)     | O(log n)   |
| **Bubble Sort**   | Î©(n)       | Î˜(nÂ²)        | O(nÂ²)      |
| **Quick Sort**    | Î©(n log n) | Î˜(n log n)   | O(nÂ²)      |
| **Merge Sort**    | Î˜(n log n) | Î˜(n log n)   | Î˜(n log n) |

### 3.2 VÃ­ dá»¥ thá»±c táº¿: Linear Search

```cpp
// Linear Search Analysis
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // Found at position i
        }
    }
    return -1;  // Not found
}
```

<div className="border border-green-200 p-4 rounded">
<h4 className="font-bold text-green-800">ğŸ“Š Case Analysis:</h4>
<ul className="text-green-700 mt-2">
<li><strong>Best Case (Î©(1)):</strong> Element á»Ÿ vá»‹ trÃ­ Ä‘áº§u tiÃªn</li>
<li><strong>Average Case (Î˜(n)):</strong> Element á»Ÿ giá»¯a máº£ng</li>
<li><strong>Worst Case (O(n)):</strong> Element á»Ÿ cuá»‘i hoáº·c khÃ´ng cÃ³</li>
</ul>
</div>

## 4. Mathematical Proof Techniques

### 4.1 Chá»©ng minh Big-O

**VÃ­ dá»¥:** Chá»©ng minh 3nÂ² + 5n + 2 = O(nÂ²)

**BÆ°á»›c 1:** TÃ¬m háº±ng sá»‘ c vÃ  nâ‚€
**BÆ°á»›c 2:** Chá»©ng minh 3nÂ² + 5n + 2 â‰¤ cÂ·nÂ² vá»›i n â‰¥ nâ‚€

```cpp
// Proof process:
// 3nÂ² + 5n + 2 â‰¤ cÂ·nÂ²
// Vá»›i n â‰¥ 1: 5n â‰¤ 5nÂ², 2 â‰¤ 2nÂ²
// Do Ä‘Ã³: 3nÂ² + 5n + 2 â‰¤ 3nÂ² + 5nÂ² + 2nÂ² = 10nÂ²
// Chá»n c = 10, nâ‚€ = 1
```

### 4.2 Báº£ng cÃ¡c bÆ°á»›c chá»©ng minh chuáº©n

| BÆ°á»›c            | MÃ´ táº£                     | VÃ­ dá»¥                     |
| --------------- | ------------------------- | ------------------------- |
| **1. Identify** | XÃ¡c Ä‘á»‹nh f(n) vÃ  g(n)     | f(n)=3nÂ²+5n+2, g(n)=nÂ²    |
| **2. Bound**    | Æ¯á»›c lÆ°á»£ng tá»«ng thÃ nh pháº§n | 5n â‰¤ 5nÂ², 2 â‰¤ 2nÂ² vá»›i nâ‰¥1 |
| **3. Combine**  | Káº¿t há»£p Ä‘á»ƒ cÃ³ cÂ·g(n)      | 3nÂ²+5n+2 â‰¤ 10nÂ²           |
| **4. Choose**   | Chá»n c vÃ  nâ‚€              | c=10, nâ‚€=1                |
| **5. Verify**   | Kiá»ƒm tra vá»›i vÃ i giÃ¡ trá»‹  | n=2: 24 â‰¤ 40 âœ“            |

## 5. Space Complexity Analysis

### 5.1 So sÃ¡nh Space Complexity cá»§a Data Structures

| Data Structure  | Average Space | Worst Space | Ghi chÃº                |
| --------------- | ------------- | ----------- | ---------------------- |
| **Array**       | Î˜(n)          | Î˜(n)        | Fixed size             |
| **Linked List** | Î˜(n)          | Î˜(n)        | Extra pointer storage  |
| **Stack**       | Î˜(n)          | Î˜(n)        | Linear vá»›i sá»‘ elements |
| **Queue**       | Î˜(n)          | Î˜(n)        | Linear vá»›i sá»‘ elements |
| **Hash Table**  | Î˜(n)          | O(n)        | Depends on load factor |
| **BST**         | Î˜(n)          | Î˜(n)        | Tree nodes             |

### 5.2 VÃ­ dá»¥ phÃ¢n tÃ­ch Space Complexity

```cpp
// Recursive Factorial - Space Analysis
int factorial(int n) {
    if (n <= 1) return 1;      // Base case: O(1) space
    return n * factorial(n-1); // Recursive call: O(n) stack space
}

// Iterative Factorial - Space Analysis
int factorialIter(int n) {
    int result = 1;            // O(1) space
    for (int i = 1; i <= n; i++) {
        result *= i;           // O(1) space
    }
    return result;             // Total: O(1) space
}
```

```mermaid
graph TD
    A[Recursive Factorial] --> B[Stack Depth = n]
    A --> C[Space = Big-O of n]
    D[Iterative Factorial] --> E[No Recursion]
    D --> F[Space = Big-O of 1]
```

## 6. Practical Examples

### 6.1 Matrix Multiplication Analysis

```cpp
// Standard Matrix Multiplication
void matrixMultiply(int A[][100], int B[][100], int C[][100], int n) {
    for (int i = 0; i < n; i++) {           // O(n) iterations
        for (int j = 0; j < n; j++) {       // O(n) iterations
            C[i][j] = 0;
            for (int k = 0; k < n; k++) {   // O(n) iterations
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}
// Time Complexity: Î˜(nÂ³)
// Space Complexity: Î˜(1) - khÃ´ng tÃ­nh input arrays
```

### 6.2 Comparison Table cá»§a thuáº­t toÃ¡n thá»±c táº¿

| Algorithm          | Time Best  | Time Average | Time Worst | Space    |
| ------------------ | ---------- | ------------ | ---------- | -------- |
| **Bubble Sort**    | Î©(n)       | Î˜(nÂ²)        | O(nÂ²)      | O(1)     |
| **Insertion Sort** | Î©(n)       | Î˜(nÂ²)        | O(nÂ²)      | O(1)     |
| **Merge Sort**     | Î˜(n log n) | Î˜(n log n)   | Î˜(n log n) | O(n)     |
| **Quick Sort**     | Î©(n log n) | Î˜(n log n)   | O(nÂ²)      | O(log n) |
| **Heap Sort**      | Î˜(n log n) | Î˜(n log n)   | Î˜(n log n) | O(1)     |

## 7. Advanced Topics

### 7.1 Little-o vÃ  little-Ï‰ notation

<div className="border border-purple-200 p-4 rounded">
<h4 className="font-bold text-purple-800">ğŸ”¬ Advanced Notations:</h4>
<ul className="text-purple-700 mt-2">
<li><strong>o(g(n)):</strong> Strictly smaller than - lim[nâ†’âˆ] f(n)/g(n) = 0</li>
<li><strong>Ï‰(g(n)):</strong> Strictly larger than - lim[nâ†’âˆ] f(n)/g(n) = âˆ</li>
</ul>
</div>

### 7.2 Amortized Analysis

```cpp
// Dynamic Array - Amortized O(1) insertion
class DynamicArray {
private:
    int* data;
    int size;
    int capacity;

public:
    void push_back(int value) {
        if (size == capacity) {
            // Resize: O(n) time, but rare
            capacity *= 2;
            int* newData = new int[capacity];
            for (int i = 0; i < size; i++) {
                newData[i] = data[i];
            }
            delete[] data;
            data = newData;
        }
        data[size++] = value;  // O(1) time, most cases
    }
};
// Amortized Time: O(1) per insertion
```

## 8. BÃ i táº­p thá»±c hÃ nh

### 8.1 BÃ i táº­p phÃ¢n tÃ­ch Complexity

<div className="border border-gray-200 p-4 rounded">
<h4 className="font-bold text-gray-800">ğŸ“ Thá»±c hÃ nh:</h4>
<ol className="text-gray-700 mt-2">
<li>PhÃ¢n tÃ­ch complexity cá»§a Binary Search Tree insertion</li>
<li>Chá»©ng minh 5nÂ³ + 3nÂ² + 2n + 1 = O(nÂ³)</li>
<li>So sÃ¡nh space complexity cá»§a DFS vs BFS</li>
<li>TÃ­nh amortized time cá»§a Hash Table resize</li>
</ol>
</div>

### 8.2 LeetCode Problems liÃªn quan

| Problem                                                                                                 | Difficulty | Concept                 |
| ------------------------------------------------------------------------------------------------------- | ---------- | ----------------------- |
| [Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)                 | Medium     | Binary Search Analysis  |
| [Design HashSet](https://leetcode.com/problems/design-hashset/)                                         | Easy       | Hash Table Complexity   |
| [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)             | Easy       | Amortized Analysis      |
| [Design Dynamic Array](https://leetcode.com/problems/design-dynamic-array/)                             | Medium     | Amortized Time Analysis |
| [Analyze User Website Visit Pattern](https://leetcode.com/problems/analyze-user-website-visit-pattern/) | Medium     | Complex Time Analysis   |

## 9. TÃ³m táº¯t vÃ  Checklist

<div className="border-l-4 border-indigo-400 p-4">
<h4 className="font-bold text-indigo-800">âœ… Key Takeaways:</h4>
<ul className="text-indigo-700 mt-2">
<li>Big-O (O): Upper bound - worst case scenario</li>
<li>Big-Î© (Î©): Lower bound - best case scenario</li>
<li>Big-Î¸ (Î˜): Tight bound - average case, chÃ­nh xÃ¡c nháº¥t</li>
<li>Space complexity cÅ©ng quan trá»ng nhÆ° time complexity</li>
<li>Amortized analysis cho cÃ¡c thao tÃ¡c cÃ³ cost khÃ´ng Ä‘á»“ng Ä‘á»u</li>
<li>Mathematical proof giÃºp chá»©ng minh tÃ­nh Ä‘Ãºng Ä‘áº¯n</li>
</ul>
</div>

---

## Chuáº©n bá»‹ cho bÃ i tiáº¿p theo

**BÃ i 9: Simple Sorting Algorithms** sáº½ táº­p trung vÃ o:

- CÃ i Ä‘áº·t vÃ  phÃ¢n tÃ­ch Bubble Sort
- Selection Sort vá»›i optimizations
- Insertion Sort cho small arrays
- So sÃ¡nh hiá»‡u suáº¥t cÃ¡c thuáº­t toÃ¡n
- Visualization cá»§a sorting process
