# B√†i 7: Ph√¢n T√≠ch ƒê·ªô Ph·ª©c T·∫°p Thu·∫≠t To√°n
## (Algorithmic Complexity Analysis)

---

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-6">
  <h3 className="text-xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h3>
  <ul className="text-blue-700 space-y-1">
    <li>‚Ä¢ Hi·ªÉu r√µ kh√°i ni·ªám Time Complexity v√† Space Complexity</li>
    <li>‚Ä¢ N·∫Øm v·ªØng c√°ch t√≠nh to√°n v√† ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p</li>
    <li>‚Ä¢ L√†m quen v·ªõi c√°c runtime ph·ªï bi·∫øn: O(1), O(log n), O(n), O(n¬≤), O(2‚Åø)</li>
    <li>‚Ä¢ Th·ª±c h√†nh ph√¢n t√≠ch complexity cho c√°c thu·∫≠t to√°n th·ª±c t·∫ø</li>
  </ul>
</div>

## 1. Gi·ªõi Thi·ªáu V·ªÅ ƒê·ªô Ph·ª©c T·∫°p Thu·∫≠t To√°n

### 1.1 T·∫°i Sao C·∫ßn Ph√¢n T√≠ch ƒê·ªô Ph·ª©c T·∫°p?

<div className="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-400 mb-4">
  <p className="text-yellow-800"><strong>üí° T·∫ßm quan tr·ªçng:</strong> Trong th·ª±c t·∫ø, ch√∫ng ta c·∫ßn so s√°nh c√°c thu·∫≠t to√°n ƒë·ªÉ ch·ªçn ra gi·∫£i ph√°p t·ªëi ∆∞u nh·∫•t cho t·ª´ng b√†i to√°n c·ª• th·ªÉ.</p>
</div>

```mermaid
graph TD
    A[B√†i To√°n C·∫ßn Gi·∫£i] --> B{C√≥ Nhi·ªÅu Thu·∫≠t To√°n}
    B --> C[Thu·∫≠t To√°n A]
    B --> D[Thu·∫≠t To√°n B]
    B --> E[Thu·∫≠t To√°n C]
    C --> F[Ph√¢n T√≠ch ƒê·ªô Ph·ª©c T·∫°p]
    D --> F
    E --> F
    F --> G[Ch·ªçn Thu·∫≠t To√°n T·ªëi ∆Øu]
```

### 1.2 Hai Lo·∫°i ƒê·ªô Ph·ª©c T·∫°p Ch√≠nh

| Lo·∫°i ƒê·ªô Ph·ª©c T·∫°p | K√Ω Hi·ªáu | M√¥ T·∫£ | V√≠ D·ª• |
|------------------|---------|-------|-------|
| **Time Complexity** | T(n) | Th·ªùi gian th·ª±c thi thu·∫≠t to√°n | S·ªë ph√©p so s√°nh, s·ªë v√≤ng l·∫∑p |
| **Space Complexity** | S(n) | B·ªô nh·ªõ c·∫ßn thi·∫øt ƒë·ªÉ th·ª±c thi | Bi·∫øn ph·ª•, m·∫£ng t·∫°m, stack recursion |

## 2. Time Complexity - ƒê·ªô Ph·ª©c T·∫°p Th·ªùi Gian

### 2.1 C√°c M·ª©c ƒê·ªô Time Complexity Ph·ªï Bi·∫øn

<div className="bg-green-50 p-4 rounded-lg mb-4">
  <h4 className="text-green-800 font-semibold mb-2">üìä B·∫£ng So S√°nh C√°c Runtime</h4>
</div>

| Runtime | T√™n G·ªçi | M√¥ T·∫£ | V√≠ D·ª• Thu·∫≠t To√°n |
|---------|----------|-------|------------------|
| **O(1)** | Constant | Th·ªùi gian kh√¥ng ƒë·ªïi | Array access, Hash lookup |
| **O(log n)** | Logarithmic | Chia ƒë√¥i m·ªói b∆∞·ªõc | Binary Search, Tree operations |
| **O(n)** | Linear | T·ª∑ l·ªá thu·∫≠n v·ªõi n | Linear Search, Array traversal |
| **O(n log n)** | Linearithmic | n nh√¢n log n | Merge Sort, Heap Sort |
| **O(n¬≤)** | Quadratic | B√¨nh ph∆∞∆°ng c·ªßa n | Bubble Sort, Nested loops |
| **O(2‚Åø)** | Exponential | TƒÉng theo c·∫•p s·ªë nh√¢n | Fibonacci recursive |

### 2.2 Minh H·ªça TƒÉng Tr∆∞·ªüng Complexity

```mermaid
graph LR
    A["n = 10"] --> B["O(1) = 1"]
    A --> C["O(log n) = 3.3"]
    A --> D["O(n) = 10"]
    A --> E["O(n¬≤) = 100"]
    A --> F["O(2‚Åø) = 1024"]
    
    G["n = 100"] --> H["O(1) = 1"]
    G --> I["O(log n) = 6.6"]
    G --> J["O(n) = 100"]
    G --> K["O(n¬≤) = 10000"]
    G --> L["O(2‚Åø) = 10^30"]
```

### 2.3 V√≠ D·ª• Ph√¢n T√≠ch Time Complexity V·ªõi Rust

#### V√≠ D·ª• 1: O(1) - Constant Time
```rust
fn get_array_element(arr: &[i32], index: usize) -> Option<i32> {
    // Ch·ªâ m·ªôt ph√©p truy xu·∫•t -> O(1)
    arr.get(index).copied()
}
```

#### V√≠ D·ª• 2: O(n) - Linear Time
```rust
fn linear_search(arr: &[i32], target: i32) -> Option<usize> {
    // Trong tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t, duy·ªát h·∫øt m·∫£ng -> O(n)
    for (index, &value) in arr.iter().enumerate() {
        if value == target {
            return Some(index);
        }
    }
    None
}
```

#### V√≠ D·ª• 3: O(log n) - Logarithmic Time
```rust
fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    // M·ªói l·∫ßn l·∫∑p chia ƒë√¥i kh√¥ng gian t√¨m ki·∫øm -> O(log n)
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(&target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    None
}
```

#### V√≠ D·ª• 4: O(n¬≤) - Quadratic Time
```rust
fn bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    // V√≤ng l·∫∑p ngo√†i: n l·∫ßn
    for i in 0..n {
        let mut swapped = false;
        // V√≤ng l·∫∑p trong: (n-i-1) l·∫ßn
        // T·ªïng c·ªông: n * n = O(n¬≤)
        for j in 0..n-i-1 {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
                swapped = true;
            }
        }
        // Optimization: n·∫øu kh√¥ng c√≥ swap n√†o th√¨ m·∫£ng ƒë√£ s·∫Øp x·∫øp
        if !swapped {
            break;
        }
    }
}
```

## 3. Space Complexity - ƒê·ªô Ph·ª©c T·∫°p Kh√¥ng Gian

### 3.1 C√°c Lo·∫°i Space Complexity

| Lo·∫°i | M√¥ T·∫£ | V√≠ D·ª• |
|------|-------|-------|
| **Auxiliary Space** | B·ªô nh·ªõ ph·ª• b·ªï sung | M·∫£ng t·∫°m, bi·∫øn ƒë·ªám |
| **Input Space** | B·ªô nh·ªõ l∆∞u input | D·ªØ li·ªáu ƒë·∫ßu v√†o |
| **Total Space** | T·ªïng b·ªô nh·ªõ c·∫ßn d√πng | Auxiliary + Input |

### 3.2 V√≠ D·ª• Ph√¢n T√≠ch Space Complexity

#### Space O(1) - Constant Space
```rust
fn reverse_array_in_place(arr: &mut [i32]) {
    let mut left = 0;
    let mut right = arr.len() - 1;
    
    // Ch·ªâ s·ª≠ d·ª•ng 2 bi·∫øn left, right -> O(1) space
    while left < right {
        arr.swap(left, right);
        left += 1;
        right -= 1;
    }
}
```

#### Space O(n) - Linear Space
```rust
fn merge_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    
    let mid = arr.len() / 2;
    
    // T·∫°o m·∫£ng t·∫°m c√≥ k√≠ch th∆∞·ªõc n -> O(n) space
    let mut temp = vec![0; arr.len()];
    
    merge_sort(&mut arr[0..mid]);
    merge_sort(&mut arr[mid..]);
    merge(&arr[0..mid], &arr[mid..], &mut temp, arr);
}

fn merge(left: &[i32], right: &[i32], temp: &mut [i32], result: &mut [i32]) {
    let mut i = 0; // Index cho left
    let mut j = 0; // Index cho right
    let mut k = 0; // Index cho temp
    
    // Merge hai m·∫£ng ƒë√£ s·∫Øp x·∫øp
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            temp[k] = left[i];
            i += 1;
        } else {
            temp[k] = right[j];
            j += 1;
        }
        k += 1;
    }
    
    // Copy c√°c ph·∫ßn t·ª≠ c√≤n l·∫°i
    while i < left.len() {
        temp[k] = left[i];
        i += 1;
        k += 1;
    }
    
    while j < right.len() {
        temp[k] = right[j];
        j += 1;
        k += 1;
    }
    
    // Copy t·ª´ temp v·ªÅ result
    result.copy_from_slice(&temp[0..left.len() + right.len()]);
}
```

## 4. Ph∆∞∆°ng Ph√°p Ph√¢n T√≠ch Complexity

### 4.1 Quy T·∫Øc Ph√¢n T√≠ch

<div className="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400 mb-4">
  <h4 className="text-blue-800 font-semibold mb-2">üìã C√°c Quy T·∫Øc C∆° B·∫£n</h4>
  <ol className="text-blue-700 space-y-2">
    <li><strong>1. Drop Constants:</strong> O(3n) ‚Üí O(n)</li>
    <li><strong>2. Drop Lower Order Terms:</strong> O(n¬≤ + n) ‚Üí O(n¬≤)</li>
    <li><strong>3. Worst Case Analysis:</strong> X√©t tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t</li>
    <li><strong>4. Add Complexities:</strong> Sequential ‚Üí O(a) + O(b) = O(a+b)</li>
    <li><strong>5. Multiply Complexities:</strong> Nested ‚Üí O(a) * O(b) = O(a*b)</li>
  </ol>
</div>

### 4.2 B·∫£ng Ph√¢n T√≠ch C√°c C·∫•u Tr√∫c L·∫∑p

| C·∫•u Tr√∫c | Time Complexity | Ghi Ch√∫ |
|----------|----------------|---------|
| `for i in 0..n` | O(n) | V√≤ng l·∫∑p ƒë∆°n |
| `for i in 0..n { for j in 0..n }` | O(n¬≤) | V√≤ng l·∫∑p l·ªìng nhau |
| `while n > 1 { n /= 2 }` | O(log n) | Chia ƒë√¥i m·ªói l·∫ßn |
| Recursive v·ªõi 2 nh√°nh | O(2‚Åø) | C√¢y nh·ªã ph√¢n ƒë·∫ßy |

## 5. Th·ª±c H√†nh Ph√¢n T√≠ch Complexity

### 5.1 B√†i T·∫≠p Ph√¢n T√≠ch

```rust
// B√†i t·∫≠p 1: Ph√¢n t√≠ch complexity c·ªßa h√†m n√†y
fn mystery_function_1(arr: &[i32]) -> i32 {
    let mut sum = 0;
    for i in 0..arr.len() {           // O(n)
        for j in 0..arr.len() {       // O(n)
            sum += arr[i] * arr[j];   // O(1)
        }
    }
    sum
}
// Time Complexity: O(n¬≤)
// Space Complexity: O(1)
```

```rust
// B√†i t·∫≠p 2: Ph√¢n t√≠ch complexity c·ªßa h√†m n√†y
fn mystery_function_2(n: usize) -> Vec<i32> {
    let mut result = Vec::new();
    let mut i = 1;
    
    while i <= n {              // Ch·∫°y log n l·∫ßn
        let mut j = 1;
        while j <= i {          // Ch·∫°y i l·∫ßn (1, 2, 4, 8, ...)
            result.push(i * j); // O(1)
            j += 1;
        }
        i *= 2;                 // TƒÉng g·∫•p ƒë√¥i
    }
    result
}
// Ph√¢n t√≠ch chi ti·∫øt:
// - V√≤ng ngo√†i ch·∫°y: log‚ÇÇ(n) l·∫ßn (i = 1, 2, 4, 8, ..., 2^k ‚â§ n)
// - V√≤ng trong ch·∫°y: 1 + 2 + 4 + ... + 2^k = 2^(k+1) - 1 ‚âà 2n
// Time Complexity: O(n)
// Space Complexity: O(n) - do l∆∞u tr·ªØ result vector
```

### 5.2 So S√°nh Th·ª±c T·∫ø C√°c Thu·∫≠t To√°n

```rust
use std::time::Instant;

fn benchmark_algorithms() {
    let sizes = vec![100, 1000, 10000, 100000];
    
    println!("Benchmark Results:");
    println!("{:<10} {:<15} {:<15} {:<10}", "Size", "Linear (Œºs)", "Binary (Œºs)", "Ratio");
    println!("{}", "-".repeat(55));
    
    for &n in &sizes {
        let data: Vec<i32> = (0..n).collect();
        let target = n - 1; // Worst case: t√¨m ph·∫ßn t·ª≠ cu·ªëi
        
        // Test O(n) - Linear Search (repeated for better measurement)
        let start = Instant::now();
        for _ in 0..1000 {
            let _ = linear_search(&data, target);
        }
        let linear_time = start.elapsed().as_micros() / 1000;
        
        // Test O(log n) - Binary Search (repeated for better measurement)  
        let start = Instant::now();
        for _ in 0..1000 {
            let _ = binary_search(&data, target);
        }
        let binary_time = start.elapsed().as_micros() / 1000;
        
        let ratio = if binary_time > 0 { 
            linear_time as f64 / binary_time as f64 
        } else { 
            0.0 
        };
        
        println!("{:<10} {:<15} {:<15} {:<10.1}x", 
                 n, linear_time, binary_time, ratio);
    }
}
```

## 6. Complexity c·ªßa C√°c C·∫•u Tr√∫c D·ªØ Li·ªáu Ph·ªï Bi·∫øn

### 6.1 B·∫£ng T·ªïng H·ª£p

| C·∫•u Tr√∫c D·ªØ Li·ªáu | Access | Search | Insert | Delete | Space |
|------------------|---------|---------|---------|---------|-------|
| **Array** | O(1) | O(n) | O(n) | O(n) | O(n) |
| **Linked List** | O(n) | O(n) | O(1) | O(1) | O(n) |
| **Hash Table** | N/A | O(1)* | O(1)* | O(1)* | O(n) |
| **Binary Search Tree** | O(log n)* | O(log n)* | O(log n)* | O(log n)* | O(n) |
| **Stack/Queue** | N/A | N/A | O(1) | O(1) | O(n) |

<small>*Average case, worst case c√≥ th·ªÉ kh√°c</small>

### 6.2 Bi·ªÉu ƒê·ªì So S√°nh Performance

```mermaid
graph TD
    A["Data Structures Performance"] 
    A --> B["Fast Access O(1)"]
    A --> C["Moderate Access O(log n)"]
    A --> D["Slow Access O(n)"]
    
    B --> E["Array indexing"]
    B --> F["Hash Table"]
    
    C --> G["Binary Search Tree"]
    C --> H["Binary Search"]
    
    D --> I["Linear Search"]
    D --> J["Linked List traversal"]
```

## 7. Best Practices v√† L∆∞u √ù

<div className="bg-red-50 p-4 rounded-lg border-l-4 border-red-400 mb-4">
  <h4 className="text-red-800 font-semibold mb-2">‚ö†Ô∏è Nh·ªØng L∆∞u √ù Quan Tr·ªçng</h4>
  <ul className="text-red-700 space-y-1">
    <li>‚Ä¢ Complexity kh√¥ng ph·∫£i l√† t·∫•t c·∫£ - constant factors c≈©ng quan tr·ªçng</li>
    <li>‚Ä¢ V·ªõi d·ªØ li·ªáu nh·ªè, thu·∫≠t to√°n O(n¬≤) c√≥ th·ªÉ nhanh h∆°n O(n log n)</li>
    <li>‚Ä¢ C·∫ßn c√¢n nh·∫Øc gi·ªØa time v√† space complexity</li>
    <li>‚Ä¢ Lu√¥n xem x√©t average case v√† worst case</li>
  </ul>
</div>

### 7.1 Khi N√†o Ch·ªçn Thu·∫≠t To√°n N√†o?

| K√≠ch Th∆∞·ªõc D·ªØ Li·ªáu | ∆Øu Ti√™n | Thu·∫≠t To√°n G·ª£i √ù |
|-------------------|---------|------------------|
| **n < 100** | Simple implementation | Bubble sort, Linear search |
| **100 ‚â§ n ‚â§ 10,000** | Balanced approach | Quick sort, Hash table |
| **n > 10,000** | Optimal complexity | Merge sort, Binary search |

## 9. Recursive Complexity Analysis

### 9.1 Master Theorem - C√¥ng Th·ª©c T√≠nh Complexity ƒê·ªá Quy

<div className="bg-indigo-50 p-4 rounded-lg border-l-4 border-indigo-400 mb-4">
  <h4 className="text-indigo-800 font-semibold mb-2">üìê Master Theorem</h4>
  <p className="text-indigo-700">Cho recurrence relation: <strong>T(n) = aT(n/b) + f(n)</strong></p>
  <ul className="text-indigo-700 mt-2 space-y-1">
    <li>‚Ä¢ <strong>a:</strong> s·ªë l∆∞·ª£ng subproblems</li>
    <li>‚Ä¢ <strong>b:</strong> factor chia nh·ªè input</li>
    <li>‚Ä¢ <strong>f(n):</strong> cost c·ªßa vi·ªác divide v√† combine</li>
  </ul>
</div>

| Case | ƒêi·ªÅu Ki·ªán | K·∫øt Qu·∫£ | V√≠ D·ª• |
|------|-----------|---------|-------|
| **Case 1** | f(n) = O(n^c), c < log_b(a) | T(n) = Œò(n^log_b(a)) | T(n) = 2T(n/2) + O(1) |
| **Case 2** | f(n) = Œò(n^c), c = log_b(a) | T(n) = Œò(n^c log n) | T(n) = 2T(n/2) + O(n) |
| **Case 3** | f(n) = Œ©(n^c), c > log_b(a) | T(n) = Œò(f(n)) | T(n) = 2T(n/2) + O(n¬≤) |

### 9.2 V√≠ D·ª• Ph√¢n T√≠ch ƒê·ªá Quy

```rust
// Fibonacci - O(2‚Åø) exponential
fn fibonacci_naive(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci_naive(n - 1) + fibonacci_naive(n - 2)
    }
}
// T(n) = T(n-1) + T(n-2) + O(1) ‚Üí O(2‚Åø)

// Fibonacci optimized - O(n) v·ªõi memoization
fn fibonacci_memo(n: u32, memo: &mut std::collections::HashMap<u32, u64>) -> u64 {
    if let Some(&result) = memo.get(&n) {
        return result;
    }
    
    let result = match n {
        0 => 0,
        1 => 1,
        _ => fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    };
    
    memo.insert(n, result);
    result
}
// Space: O(n) cho memo table, Time: O(n)
```

## 10. Amortized Analysis - Ph√¢n T√≠ch Kh·∫•u Hao

### 10.1 Kh√°i Ni·ªám Amortized Complexity

<div className="bg-orange-50 p-4 rounded-lg border-l-4 border-orange-400 mb-4">
  <p className="text-orange-800"><strong>üí° Amortized Analysis:</strong> Ph√¢n t√≠ch cost trung b√¨nh c·ªßa m·ªôt sequence operations, kh√¥ng ph·∫£i t·ª´ng operation ri√™ng l·∫ª.</p>
</div>

```rust
// Dynamic Array - Vector trong Rust
// Insert operation c√≥ amortized O(1) complexity
struct DynamicArray<T> {
    data: Vec<T>,
    capacity: usize,
}

impl<T> DynamicArray<T> {
    fn new() -> Self {
        Self {
            data: Vec::with_capacity(1),
            capacity: 1,
        }
    }
    
    fn push(&mut self, item: T) {
        if self.data.len() == self.capacity {
            // Resize: O(n) - nh∆∞ng x·∫£y ra √≠t
            self.capacity *= 2;
            self.data.reserve(self.capacity - self.data.len());
        }
        // Normal push: O(1) - x·∫£y ra nhi·ªÅu
        self.data.push(item);
    }
}

// Amortized Analysis:
// - Resize cost: n + n/2 + n/4 + ... = 2n = O(n)
// - Total operations: n  
// - Amortized cost per operation: O(n)/n = O(1)
```

## 11. B√†i T·∫≠p LeetCode Li√™n Quan

### 11.1 Danh S√°ch B√†i T·∫≠p Th·ª±c H√†nh
<div className="bg-purple-50 p-4 rounded-lg border-l-4 border-purple-400">
  <h4 className="text-purple-800 font-semibold mb-2">üéØ LeetCode Problems</h4>
  <ul className="text-purple-700 space-y-2">
    <li>
      <strong>Easy:</strong>
      <ul className="ml-4 mt-1 space-y-1">
        <li>‚Ä¢ <strong>Problem 1:</strong> Two Sum - Ph√¢n t√≠ch O(n¬≤) vs O(n)</li>
        <li>‚Ä¢ <strong>Problem 704:</strong> Binary Search - Th·ª±c h√†nh O(log n)</li>
        <li>‚Ä¢ <strong>Problem 283:</strong> Move Zeroes - So s√°nh c√°c approach</li>
        <li>‚Ä¢ <strong>Problem 217:</strong> Contains Duplicate - Hash vs Sort approach</li>
      </ul>
    </li>
    <li>
      <strong>Medium:</strong>
      <ul className="ml-4 mt-1 space-y-1">
        <li>‚Ä¢ <strong>Problem 15:</strong> 3Sum - Ph√¢n t√≠ch t·ª´ O(n¬≥) xu·ªëng O(n¬≤)</li>
        <li>‚Ä¢ <strong>Problem 53:</strong> Maximum Subarray - DP approach O(n)</li>
        <li>‚Ä¢ <strong>Problem 238:</strong> Product of Array Except Self - O(n) time, O(1) space</li>
        <li>‚Ä¢ <strong>Problem 240:</strong> Search 2D Matrix II - O(m+n) complexity</li>
      </ul>
    </li>
    <li>
      <strong>Hard:</strong>
      <ul className="ml-4 mt-1 space-y-1">
        <li>‚Ä¢ <strong>Problem 4:</strong> Median of Two Sorted Arrays - O(log(min(m,n)))</li>
        <li>‚Ä¢ <strong>Problem 25:</strong> Reverse Nodes in k-Group - Space complexity analysis</li>
        <li>‚Ä¢ <strong>Problem 84:</strong> Largest Rectangle in Histogram - Stack O(n) approach</li>
      </ul>
    </li>
  </ul>
</div>

### 11.2 Ph√¢n T√≠ch Chi Ti·∫øt M·ªôt S·ªë B√†i

```rust
// LeetCode 1: Two Sum
// Approach 1: Brute Force - O(n¬≤)
fn two_sum_bruteforce(nums: Vec<i32>, target: i32) -> Vec<i32> {
    for i in 0..nums.len() {
        for j in (i+1)..nums.len() {
            if nums[i] + nums[j] == target {
                return vec![i as i32, j as i32];
            }
        }
    }
    vec![]
}

// Approach 2: Hash Map - O(n)
use std::collections::HashMap;
fn two_sum_optimized(nums: Vec<i32>, target: i32) -> Vec<i32> {
    let mut map = HashMap::new();
    
    for (i, &num) in nums.iter().enumerate() {
        let complement = target - num;
        if let Some(&j) = map.get(&complement) {
            return vec![j, i as i32];
        }
        map.insert(num, i as i32);
    }
    vec![]
}
```

---

## T√≥m T·∫Øt B√†i H·ªçc

<div className="bg-gray-50 p-6 rounded-lg border border-gray-200">
  <h3 className="text-lg font-bold text-gray-800 mb-3">üéØ Key Takeaways</h3>
  <ul className="text-gray-700 space-y-2">
    <li><strong>1.</strong> Complexity analysis gi√∫p so s√°nh v√† l·ª±a ch·ªçn thu·∫≠t to√°n ph√π h·ª£p</li>
    <li><strong>2.</strong> Time complexity quan t√¢m ƒë·∫øn th·ªùi gian, space complexity quan t√¢m ƒë·∫øn b·ªô nh·ªõ</li>
    <li><strong>3.</strong> C√°c runtime ph·ªï bi·∫øn: O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2‚Åø)</li>
    <li><strong>4.</strong> Lu√¥n ph√¢n t√≠ch worst case v√† xem x√©t trade-off gi·ªØa time v√† space</li>
    <li><strong>5.</strong> Th·ª±c h√†nh v·ªõi c√°c b√†i t·∫≠p tr√™n LeetCode ƒë·ªÉ n·∫Øm v·ªØng ki·∫øn th·ª©c</li>
  </ul>
</div>

---

**B√†i ti·∫øp theo:** B√†i 8 - Big-O, Big-Œ∏, Big-Œ© Notation (K√Ω hi·ªáu ti·ªám c·∫≠n)