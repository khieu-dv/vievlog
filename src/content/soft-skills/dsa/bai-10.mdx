# B√†i 10: Advanced Sorting Algorithms
*Kh√≥a h·ªçc Data Structures & Algorithms cho ng∆∞·ªùi m·ªõi b·∫Øt ƒë·∫ßu*

---

## üìö M·ª•c ti√™u h·ªçc t·∫≠p

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
  <h3 className="text-lg font-semibold text-blue-800 mb-2">Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:</h3>
  <ul className="text-blue-700 space-y-1">
    <li>‚úì Hi·ªÉu v√† c√†i ƒë·∫∑t thu·∫≠t to√°n Merge Sort</li>
    <li>‚úì N·∫Øm v·ªØng chi·∫øn l∆∞·ª£c Divide & Conquer</li>
    <li>‚úì C√†i ƒë·∫∑t v√† t·ªëi ∆∞u thu·∫≠t to√°n Quick Sort</li>
    <li>‚úì Ph√¢n t√≠ch complexity v√† so s√°nh hi·ªáu su·∫•t</li>
  </ul>
</div>

---

## 1. T·ªïng quan v·ªÅ Advanced Sorting

### So s√°nh v·ªõi Simple Sorting

| Thu·ªôc t√≠nh | Simple Sorting | Advanced Sorting |
|------------|---------------|------------------|
| **Time Complexity** | O(n¬≤) | O(n log n) |
| **ƒê·ªô ph·ª©c t·∫°p code** | Th·∫•p | Trung b√¨nh - Cao |
| **Hi·ªáu su·∫•t v·ªõi big data** | K√©m | T·ªët |
| **Memory usage** | O(1) | O(log n) - O(n) |
| **Stability** | C√≥ th·ªÉ | T√πy thu·ªôc thu·∫≠t to√°n |

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mt-4">
  <p className="text-yellow-800"><strong>üí° T·∫°i sao c·∫ßn Advanced Sorting?</strong></p>
  <p className="text-yellow-700 mt-2">Khi d·ªØ li·ªáu l·ªõn (n > 10,000), s·ª± kh√°c bi·ªát gi·ªØa O(n¬≤) v√† O(n log n) l√† r·∫•t l·ªõn. V√≠ d·ª•: v·ªõi n = 100,000, simple sorting c·∫ßn ~10 t·ª∑ ph√©p to√°n, advanced sorting ch·ªâ c·∫ßn ~1.7 tri·ªáu ph√©p to√°n.</p>
</div>

---

## 2. Merge Sort - Thu·∫≠t to√°n "Chia ƒë·ªÉ tr·ªã"

### Nguy√™n l√Ω ho·∫°t ƒë·ªông

```mermaid
graph TD
    A["[8, 3, 1, 7, 0, 10, 2]"] --> B["[8, 3, 1, 7]"]
    A --> C["[0, 10, 2]"]
    B --> D["[8, 3]"]
    B --> E["[1, 7]"]
    C --> F["[0, 10]"]
    C --> G["[2]"]
    D --> H["[8]"]
    D --> I["[3]"]
    E --> J["[1]"]
    E --> K["[7]"]
    F --> L["[0]"]
    F --> M["[10]"]
    
    style A fill:#ff9999
    style G fill:#99ff99
    style H fill:#99ff99
    style I fill:#99ff99
    style J fill:#99ff99
    style K fill:#99ff99
    style L fill:#99ff99
    style M fill:#99ff99
```

### C√†i ƒë·∫∑t Merge Sort b·∫±ng Rust

```rust
fn merge_sort(arr: &mut [i32]) {
    let len = arr.len();
    if len <= 1 {
        return;
    }
    
    let mid = len / 2;
    merge_sort(&mut arr[0..mid]);
    merge_sort(&mut arr[mid..len]);
    
    // T·∫°o temporary arrays cho merge
    let left: Vec<i32> = arr[0..mid].to_vec();
    let right: Vec<i32> = arr[mid..len].to_vec();
    
    merge(arr, &left, &right);
}

fn merge(arr: &mut [i32], left: &[i32], right: &[i32]) {
    let mut i = 0; // Index cho left array
    let mut j = 0; // Index cho right array  
    let mut k = 0; // Index cho merged array
    
    // Merge hai m·∫£ng ƒë√£ s·∫Øp x·∫øp
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            arr[k] = left[i];
            i += 1;
        } else {
            arr[k] = right[j];
            j += 1;
        }
        k += 1;
    }
    
    // Copy remaining elements
    while i < left.len() {
        arr[k] = left[i];
        i += 1;
        k += 1;
    }
    
    while j < right.len() {
        arr[k] = right[j];
        j += 1;
        k += 1;
    }
}

// Test function
fn main() {
    let mut arr = vec![8, 3, 1, 7, 0, 10, 2];
    println!("Before: {:?}", arr);
    merge_sort(&mut arr);
    println!("After:  {:?}", arr);
}
```

### Ph√¢n t√≠ch Complexity c·ªßa Merge Sort

<div className="overflow-x-auto">

| Tr∆∞·ªùng h·ª£p | Time Complexity | Space Complexity | Gi·∫£i th√≠ch |
|------------|----------------|------------------|------------|
| **Best Case** | O(n log n) | O(n) | Lu√¥n chia ƒë√¥i v√† merge |
| **Average Case** | O(n log n) | O(n) | Kh√¥ng ph·ª• thu·ªôc input |
| **Worst Case** | O(n log n) | O(n) | Stable performance |

</div>

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mt-4">
  <h4 className="text-green-800 font-semibold">üîç Recurrence Relation</h4>
  <p className="text-green-700 mt-2"><code>T(n) = 2T(n/2) + O(n)</code></p>
  <p className="text-green-600 text-sm mt-1">S·ª≠ d·ª•ng Master Theorem: T(n) = O(n log n)</p>
</div>

---

## 3. Quick Sort - Thu·∫≠t to√°n "Ph√¢n ho·∫°ch"

### Nguy√™n l√Ω ho·∫°t ƒë·ªông

```mermaid
graph TD
    A["[3, 6, 8, 10, 1, 2, 1]"] --> B["Ch·ªçn pivot = 1"]
    B --> C["Partition around pivot"]
    C --> D["[1, 1] + [pivot=1] + [3, 6, 8, 10, 2]"]
    D --> E["Recursively sort left"]
    D --> F["Recursively sort right"]
    E --> G["[1, 1]"]
    F --> H["[2, 3, 6, 8, 10]"]
    G --> I["Final: [1, 1, 1, 2, 3, 6, 8, 10]"]
    H --> I
    
    style B fill:#ffcc99
    style I fill:#99ff99
```

### C√†i ƒë·∫∑t Quick Sort b·∫±ng Rust

```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    quick_sort_helper(arr, 0, arr.len() - 1);
}

fn quick_sort_helper(arr: &mut [i32], low: usize, high: usize) {
    if low < high {
        let pivot_index = partition(arr, low, high);
        
        // Sort left partition
        if pivot_index > 0 {
            quick_sort_helper(arr, low, pivot_index - 1);
        }
        
        // Sort right partition
        quick_sort_helper(arr, pivot_index + 1, high);
    }
}

fn partition(arr: &mut [i32], low: usize, high: usize) -> usize {
    // Ch·ªçn element cu·ªëi l√†m pivot
    let pivot = arr[high];
    let mut i = low; // Index c·ªßa element nh·ªè h∆°n
    
    for j in low..high {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    
    arr.swap(i, high); // ƒê·∫∑t pivot v√†o v·ªã tr√≠ ƒë√∫ng
    i
}

// Optimized version v·ªõi random pivot
use rand::Rng;

fn randomized_partition(arr: &mut [i32], low: usize, high: usize) -> usize {
    let mut rng = rand::thread_rng();
    let random_index = rng.gen_range(low..=high);
    arr.swap(random_index, high);
    partition(arr, low, high)
}
```

### C√°c chi·∫øn l∆∞·ª£c ch·ªçn Pivot

| Chi·∫øn l∆∞·ª£c | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm | Khi n√†o s·ª≠ d·ª•ng |
|------------|---------|------------|------------------|
| **First Element** | ƒê∆°n gi·∫£n, nhanh | Worst case v·ªõi sorted array | D·ªØ li·ªáu random |
| **Last Element** | ƒê∆°n gi·∫£n | Worst case v·ªõi reverse sorted | D·ªØ li·ªáu random |
| **Random Element** | Tr√°nh worst case | Overhead c·ªßa random | D·ªØ li·ªáu kh√¥ng bi·∫øt tr∆∞·ªõc |
| **Median-of-3** | Balanced partition | Ph·ª©c t·∫°p h∆°n | Production code |

### Ph√¢n t√≠ch Complexity c·ªßa Quick Sort

<div className="overflow-x-auto">

| Tr∆∞·ªùng h·ª£p | Time Complexity | Space Complexity | ƒêi·ªÅu ki·ªán |
|------------|----------------|------------------|-----------|
| **Best Case** | O(n log n) | O(log n) | Pivot lu√¥n ·ªü gi·ªØa |
| **Average Case** | O(n log n) | O(log n) | Random pivot |
| **Worst Case** | O(n¬≤) | O(n) | Pivot lu√¥n min/max |

</div>

---

## 4. So s√°nh Merge Sort vs Quick Sort

<div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
    <h4 className="text-blue-800 font-semibold mb-3">üîÑ Merge Sort</h4>
    <div className="text-blue-700 space-y-2">
      <p><strong>‚úÖ ∆Øu ƒëi·ªÉm:</strong></p>
      <ul className="list-disc list-inside text-sm space-y-1">
        <li>Stable sorting</li>
        <li>Guaranteed O(n log n)</li>
        <li>Predictable performance</li>
      </ul>
      <p><strong>‚ùå Nh∆∞·ª£c ƒëi·ªÉm:</strong></p>
      <ul className="list-disc list-inside text-sm space-y-1">
        <li>C·∫ßn O(n) extra memory</li>
        <li>Slower cho small arrays</li>
      </ul>
    </div>
  </div>
  
  <div className="bg-orange-50 border border-orange-200 rounded-lg p-4">
    <h4 className="text-orange-800 font-semibold mb-3">‚ö° Quick Sort</h4>
    <div className="text-orange-700 space-y-2">
      <p><strong>‚úÖ ∆Øu ƒëi·ªÉm:</strong></p>
      <ul className="list-disc list-inside text-sm space-y-1">
        <li>In-place sorting</li>
        <li>Faster trong th·ª±c t·∫ø</li>
        <li>Cache-friendly</li>
      </ul>
      <p><strong>‚ùå Nh∆∞·ª£c ƒëi·ªÉm:</strong></p>
      <ul className="list-disc list-inside text-sm space-y-1">
        <li>Worst case O(n¬≤)</li>
        <li>Not stable</li>
        <li>Performance ph·ª• thu·ªôc pivot</li>
      </ul>
    </div>
  </div>
</div>

---

## 5. Benchmark v√† Testing

### Test v·ªõi different input sizes

```rust
use std::time::Instant;

fn benchmark_sorting() {
    let sizes = vec![1000, 10000, 100000];
    
    for &size in &sizes {
        println!("\n=== Testing v·ªõi {} elements ===", size);
        
        // Generate random data
        let mut data: Vec<i32> = (0..size).map(|_| rand::random()).collect();
        
        // Test Merge Sort
        let mut merge_data = data.clone();
        let start = Instant::now();
        merge_sort(&mut merge_data);
        let merge_time = start.elapsed();
        
        // Test Quick Sort  
        let mut quick_data = data.clone();
        let start = Instant::now();
        quick_sort(&mut quick_data);
        let quick_time = start.elapsed();
        
        println!("Merge Sort: {:?}", merge_time);
        println!("Quick Sort: {:?}", quick_time);
        
        // Verify correctness
        assert!(is_sorted(&merge_data));
        assert!(is_sorted(&quick_data));
    }
}

fn is_sorted(arr: &[i32]) -> bool {
    arr.windows(2).all(|w| w[0] <= w[1])
}
```

---

## 6. Khi n√†o s·ª≠ d·ª•ng thu·∫≠t to√°n n√†o?

### Decision Tree cho Sorting Algorithm

```mermaid
flowchart TD
    A["C·∫ßn s·∫Øp x·∫øp d·ªØ li·ªáu"] --> B{"D·ªØ li·ªáu c√≥ l·ªõn kh√¥ng?"}
    B -->|"< 50 elements"| C["Insertion Sort"]
    B -->|"> 50 elements"| D{"C·∫ßn stable sorting?"}
    
    D -->|"C√≥"| E["Merge Sort"]
    D -->|"Kh√¥ng"| F{"Memory c√≥ h·∫°n ch·∫ø?"}
    
    F -->|"C√≥"| G["Quick Sort"]
    F -->|"Kh√¥ng"| H{"Worst case c√≥ quan tr·ªçng?"}
    
    H -->|"C√≥"| I["Merge Sort"]
    H -->|"Kh√¥ng"| J["Quick Sort"]
    
    style C fill:#99ccff
    style E fill:#99ff99
    style G fill:#ffcc99
    style I fill:#99ff99
    style J fill:#ffcc99
```

### Recommendations Table

| T√¨nh hu·ªëng | Thu·∫≠t to√°n ƒë·ªÅ xu·∫•t | L√Ω do |
|------------|-------------------|-------|
| **Small arrays (n < 50)** | Insertion Sort | Overhead th·∫•p, simple |
| **Need stable sorting** | Merge Sort | Duy tr√¨ th·ª© t·ª± relative |
| **Memory constrained** | Quick Sort | In-place sorting |
| **Guaranteed performance** | Merge Sort | Always O(n log n) |
| **General purpose** | Quick Sort | Average case t·ªët nh·∫•t |

---

## 7. B√†i t·∫≠p th·ª±c h√†nh

### B√†i t·∫≠p LeetCode li√™n quan:

<div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
  <h4 className="font-semibold mb-3">üéØ Danh s√°ch b√†i t·∫≠p tr√™n LeetCode:</h4>
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <p className="font-medium text-green-700">Easy Level:</p>
      <ul className="text-sm space-y-1 mt-1">
        <li>‚Ä¢ <strong>88.</strong> Merge Sorted Array</li>
        <li>‚Ä¢ <strong>283.</strong> Move Zeroes</li>
        <li>‚Ä¢ <strong>922.</strong> Sort Array By Parity II</li>
      </ul>
    </div>
    <div>
      <p className="font-medium text-orange-700">Medium Level:</p>
      <ul className="text-sm space-y-1 mt-1">
        <li>‚Ä¢ <strong>75.</strong> Sort Colors (Dutch Flag)</li>
        <li>‚Ä¢ <strong>148.</strong> Sort List</li>
        <li>‚Ä¢ <strong>215.</strong> Kth Largest Element</li>
        <li>‚Ä¢ <strong>912.</strong> Sort an Array</li>
      </ul>
    </div>
  </div>
</div>

### C√¢u h·ªèi t·ª± ki·ªÉm tra:

1. **Merge Sort c√≥ th·ªÉ ƒë∆∞·ª£c implement iteratively kh√¥ng? T·∫°i sao?**
2. **L√†m th·∫ø n√†o ƒë·ªÉ Quick Sort tr·ªü th√†nh stable?**
3. **T·∫°i sao Quick Sort l·∫°i cache-friendly h∆°n Merge Sort?**
4. **Hybrid sorting algorithm l√† g√¨? V√≠ d·ª• v·ªÅ Timsort.**

---

## 8. T√≥m t·∫Øt

<div className="bg-indigo-50 border border-indigo-200 rounded-lg p-6 mt-6">
  <h4 className="text-indigo-800 font-semibold mb-4">üìù Key Takeaways</h4>
  <div className="text-indigo-700 space-y-3">
    <p><strong>1. Merge Sort:</strong> Stable, predictable O(n log n), c·∫ßn extra memory</p>
    <p><strong>2. Quick Sort:</strong> In-place, average O(n log n), worst O(n¬≤)</p>
    <p><strong>3. Divide & Conquer:</strong> Powerful paradigm cho optimization problems</p>
    <p><strong>4. Algorithm Selection:</strong> Ph·ª• thu·ªôc requirements v√† constraints</p>
  </div>
</div>

---

**B√†i ti·∫øp theo:** [B√†i 11: Heap Sort & Priority Queue](./lesson-11.md)

*üí° Tip: Th·ª±c h√†nh implement c·∫£ hai thu·∫≠t to√°n v√† benchmark v·ªõi different data sizes ƒë·ªÉ hi·ªÉu s√¢u h∆°n v·ªÅ performance characteristics!*