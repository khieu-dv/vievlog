# B√†i 14: Tree Traversal Algorithms - Thu·∫≠t to√°n duy·ªát c√¢y

<div className="bg-gradient-to-r from-blue-50 to-indigo-100 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u h·ªçc t·∫≠p</h2>
  <p className="text-blue-700">N·∫Øm v·ªØng c√°c thu·∫≠t to√°n duy·ªát c√¢y c∆° b·∫£n v√† ·ª©ng d·ª•ng th·ª±c t·∫ø c·ªßa ch√∫ng trong vi·ªác x·ª≠ l√Ω d·ªØ li·ªáu c√¢y.</p>
</div>

## üìñ Gi·ªõi thi·ªáu

Duy·ªát c√¢y (Tree Traversal) l√† qu√° tr√¨nh truy c·∫≠p v√† x·ª≠ l√Ω t·∫•t c·∫£ c√°c node trong c√¢y theo m·ªôt th·ª© t·ª± nh·∫•t ƒë·ªãnh. ƒê√¢y l√† k·ªπ thu·∫≠t c∆° b·∫£n v√† quan tr·ªçng nh·∫•t khi l√†m vi·ªác v·ªõi c·∫•u tr√∫c d·ªØ li·ªáu c√¢y.

<div className="bg-yellow-50 border-l-4 border-yellow-500 p-4 my-6">
  <h3 className="font-bold text-yellow-800">üí° T·∫°i sao c·∫ßn duy·ªát c√¢y?</h3>
  <ul className="text-yellow-700 mt-2">
    <li>T√¨m ki·∫øm ph·∫ßn t·ª≠ trong c√¢y</li>
    <li>T√≠nh to√°n c√°c gi√° tr·ªã t·ªïng h·ª£p (sum, max, min)</li>
    <li>Sao ch√©p ho·∫∑c serialize c√¢y</li>
    <li>X√¢y d·ª±ng bi·ªÉu th·ª©c to√°n h·ªçc t·ª´ c√¢y</li>
  </ul>
</div>

## üå≥ C√°c lo·∫°i thu·∫≠t to√°n duy·ªát c√¢y

C√≥ hai nh√≥m ch√≠nh c√°c thu·∫≠t to√°n duy·ªát c√¢y:

| **Nh√≥m** | **Thu·∫≠t to√°n** | **ƒê·∫∑c ƒëi·ªÉm** | **ƒê·ªô ph·ª©c t·∫°p** |
|----------|----------------|--------------|-----------------|
| **Depth-First** | In-order | Tr√°i ‚Üí G·ªëc ‚Üí Ph·∫£i | O(n) |
| **Depth-First** | Pre-order | G·ªëc ‚Üí Tr√°i ‚Üí Ph·∫£i | O(n) |
| **Depth-First** | Post-order | Tr√°i ‚Üí Ph·∫£i ‚Üí G·ªëc | O(n) |
| **Breadth-First** | Level-order | Theo t·ª´ng m·ª©c | O(n) |

## üîç 1. In-order Traversal (LNR)

**Th·ª© t·ª±:** Tr√°i ‚Üí Node ‚Üí Ph·∫£i

### Bi·ªÉu ƒë·ªì minh h·ªça

```mermaid
graph TD
    A[4] --> B[2]
    A --> C[6]
    B --> D[1]
    B --> E[3]
    C --> F[5]
    C --> G[7]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style D fill:#fff3e0
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#fff3e0
```

**K·∫øt qu·∫£:** 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí 7

### C√†i ƒë·∫∑t b·∫±ng Rust

#### C·∫•u tr√∫c d·ªØ li·ªáu c√¢y

```rust
#[derive(Debug, Clone)]
struct TreeNode {
    val: i32,
    left: Option<Box<TreeNode>>,
    right: Option<Box<TreeNode>>,
}

impl TreeNode {
    fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}
```

#### In-order Recursive

```rust
fn inorder_recursive(root: &Option<Box<TreeNode>>, result: &mut Vec<i32>) {
    if let Some(node) = root {
        // Duy·ªát c√¢y con tr√°i
        inorder_recursive(&node.left, result);
        
        // X·ª≠ l√Ω node hi·ªán t·∫°i
        result.push(node.val);
        
        // Duy·ªát c√¢y con ph·∫£i
        inorder_recursive(&node.right, result);
    }
}
```

#### In-order Iterative

```rust
fn inorder_iterative(root: Option<Box<TreeNode>>) -> Vec<i32> {
    let mut result = Vec::new();
    let mut stack = Vec::new();
    let mut current = root;
    
    while current.is_some() || !stack.is_empty() {
        // ƒêi ƒë·∫øn node tr√°i nh·∫•t
        while let Some(node) = current {
            stack.push(node.clone());
            current = node.left;
        }
        
        // X·ª≠ l√Ω node
        if let Some(node) = stack.pop() {
            result.push(node.val);
            current = node.right;
        }
    }
    
    result
}
```

<div className="bg-green-50 border-l-4 border-green-500 p-4 my-6">
  <h3 className="font-bold text-green-800">‚úÖ ·ª®ng d·ª•ng In-order</h3>
  <p className="text-green-700">Trong Binary Search Tree, In-order traversal cho ra d√£y s·ªë ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp tƒÉng d·∫ßn!</p>
</div>

## üîç 2. Pre-order Traversal (NLR)

**Th·ª© t·ª±:** Node ‚Üí Tr√°i ‚Üí Ph·∫£i

### C√†i ƒë·∫∑t b·∫±ng Rust

#### Pre-order Recursive

```rust
fn preorder_recursive(root: &Option<Box<TreeNode>>, result: &mut Vec<i32>) {
    if let Some(node) = root {
        // X·ª≠ l√Ω node hi·ªán t·∫°i tr∆∞·ªõc
        result.push(node.val);
        
        // Duy·ªát c√¢y con tr√°i
        preorder_recursive(&node.left, result);
        
        // Duy·ªát c√¢y con ph·∫£i
        preorder_recursive(&node.right, result);
    }
}
```

#### Pre-order Iterative

```rust
fn preorder_iterative(root: Option<Box<TreeNode>>) -> Vec<i32> {
    let mut result = Vec::new();
    let mut stack = Vec::new();
    
    if let Some(root_node) = root {
        stack.push(root_node);
    }
    
    while let Some(node) = stack.pop() {
        // X·ª≠ l√Ω node hi·ªán t·∫°i
        result.push(node.val);
        
        // Push right first (v√¨ stack l√† LIFO)
        if let Some(right) = node.right {
            stack.push(right);
        }
        
        // Push left second
        if let Some(left) = node.left {
            stack.push(left);
        }
    }
    
    result
}
```

## üîç 3. Post-order Traversal (LRN)

**Th·ª© t·ª±:** Tr√°i ‚Üí Ph·∫£i ‚Üí Node

### C√†i ƒë·∫∑t b·∫±ng Rust

#### Post-order Recursive

```rust
fn postorder_recursive(root: &Option<Box<TreeNode>>, result: &mut Vec<i32>) {
    if let Some(node) = root {
        // Duy·ªát c√¢y con tr√°i
        postorder_recursive(&node.left, result);
        
        // Duy·ªát c√¢y con ph·∫£i
        postorder_recursive(&node.right, result);
        
        // X·ª≠ l√Ω node hi·ªán t·∫°i cu·ªëi c√πng
        result.push(node.val);
    }
}
```

#### Post-order Iterative (s·ª≠ d·ª•ng 2 stack)

```rust
fn postorder_iterative(root: Option<Box<TreeNode>>) -> Vec<i32> {
    let mut result = Vec::new();
    let mut stack1 = Vec::new();
    let mut stack2 = Vec::new();
    
    if let Some(root_node) = root {
        stack1.push(root_node);
    }
    
    // B∆∞·ªõc 1: ƒê∆∞a t·∫•t c·∫£ node v√†o stack2 theo th·ª© t·ª± ng∆∞·ª£c
    while let Some(node) = stack1.pop() {
        stack2.push(node.val);
        
        if let Some(left) = node.left {
            stack1.push(left);
        }
        
        if let Some(right) = node.right {
            stack1.push(right);
        }
    }
    
    // B∆∞·ªõc 2: Pop t·ª´ stack2 ƒë·ªÉ c√≥ th·ª© t·ª± ƒë√∫ng
    while let Some(val) = stack2.pop() {
        result.push(val);
    }
    
    result
}
```

<div className="bg-purple-50 border-l-4 border-purple-500 p-4 my-6">
  <h3 className="font-bold text-purple-800">üéØ ·ª®ng d·ª•ng Post-order</h3>
  <p className="text-purple-700">Th√≠ch h·ª£p ƒë·ªÉ t√≠nh to√°n k√≠ch th∆∞·ªõc c√¢y con, x√≥a c√¢y, ho·∫∑c ƒë√°nh gi√° bi·ªÉu th·ª©c to√°n h·ªçc.</p>
</div>

## üîç 4. Level-order Traversal (BFS)

**Th·ª© t·ª±:** Theo t·ª´ng m·ª©c t·ª´ tr√™n xu·ªëng d∆∞·ªõi, tr√°i sang ph·∫£i

### Bi·ªÉu ƒë·ªì minh h·ªça c√°c m·ª©c

```mermaid
graph TD
    subgraph "Level 0"
    A[4]
    end
    
    subgraph "Level 1" 
    B[2]
    C[6]
    end
    
    subgraph "Level 2"
    D[1]
    E[3] 
    F[5]
    G[7]
    end
    
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    C --> G
```

### C√†i ƒë·∫∑t b·∫±ng Rust

```rust
use std::collections::VecDeque;

fn level_order_traversal(root: Option<Box<TreeNode>>) -> Vec<i32> {
    let mut result = Vec::new();
    let mut queue = VecDeque::new();
    
    if let Some(root_node) = root {
        queue.push_back(root_node);
    }
    
    while let Some(node) = queue.pop_front() {
        // X·ª≠ l√Ω node hi·ªán t·∫°i
        result.push(node.val);
        
        // Th√™m con tr√°i v√†o queue
        if let Some(left) = node.left {
            queue.push_back(left);
        }
        
        // Th√™m con ph·∫£i v√†o queue
        if let Some(right) = node.right {
            queue.push_back(right);
        }
    }
    
    result
}
```

### Level-order theo t·ª´ng m·ª©c ri√™ng bi·ªát

```rust
fn level_order_by_levels(root: Option<Box<TreeNode>>) -> Vec<Vec<i32>> {
    let mut result = Vec::new();
    let mut queue = VecDeque::new();
    
    if let Some(root_node) = root {
        queue.push_back(root_node);
    }
    
    while !queue.is_empty() {
        let level_size = queue.len();
        let mut current_level = Vec::new();
        
        for _ in 0..level_size {
            if let Some(node) = queue.pop_front() {
                current_level.push(node.val);
                
                if let Some(left) = node.left {
                    queue.push_back(left);
                }
                
                if let Some(right) = node.right {
                    queue.push_back(right);
                }
            }
        }
        
        result.push(current_level);
    }
    
    result
}
```

## üìä So s√°nh c√°c thu·∫≠t to√°n duy·ªát

| **Ti√™u ch√≠** | **In-order** | **Pre-order** | **Post-order** | **Level-order** |
|--------------|--------------|---------------|----------------|-----------------|
| **Th·ª© t·ª±** | L-N-R | N-L-R | L-R-N | Theo m·ª©c |
| **Space Complexity** | O(h) | O(h) | O(h) | O(w) |
| **·ª®ng d·ª•ng ch√≠nh** | BST sorting | Tree copy | Tree delete | BFS, Tree size |
| **Stack/Queue** | Stack | Stack | Stack | Queue |

*Trong ƒë√≥: h = chi·ªÅu cao c√¢y, w = chi·ªÅu r·ªông t·ªëi ƒëa c·ªßa c√¢y*

## üîß ·ª®ng d·ª•ng th·ª±c t·∫ø

### 1. Serialize v√† Deserialize c√¢y

```rust
fn serialize_preorder(root: &Option<Box<TreeNode>>) -> String {
    let mut result = Vec::new();
    serialize_helper(root, &mut result);
    result.join(",")
}

fn serialize_helper(root: &Option<Box<TreeNode>>, result: &mut Vec<String>) {
    match root {
        Some(node) => {
            result.push(node.val.to_string());
            serialize_helper(&node.left, result);
            serialize_helper(&node.right, result);
        }
        None => {
            result.push("null".to_string());
        }
    }
}
```

### 2. Ki·ªÉm tra t√≠nh ƒë·ªëi x·ª©ng c·ªßa c√¢y

```rust
fn is_symmetric(root: Option<Box<TreeNode>>) -> bool {
    match root {
        Some(node) => is_mirror(&node.left, &node.right),
        None => true,
    }
}

fn is_mirror(left: &Option<Box<TreeNode>>, right: &Option<Box<TreeNode>>) -> bool {
    match (left, right) {
        (None, None) => true,
        (Some(l), Some(r)) => {
            l.val == r.val
                && is_mirror(&l.left, &r.right)
                && is_mirror(&l.right, &r.left)
        }
        _ => false,
    }
}
```

### 3. T√¨m ƒë∆∞·ªùng ƒëi t·ª´ root ƒë·∫øn node

```rust
fn find_path(root: &Option<Box<TreeNode>>, target: i32) -> Vec<i32> {
    let mut path = Vec::new();
    find_path_helper(root, target, &mut path);
    path
}

fn find_path_helper(root: &Option<Box<TreeNode>>, target: i32, path: &mut Vec<i32>) -> bool {
    if let Some(node) = root {
        path.push(node.val);
        
        if node.val == target {
            return true;
        }
        
        if find_path_helper(&node.left, target, path) 
            || find_path_helper(&node.right, target, path) {
            return true;
        }
        
        path.pop(); // Backtrack
    }
    
    false
}
```

<div className="bg-red-50 border-l-4 border-red-500 p-4 my-6">
  <h3 className="font-bold text-red-800">‚ö†Ô∏è L∆∞u √Ω quan tr·ªçng</h3>
  <ul className="text-red-700 mt-2">
    <li>Recursive approach c√≥ th·ªÉ g√¢y stack overflow v·ªõi c√¢y s√¢u</li>
    <li>Iterative approach s·ª≠ d·ª•ng b·ªô nh·ªõ hi·ªáu qu·∫£ h∆°n cho c√¢y l·ªõn</li>
    <li>Level-order c·∫ßn nhi·ªÅu b·ªô nh·ªõ nh·∫•t do s·ª≠ d·ª•ng queue</li>
  </ul>
</div>

## üéØ B√†i t·∫≠p th·ª±c h√†nh tr√™n LeetCode

### üü¢ D·ªÖ
1. **[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)**
2. **[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)**
3. **[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)**
4. **[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)**

### üü° Trung b√¨nh  
1. **[103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)**
2. **[107. Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)**
3. **[199. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)**
4. **[515. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)**

### üî¥ Kh√≥
1. **[297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)**
2. **[987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)**

## üìù T·ªïng k·∫øt

<div className="bg-blue-50 border-l-4 border-blue-500 p-4 my-6">
  <h3 className="font-bold text-blue-800">üéØ ƒêi·ªÉm ch√≠nh c·∫ßn nh·ªõ</h3>
  <ul className="text-blue-700 mt-2">
    <li><strong>In-order:</strong> T·∫°o d√£y s·∫Øp x·∫øp t·ª´ BST</li>
    <li><strong>Pre-order:</strong> Sao ch√©p v√† serialize c√¢y</li>
    <li><strong>Post-order:</strong> T√≠nh to√°n t·ª´ l√° l√™n g·ªëc</li>
    <li><strong>Level-order:</strong> X·ª≠ l√Ω theo ƒë·ªô s√¢u, BFS</li>
    <li>M·ªói thu·∫≠t to√°n ƒë·ªÅu c√≥ ƒë·ªô ph·ª©c t·∫°p th·ªùi gian O(n)</li>
    <li>L·ª±a ch·ªçn recursive vs iterative t√πy thu·ªôc v√†o y√™u c·∫ßu b·ªô nh·ªõ</li>
  </ul>
</div>

Trong b√†i ti·∫øp theo, ch√∫ng ta s·∫Ω h·ªçc v·ªÅ **Binary Search Trees (BST)** - m·ªôt ·ª©ng d·ª•ng quan tr·ªçng c·ªßa c√°c thu·∫≠t to√°n duy·ªát c√¢y m√† ch√∫ng ta v·ª´a h·ªçc!