# B√†i 16: Balanced Trees - AVL Trees

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-l-4 border-blue-500 p-6 mb-8 rounded-r-lg">
  <h2 className="text-2xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u h·ªçc t·∫≠p</h2>
  <ul className="text-blue-700 space-y-2">
    <li>‚Ä¢ Hi·ªÉu v·∫•n ƒë·ªÅ c·ªßa Binary Search Tree kh√¥ng c√¢n b·∫±ng</li>
    <li>‚Ä¢ N·∫Øm v·ªØng kh√°i ni·ªám AVL Tree v√† Balance Factor</li>
    <li>‚Ä¢ Th·ª±c hi·ªán c√°c ph√©p xoay (rotation) ƒë·ªÉ c√¢n b·∫±ng c√¢y</li>
    <li>‚Ä¢ C√†i ƒë·∫∑t AVL Tree v·ªõi c√°c thao t√°c insert v√† delete</li>
  </ul>
</div>

## 1. V·∫•n ƒë·ªÅ c·ªßa Binary Search Tree kh√¥ng c√¢n b·∫±ng

### 1.1 T·∫°i sao c·∫ßn c√¢y c√¢n b·∫±ng?

Binary Search Tree (BST) th√¥ng th∆∞·ªùng c√≥ th·ªÉ b·ªã tho√°i h√≥a th√†nh danh s√°ch li√™n k·∫øt trong tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t, d·∫´n ƒë·∫øn hi·ªáu su·∫•t O(n) thay v√¨ O(log n).

```mermaid
graph TD
    subgraph "BST L√Ω t∆∞·ªüng O(log n)"
        A[50] --> B[30]
        A --> C[70]
        B --> D[20]
        B --> E[40]
        C --> F[60]
        C --> G[80]
    end
    
    subgraph "BST Tho√°i h√≥a O(n)"
        H[10] --> I[20]
        I --> J[30]
        J --> K[40]
        K --> L[50]
        L --> M[60]
    end
```

### 1.2 So s√°nh hi·ªáu su·∫•t

| Thao t√°c | BST C√¢n b·∫±ng | BST Tho√°i h√≥a |
|----------|--------------|---------------|
| Search   | O(log n)     | O(n)          |
| Insert   | O(log n)     | O(n)          |
| Delete   | O(log n)     | O(n)          |

## 2. AVL Tree - ƒê·ªãnh nghƒ©a v√† T√≠nh ch·∫•t

<div className="bg-green-50 border border-green-200 rounded-lg p-6 mb-6">
  <h3 className="text-xl font-semibold text-green-800 mb-3">üìö ƒê·ªãnh nghƒ©a</h3>
  <p className="text-green-700">
    <strong>AVL Tree</strong> l√† m·ªôt Binary Search Tree t·ª± c√¢n b·∫±ng, trong ƒë√≥ ƒë·ªô ch√™nh l·ªách chi·ªÅu cao gi·ªØa c√¢y con tr√°i v√† c√¢y con ph·∫£i c·ªßa m·ªói node kh√¥ng v∆∞·ª£t qu√° 1.
  </p>
</div>

### 2.1 Balance Factor (H·ªá s·ªë c√¢n b·∫±ng)

**Balance Factor (BF) = Height(Left Subtree) - Height(Right Subtree)**

Trong AVL Tree, Balance Factor c·ªßa m·ªói node ph·∫£i thu·ªôc t·∫≠p `{-1, 0, 1}`.

| Balance Factor | √ù nghƒ©a |
|----------------|---------|
| -1 | C√¢y con ph·∫£i cao h∆°n c√¢y con tr√°i 1 level |
| 0  | C√¢y con tr√°i v√† ph·∫£i c√≥ c√πng chi·ªÅu cao |
| 1  | C√¢y con tr√°i cao h∆°n c√¢y con ph·∫£i 1 level |

```rust
#[derive(Debug, Clone)]
struct AVLNode {
    value: i32,
    height: i32,
    left: Option<Box<AVLNode>>,
    right: Option<Box<AVLNode>>,
}

impl AVLNode {
    fn new(value: i32) -> Self {
        AVLNode {
            value,
            height: 1,
            left: None,
            right: None,
        }
    }
    
    fn get_height(node: &Option<Box<AVLNode>>) -> i32 {
        match node {
            Some(n) => n.height,
            None => 0,
        }
    }
    
    fn get_balance_factor(&self) -> i32 {
        Self::get_height(&self.left) - Self::get_height(&self.right)
    }
    
    fn update_height(&mut self) {
        self.height = 1 + std::cmp::max(
            Self::get_height(&self.left),
            Self::get_height(&self.right)
        );
    }
}
```

## 3. C√°c ph√©p xoay (Rotation Operations)

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6 mb-6">
  <h3 className="text-xl font-semibold text-yellow-800 mb-3">‚öôÔ∏è B·ªën lo·∫°i ph√©p xoay</h3>
  <div className="grid grid-cols-2 gap-4 text-sm">
    <div>
      <strong className="text-yellow-700">Left Rotation (LL)</strong>
      <p className="text-yellow-600">Khi c√¢y con ph·∫£i n·∫∑ng v·ªÅ ph·∫£i</p>
    </div>
    <div>
      <strong className="text-yellow-700">Right Rotation (RR)</strong>
      <p className="text-yellow-600">Khi c√¢y con tr√°i n·∫∑ng v·ªÅ tr√°i</p>
    </div>
    <div>
      <strong className="text-yellow-700">Left-Right Rotation (LR)</strong>
      <p className="text-yellow-600">Khi c√¢y con tr√°i n·∫∑ng v·ªÅ ph·∫£i</p>
    </div>
    <div>
      <strong className="text-yellow-700">Right-Left Rotation (RL)</strong>
      <p className="text-yellow-600">Khi c√¢y con ph·∫£i n·∫∑ng v·ªÅ tr√°i</p>
    </div>
  </div>
</div>

### 3.1 Left Rotation (Xoay tr√°i)

```mermaid
graph TD
    subgraph "Tr∆∞·ªõc xoay"
        A[X] --> B[T1]
        A --> C[Y]
        C --> D[T2]
        C --> E[T3]
    end
    
    subgraph "Sau xoay"
        F[Y] --> G[X]
        F --> H[T3]
        G --> I[T1]
        G --> J[T2]
    end
```

```rust
impl AVLNode {
    fn left_rotate(mut x: Box<AVLNode>) -> Box<AVLNode> {
        let mut y = x.right.take().unwrap();
        x.right = y.left.take();
        x.update_height();
        y.left = Some(x);
        y.update_height();
        y
    }
}
```

### 3.2 Right Rotation (Xoay ph·∫£i)

```rust
impl AVLNode {
    fn right_rotate(mut y: Box<AVLNode>) -> Box<AVLNode> {
        let mut x = y.left.take().unwrap();
        y.left = x.right.take();
        y.update_height();
        x.right = Some(y);
        x.update_height();
        x
    }
}
```

### 3.3 B·∫£ng t·ªïng k·∫øt c√°c tr∆∞·ªùng h·ª£p xoay

| Balance Factor | C√¢y con | Lo·∫°i xoay c·∫ßn thi·∫øt |
|----------------|---------|-------------------|
| > 1 | Left BF ‚â• 0 | Right Rotation |
| > 1 | Left BF < 0 | Left-Right Rotation |
| < -1 | Right BF ‚â§ 0 | Left Rotation |
| < -1 | Right BF > 0 | Right-Left Rotation |

## 4. C√†i ƒë·∫∑t AVL Tree

### 4.1 C·∫•u tr√∫c AVL Tree

```rust
pub struct AVLTree {
    root: Option<Box<AVLNode>>,
}

impl AVLTree {
    pub fn new() -> Self {
        AVLTree { root: None }
    }
    
    pub fn insert(&mut self, value: i32) {
        self.root = Self::insert_node(self.root.take(), value);
    }
    
    pub fn delete(&mut self, value: i32) {
        self.root = Self::delete_node(self.root.take(), value);
    }
    
    pub fn search(&self, value: i32) -> bool {
        Self::search_node(&self.root, value)
    }
}
```

### 4.2 Thao t√°c Insert v·ªõi c√¢n b·∫±ng

```rust
impl AVLTree {
    fn insert_node(node: Option<Box<AVLNode>>, value: i32) -> Option<Box<AVLNode>> {
        // B∆∞·ªõc 1: Th·ª±c hi·ªán BST insert b√¨nh th∆∞·ªùng
        let mut node = match node {
            None => return Some(Box::new(AVLNode::new(value))),
            Some(mut n) => {
                if value < n.value {
                    n.left = Self::insert_node(n.left.take(), value);
                } else if value > n.value {
                    n.right = Self::insert_node(n.right.take(), value);
                } else {
                    return Some(n); // Duplicate values not allowed
                }
                n
            }
        };
        
        // B∆∞·ªõc 2: C·∫≠p nh·∫≠t height
        node.update_height();
        
        // B∆∞·ªõc 3: T√≠nh balance factor
        let balance = node.get_balance_factor();
        
        // B∆∞·ªõc 4: Th·ª±c hi·ªán rotation n·∫øu c·∫ßn
        Some(Self::rebalance(node, balance))
    }
    
    fn rebalance(mut node: Box<AVLNode>, balance: i32) -> Box<AVLNode> {
        // Left Heavy
        if balance > 1 {
            let left_balance = node.left.as_ref().unwrap().get_balance_factor();
            if left_balance < 0 {
                // Left-Right case
                node.left = Some(AVLNode::left_rotate(node.left.take().unwrap()));
            }
            // Left-Left case
            return AVLNode::right_rotate(node);
        }
        
        // Right Heavy
        if balance < -1 {
            let right_balance = node.right.as_ref().unwrap().get_balance_factor();
            if right_balance > 0 {
                // Right-Left case
                node.right = Some(AVLNode::right_rotate(node.right.take().unwrap()));
            }
            // Right-Right case
            return AVLNode::left_rotate(node);
        }
        
        node
    }
}
```

### 4.3 Thao t√°c Delete v·ªõi c√¢n b·∫±ng

```rust
impl AVLTree {
    fn delete_node(node: Option<Box<AVLNode>>, value: i32) -> Option<Box<AVLNode>> {
        let mut node = match node {
            None => return None,
            Some(mut n) => {
                if value < n.value {
                    n.left = Self::delete_node(n.left.take(), value);
                    n
                } else if value > n.value {
                    n.right = Self::delete_node(n.right.take(), value);
                    n
                } else {
                    // Node to be deleted found
                    match (n.left.take(), n.right.take()) {
                        (None, None) => return None,
                        (Some(left), None) => return Some(left),
                        (None, Some(right)) => return Some(right),
                        (Some(left), Some(right)) => {
                            // Find inorder successor
                            let min_val = Self::find_min(&right);
                            n.value = min_val;
                            n.left = Some(left);
                            n.right = Self::delete_node(Some(right), min_val);
                            n
                        }
                    }
                }
            }
        };
        
        node.update_height();
        let balance = node.get_balance_factor();
        Some(Self::rebalance(node, balance))
    }
    
    fn find_min(node: &Box<AVLNode>) -> i32 {
        match &node.left {
            None => node.value,
            Some(left) => Self::find_min(left),
        }
    }
}
```

## 5. Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p

### 5.1 B·∫£ng so s√°nh hi·ªáu su·∫•t

| Thao t√°c | Time Complexity | Space Complexity |
|----------|----------------|------------------|
| Search   | O(log n)       | O(log n) - recursion |
| Insert   | O(log n)       | O(log n) - recursion |
| Delete   | O(log n)       | O(log n) - recursion |
| Traversal| O(n)           | O(log n) - recursion |

<div className="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6">
  <h3 className="text-xl font-semibold text-blue-800 mb-3">üîç T·∫°i sao AVL Tree ƒë·∫£m b·∫£o O(log n)?</h3>
  <p className="text-blue-700 mb-2">
    V√¨ balance factor lu√¥n trong kho·∫£ng [-1, 1], chi·ªÅu cao c·ªßa AVL Tree ƒë∆∞·ª£c gi·ªõi h·∫°n b·ªüi:
  </p>
  <code className="bg-blue-100 px-2 py-1 rounded">h ‚â§ 1.44 * log‚ÇÇ(n + 2) - 0.33</code>
</div>

## 6. V√≠ d·ª• minh h·ªça

### 6.1 X√¢y d·ª±ng AVL Tree t·ª´ d√£y s·ªë [10, 20, 30, 40, 50, 25]

```mermaid
graph TD
    subgraph "B∆∞·ªõc 1: Insert 10"
        A[10]
    end
    
    subgraph "B∆∞·ªõc 2: Insert 20"
        B[10] --> C[20]
    end
    
    subgraph "B∆∞·ªõc 3: Insert 30 - C·∫ßn xoay"
        D[20] --> E[10]
        D --> F[30]
    end
```

### 6.2 Demo code ho√†n ch·ªânh

```rust
fn main() {
    let mut avl = AVLTree::new();
    
    // Insert sequence
    let values = vec![10, 20, 30, 40, 50, 25];
    for val in values {
        avl.insert(val);
        println!("Inserted {}, Tree height: {}", val, avl.get_height());
    }
    
    // Search operations
    println!("Search 25: {}", avl.search(25)); // true
    println!("Search 35: {}", avl.search(35)); // false
    
    // Delete operation
    avl.delete(30);
    println!("Deleted 30, Tree height: {}", avl.get_height());
}

impl AVLTree {
    pub fn get_height(&self) -> i32 {
        AVLNode::get_height(&self.root)
    }
}
```

## 7. ∆Øu v√† nh∆∞·ª£c ƒëi·ªÉm

### 7.1 B·∫£ng so s√°nh v·ªõi c√°c c·∫•u tr√∫c kh√°c

| ƒê·∫∑c ƒëi·ªÉm | AVL Tree | BST | Hash Table |
|----------|----------|-----|------------|
| Search | O(log n) | O(n) worst | O(1) average |
| Insert | O(log n) | O(n) worst | O(1) average |
| Delete | O(log n) | O(n) worst | O(1) average |
| Ordered traversal | ‚úÖ | ‚úÖ | ‚ùå |
| Memory overhead | Cao | Th·∫•p | Trung b√¨nh |

### 7.2 Khi n√†o s·ª≠ d·ª•ng AVL Tree?

<div className="grid grid-cols-1 md:grid-cols-2 gap-4">
  <div className="bg-green-50 border border-green-200 rounded-lg p-4">
    <h4 className="text-lg font-semibold text-green-800 mb-2">‚úÖ N√™n s·ª≠ d·ª•ng khi:</h4>
    <ul className="text-green-700 space-y-1 text-sm">
      <li>‚Ä¢ C·∫ßn search/insert/delete v·ªõi ƒë·ªô ph·ª©c t·∫°p ·ªïn ƒë·ªãnh</li>
      <li>‚Ä¢ Th·ª±c hi·ªán nhi·ªÅu thao t√°c search</li>
      <li>‚Ä¢ C·∫ßn duy·ªát d·ªØ li·ªáu theo th·ª© t·ª±</li>
      <li>‚Ä¢ D·ªØ li·ªáu c√≥ th·ªÉ ƒë∆∞·ª£c insert theo th·ª© t·ª±</li>
    </ul>
  </div>
  
  <div className="bg-red-50 border border-red-200 rounded-lg p-4">
    <h4 className="text-lg font-semibold text-red-800 mb-2">‚ùå Kh√¥ng n√™n s·ª≠ d·ª•ng khi:</h4>
    <ul className="text-red-700 space-y-1 text-sm">
      <li>‚Ä¢ Th·ª±c hi·ªán ch·ªß y·∫øu insert/delete</li>
      <li>‚Ä¢ Memory overhead l√† v·∫•n ƒë·ªÅ</li>
      <li>‚Ä¢ Kh√¥ng c·∫ßn d·ªØ li·ªáu c√≥ th·ª© t·ª±</li>
      <li>‚Ä¢ Ch·ªâ c·∫ßn average-case performance</li>
    </ul>
  </div>
</div>

## 8. B√†i t·∫≠p th·ª±c h√†nh tr√™n LeetCode

### 8.1 B√†i t·∫≠p c∆° b·∫£n
| Problem | Difficulty | Link |
|---------|------------|------|
| Validate Binary Search Tree | Medium | [LeetCode 98](https://leetcode.com/problems/validate-binary-search-tree/) |
| Convert Sorted Array to Binary Search Tree | Easy | [LeetCode 108](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) |
| Balance a Binary Search Tree | Medium | [LeetCode 1382](https://leetcode.com/problems/balance-a-binary-search-tree/) |

### 8.2 B√†i t·∫≠p n√¢ng cao
| Problem | Difficulty | Link |
|---------|------------|------|
| Delete Node in a BST | Medium | [LeetCode 450](https://leetcode.com/problems/delete-node-in-a-bst/) |
| Construct Binary Tree from Preorder and Inorder | Medium | [LeetCode 105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |
| Binary Tree Maximum Path Sum | Hard | [LeetCode 124](https://leetcode.com/problems/binary-tree-maximum-path-sum/) |

<div className="bg-gray-50 border border-gray-200 rounded-lg p-6 mt-8">
  <h3 className="text-xl font-semibold text-gray-800 mb-3">üìù T√≥m t·∫Øt b√†i h·ªçc</h3>
  <div className="text-gray-700 space-y-2">
    <p>‚Ä¢ AVL Tree ƒë·∫£m b·∫£o hi·ªáu su·∫•t O(log n) cho m·ªçi thao t√°c c∆° b·∫£n</p>
    <p>‚Ä¢ Balance Factor ph·∫£i lu√¥n thu·ªôc <code>{'-1, 0, 1'}</code></p>
    <p>‚Ä¢ B·ªën lo·∫°i rotation: LL, RR, LR, RL</p>
    <p>‚Ä¢ Trade-off gi·ªØa performance ·ªïn ƒë·ªãnh v√† memory overhead</p>
  </div>
</div>

---

**B√†i ti·∫øp theo:** B√†i 17 - B-Trees v√† Advanced Tree Structures