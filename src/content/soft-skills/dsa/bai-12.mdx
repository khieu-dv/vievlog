# B√†i 12: Searching Algorithms - Thu·∫≠t to√°n t√¨m ki·∫øm

<div className="border-l-4 border-blue-500 bg-blue-50 p-4 mb-6">
<h2 className="text-xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
<p className="text-blue-700">Hi·ªÉu v√† n·∫Øm v·ªØng c√°c thu·∫≠t to√°n t√¨m ki·∫øm c∆° b·∫£n, t·ª´ t√¨m ki·∫øm tuy·∫øn t√≠nh ƒë·∫øn t√¨m ki·∫øm nh·ªã ph√¢n, ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p v√† ·ª©ng d·ª•ng trong th·ª±c t·∫ø.</p>
</div>

## üìö T·ªïng quan v·ªÅ Searching Algorithms

Thu·∫≠t to√°n t√¨m ki·∫øm l√† n·ªÅn t·∫£ng c·ªßa nhi·ªÅu ·ª©ng d·ª•ng trong khoa h·ªçc m√°y t√≠nh. Ch√∫ng ta s·∫Ω t√¨m hi·ªÉu c√°c ph∆∞∆°ng ph√°p t√¨m ki·∫øm kh√°c nhau v√† khi n√†o n√™n s·ª≠ d·ª•ng t·ª´ng lo·∫°i.

```mermaid
graph TD
    A[Searching Algorithms] --> B[Linear Search]
    A --> C[Binary Search]
    A --> D[Advanced Search]
    
    B --> E[Unsorted Data]
    B --> F[O(n) Complexity]
    
    C --> G[Sorted Data Only]
    C --> H[O(log n) Complexity]
    
    D --> I[Interpolation Search]
    D --> J[Jump Search]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

## 1. Linear Search (T√¨m ki·∫øm tuy·∫øn t√≠nh)

### üìñ Kh√°i ni·ªám c∆° b·∫£n

Linear Search l√† thu·∫≠t to√°n t√¨m ki·∫øm ƒë∆°n gi·∫£n nh·∫•t, duy·ªát qua t·ª´ng ph·∫ßn t·ª≠ c·ªßa d·ªØ li·ªáu cho ƒë·∫øn khi t√¨m th·∫•y ho·∫∑c k·∫øt th√∫c danh s√°ch.

| Thu·ªôc t√≠nh | Gi√° tr·ªã |
|------------|---------|
| Time Complexity | O(n) |
| Space Complexity | O(1) |
| ƒêi·ªÅu ki·ªán d·ªØ li·ªáu | Kh√¥ng y√™u c·∫ßu s·∫Øp x·∫øp |
| Ph√π h·ª£p v·ªõi | D·ªØ li·ªáu nh·ªè, ch∆∞a s·∫Øp x·∫øp |

### üîß C√†i ƒë·∫∑t b·∫±ng Rust

```rust
// Linear Search implementation
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
    for (index, element) in arr.iter().enumerate() {
        if element == target {
            return Some(index);
        }
    }
    None
}

// Linear Search v·ªõi custom comparator
fn linear_search_with<T, F>(arr: &[T], predicate: F) -> Option<usize>
where
    F: Fn(&T) -> bool,
{
    for (index, element) in arr.iter().enumerate() {
        if predicate(element) {
            return Some(index);
        }
    }
    None
}

// V√≠ d·ª• s·ª≠ d·ª•ng
fn main() {
    let numbers = vec![64, 34, 25, 12, 22, 11, 90];
    
    // T√¨m ki·∫øm gi√° tr·ªã 25
    match linear_search(&numbers, &25) {
        Some(index) => println!("T√¨m th·∫•y 25 t·∫°i v·ªã tr√≠: {}", index),
        None => println!("Kh√¥ng t√¨m th·∫•y 25"),
    }
    
    // T√¨m s·ªë l·ªõn h∆°n 50
    match linear_search_with(&numbers, |&x| x > 50) {
        Some(index) => println!("S·ªë ƒë·∫ßu ti√™n > 50 t·∫°i v·ªã tr√≠: {}", index),
        None => println!("Kh√¥ng t√¨m th·∫•y s·ªë > 50"),
    }
}
```

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 my-4">
<h4 className="font-bold text-yellow-800 mb-2">üí° ∆Øu ƒëi·ªÉm c·ªßa Linear Search:</h4>
<ul className="text-yellow-700 space-y-1">
<li>‚Ä¢ ƒê∆°n gi·∫£n, d·ªÖ hi·ªÉu v√† c√†i ƒë·∫∑t</li>
<li>‚Ä¢ Ho·∫°t ƒë·ªông v·ªõi m·ªçi lo·∫°i d·ªØ li·ªáu</li>
<li>‚Ä¢ Kh√¥ng y√™u c·∫ßu d·ªØ li·ªáu ph·∫£i s·∫Øp x·∫øp</li>
<li>‚Ä¢ Hi·ªáu qu·∫£ v·ªõi d·ªØ li·ªáu nh·ªè</li>
</ul>
</div>

## 2. Binary Search (T√¨m ki·∫øm nh·ªã ph√¢n)

### üìñ Kh√°i ni·ªám c∆° b·∫£n

Binary Search s·ª≠ d·ª•ng chi·∫øn l∆∞·ª£c "chia ƒë·ªÉ tr·ªã", li√™n t·ª•c chia ƒë√¥i kh√¥ng gian t√¨m ki·∫øm b·∫±ng c√°ch so s√°nh v·ªõi ph·∫ßn t·ª≠ ·ªü gi·ªØa.

```mermaid
graph TD
    A["M·∫£ng ƒë√£ s·∫Øp x·∫øp: [1, 3, 5, 7, 9, 11, 13]"] --> B["T√¨m ki·∫øm: 7"]
    B --> C["So s√°nh v·ªõi gi·ªØa: arr[3] = 7"]
    C --> D["T√¨m th·∫•y! V·ªã tr√≠ = 3"]
    
    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#e8f5e8
    style D fill:#f3e5f5
```

### üìä So s√°nh hi·ªáu su·∫•t

| K√≠ch th∆∞·ªõc m·∫£ng | Linear Search | Binary Search |
|----------------|---------------|---------------|
| 1,000 | ~500 so s√°nh | ~10 so s√°nh |
| 1,000,000 | ~500,000 so s√°nh | ~20 so s√°nh |
| 1,000,000,000 | ~500,000,000 so s√°nh | ~30 so s√°nh |

### üîß C√†i ƒë·∫∑t Binary Search

```rust
// Binary Search c∆° b·∫£n
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Result<usize, usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Ok(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    Err(left) // V·ªã tr√≠ ƒë·ªÉ ch√®n n·∫øu kh√¥ng t√¨m th·∫•y
}

// Binary Search ƒë·ªá quy
fn binary_search_recursive<T: Ord>(
    arr: &[T], 
    target: &T, 
    left: usize, 
    right: usize
) -> Option<usize> {
    if left >= right {
        return None;
    }
    
    let mid = left + (right - left) / 2;
    
    match arr[mid].cmp(target) {
        std::cmp::Ordering::Equal => Some(mid),
        std::cmp::Ordering::Less => {
            binary_search_recursive(arr, target, mid + 1, right)
        },
        std::cmp::Ordering::Greater => {
            binary_search_recursive(arr, target, left, mid)
        }
    }
}

// T√¨m v·ªã tr√≠ ƒë·∫ßu ti√™n c·ªßa ph·∫ßn t·ª≠
fn find_first_occurrence<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    let mut result = None;
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => {
                result = Some(mid);
                right = mid; // Ti·∫øp t·ª•c t√¨m b√™n tr√°i
            },
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    result
}

// T√¨m v·ªã tr√≠ cu·ªëi c√πng c·ªßa ph·∫ßn t·ª≠
fn find_last_occurrence<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    let mut result = None;
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => {
                result = Some(mid);
                left = mid + 1; // Ti·∫øp t·ª•c t√¨m b√™n ph·∫£i
            },
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    result
}
```

## 3. Binary Search Variants

### 3.1 Lower Bound v√† Upper Bound

```rust
// T√¨m v·ªã tr√≠ ƒë·∫ßu ti√™n >= target (lower_bound)
fn lower_bound<T: Ord>(arr: &[T], target: &T) -> usize {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        if arr[mid] < *target {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    left
}

// T√¨m v·ªã tr√≠ ƒë·∫ßu ti√™n > target (upper_bound)
fn upper_bound<T: Ord>(arr: &[T], target: &T) -> usize {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        if arr[mid] <= *target {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    left
}

// ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán c·ªßa target
fn count_occurrences<T: Ord>(arr: &[T], target: &T) -> usize {
    let lower = lower_bound(arr, target);
    let upper = upper_bound(arr, target);
    
    if lower < arr.len() && arr[lower] == *target {
        upper - lower
    } else {
        0
    }
}
```

## 4. Interpolation Search

### üìñ Kh√°i ni·ªám

Interpolation Search c·∫£i thi·ªán Binary Search b·∫±ng c√°ch ∆∞·ªõc t√≠nh v·ªã tr√≠ t·ªëi ∆∞u d·ª±a tr√™n gi√° tr·ªã c·∫ßn t√¨m, ƒë·∫∑c bi·ªát hi·ªáu qu·∫£ v·ªõi d·ªØ li·ªáu ph√¢n b·ªë ƒë·ªÅu.

<div className="bg-gray-50 border border-gray-200 rounded-lg p-4 my-4">
<h4 className="font-bold text-gray-800 mb-2">üìà C√¥ng th·ª©c Interpolation:</h4>
<code className="bg-white px-2 py-1 rounded text-sm">
pos = low + [(target - arr[low]) / (arr[high] - arr[low])] √ó (high - low)
</code>
</div>

```rust
fn interpolation_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut low = 0;
    let mut high = arr.len() - 1;
    
    while low <= high && target >= arr[low] && target <= arr[high] {
        // N·∫øu ch·ªâ c√≥ 1 ph·∫ßn t·ª≠
        if low == high {
            return if arr[low] == target { Some(low) } else { None };
        }
        
        // T√≠nh to√°n v·ªã tr√≠ interpolation
        let pos = low + (
            ((target - arr[low]) as f64 / (arr[high] - arr[low]) as f64) 
            * (high - low) as f64
        ) as usize;
        
        if arr[pos] == target {
            return Some(pos);
        }
        
        if arr[pos] < target {
            low = pos + 1;
        } else {
            high = pos - 1;
        }
    }
    
    None
}
```

## 5. Jump Search

Jump Search k·∫øt h·ª£p t√¨m ki·∫øm nh·∫£y v·ªõi t√¨m ki·∫øm tuy·∫øn t√≠nh, c√≥ ƒë·ªô ph·ª©c t·∫°p O(‚àön).

```rust
fn jump_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let n = arr.len();
    let step = (n as f64).sqrt() as usize;
    let mut prev = 0;
    
    // T√¨m block ch·ª©a target
    while prev < n && arr[std::cmp::min(step, n) - 1] < *target {
        prev = step;
        if prev >= n {
            return None;
        }
    }
    
    // Linear search trong block
    let end = std::cmp::min(prev + step, n);
    for i in prev..end {
        if arr[i] == *target {
            return Some(i);
        }
    }
    
    None
}
```

## 6. So s√°nh c√°c thu·∫≠t to√°n t√¨m ki·∫øm

| Thu·∫≠t to√°n | Time Complexity | Space | ƒêi·ªÅu ki·ªán | T·ªët nh·∫•t cho |
|------------|----------------|-------|-----------|--------------|
| Linear Search | O(n) | O(1) | Kh√¥ng | D·ªØ li·ªáu nh·ªè, ch∆∞a s·∫Øp x·∫øp |
| Binary Search | O(log n) | O(1) | ƒê√£ s·∫Øp x·∫øp | D·ªØ li·ªáu l·ªõn, ƒë√£ s·∫Øp x·∫øp |
| Interpolation | O(log log n)* | O(1) | Ph√¢n b·ªë ƒë·ªÅu | D·ªØ li·ªáu s·ªë, ph√¢n b·ªë ƒë·ªÅu |
| Jump Search | O(‚àön) | O(1) | ƒê√£ s·∫Øp x·∫øp | Trung gian, kh√¥ng gian h·∫°n ch·∫ø |

*Trong tr∆∞·ªùng h·ª£p t·ªët nh·∫•t

## 7. ·ª®ng d·ª•ng th·ª±c t·∫ø

### 7.1 Binary Search trong optimization

```rust
// T√¨m cƒÉn b·∫≠c hai b·∫±ng Binary Search
fn sqrt_binary_search(x: f64, precision: f64) -> f64 {
    let mut left = 0.0;
    let mut right = if x > 1.0 { x } else { 1.0 };
    
    while (right - left) > precision {
        let mid = left + (right - left) / 2.0;
        let square = mid * mid;
        
        if square < x {
            left = mid;
        } else {
            right = mid;
        }
    }
    
    (left + right) / 2.0
}

// T√¨m ƒëi·ªÉm peak trong m·∫£ng
fn find_peak_element(arr: &[i32]) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len() - 1;
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        if arr[mid] > arr[mid + 1] {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    Some(left)
}
```

## 8. C√°c l·ªói th∆∞·ªùng g·∫∑p v√† c√°ch tr√°nh

<div className="bg-red-50 border border-red-200 rounded-lg p-4 my-4">
<h4 className="font-bold text-red-800 mb-2">‚ö†Ô∏è L∆∞u √Ω quan tr·ªçng:</h4>
<ul className="text-red-700 space-y-1">
<li>‚Ä¢ <strong>Integer Overflow:</strong> S·ª≠ d·ª•ng <code>left + (right - left) / 2</code> thay v√¨ <code>(left + right) / 2</code></li>
<li>‚Ä¢ <strong>Infinite Loop:</strong> ƒê·∫£m b·∫£o left v√† right ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë√∫ng c√°ch</li>
<li>‚Ä¢ <strong>Off-by-one:</strong> C·∫©n th·∫≠n v·ªõi ƒëi·ªÅu ki·ªán d·ª´ng v√† boundaries</li>
<li>‚Ä¢ <strong>Empty Array:</strong> Ki·ªÉm tra k√≠ch th∆∞·ªõc m·∫£ng tr∆∞·ªõc khi t√¨m ki·∫øm</li>
</ul>
</div>

## üéØ T√≥m t·∫Øt

- **Linear Search**: ƒê∆°n gi·∫£n, O(n), kh√¥ng y√™u c·∫ßu s·∫Øp x·∫øp
- **Binary Search**: Hi·ªáu qu·∫£, O(log n), y√™u c·∫ßu d·ªØ li·ªáu ƒë√£ s·∫Øp x·∫øp
- **Variants**: First/Last occurrence, Lower/Upper bound
- **Advanced**: Interpolation Search, Jump Search
- **Applications**: Optimization problems, finding peaks, square root

## üìù B√†i t·∫≠p LeetCode li√™n quan

### C·∫•p ƒë·ªô Easy:
- [704. Binary Search](https://leetcode.com/problems/binary-search/)
- [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)
- [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)
- [367. Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)

### C·∫•p ƒë·ªô Medium:
- [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)
- [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

### C·∫•p ƒë·ªô Hard:
- [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)
- [154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)

<div className="mt-8 p-4 bg-green-50 border border-green-200 rounded-lg">
<h4 className="font-bold text-green-800 mb-2">‚úÖ Checkpoint</h4>
<p className="text-green-700">B·∫°n ƒë√£ ho√†n th√†nh B√†i 12! H√£y th·ª±c h√†nh v·ªõi c√°c b√†i t·∫≠p LeetCode ƒë·ªÉ c·ªßng c·ªë ki·∫øn th·ª©c v·ªÅ thu·∫≠t to√°n t√¨m ki·∫øm.</p>
</div>