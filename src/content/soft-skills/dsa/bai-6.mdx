# B√†i 6: Hash Tables - B·∫£ng bƒÉm

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-800 mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <ul className="text-blue-700 space-y-2">
    <li>‚úÖ Hi·ªÉu kh√°i ni·ªám Hash Function v√† Collision Handling</li>
    <li>‚úÖ C√†i ƒë·∫∑t Hash Table v·ªõi Separate Chaining</li>
    <li>‚úÖ C√†i ƒë·∫∑t Hash Table v·ªõi Open Addressing</li>
    <li>‚úÖ Ph√¢n t√≠ch Load Factor v√† Rehashing</li>
    <li>‚úÖ Th·ª±c h√†nh c√°c thao t√°c Insert, Search, Delete</li>
  </ul>
</div>

## 1. Kh√°i ni·ªám c∆° b·∫£n

**Hash Table** (B·∫£ng bƒÉm) l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu cho ph√©p l∆∞u tr·ªØ v√† truy xu·∫•t d·ªØ li·ªáu v·ªõi th·ªùi gian trung b√¨nh **O(1)**. ƒêi·ªÅu n√†y ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua **hash function** - m·ªôt h√†m chuy·ªÉn ƒë·ªïi kh√≥a (key) th√†nh ch·ªâ s·ªë (index) trong b·∫£ng.

### Th√†nh ph·∫ßn ch√≠nh c·ªßa Hash Table

```mermaid
graph TD
    A[Key: "apple"] -->|Hash Function| B[Index: 5]
    B --> C[Array Position 5]
    C --> D[Value: "red fruit"]
    
    E[Key: "banana"] -->|Hash Function| F[Index: 2] 
    F --> G[Array Position 2]
    G --> H[Value: "yellow fruit"]
```

| Th√†nh ph·∫ßn | M√¥ t·∫£ | V√≠ d·ª• |
|-----------|--------|-------|
| **Key** | Kh√≥a ƒë·ªÉ t√¨m ki·∫øm | "apple", "banana", 123 |
| **Hash Function** | H√†m chuy·ªÉn key th√†nh index | `hash("apple") = 5` |
| **Bucket/Slot** | V·ªã tr√≠ l∆∞u tr·ªØ trong m·∫£ng | `array[5]` |
| **Value** | Gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ | "red fruit" |

## 2. Hash Function (H√†m bƒÉm)

Hash function l√† tr√°i tim c·ªßa Hash Table. M·ªôt hash function t·ªët c·∫ßn c√≥ c√°c ƒë·∫∑c ƒëi·ªÉm:

<div className="bg-yellow-50 p-4 rounded-lg border border-yellow-200 mb-6">
  <h3 className="text-yellow-800 font-semibold mb-2">üîë ƒê·∫∑c ƒëi·ªÉm c·ªßa Hash Function t·ªët:</h3>
  <ul className="text-yellow-700 space-y-1">
    <li>‚Ä¢ Ph√¢n ph·ªëi ƒë·ªÅu c√°c keys trong b·∫£ng</li>
    <li>‚Ä¢ T√≠nh to√°n nhanh (O(1))</li>
    <li>‚Ä¢ Deterministic (c√πng input ‚Üí c√πng output)</li>
    <li>‚Ä¢ Gi·∫£m thi·ªÉu collision</li>
  </ul>
</div>

### C√°c Hash Function ph·ªï bi·∫øn

| Ph∆∞∆°ng ph√°p | C√¥ng th·ª©c | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|-------------|-----------|---------|------------|
| **Division** | `h(k) = k mod m` | ƒê∆°n gi·∫£n, nhanh | Clustering n·∫øu m kh√¥ng t·ªët |
| **Multiplication** | `h(k) = ‚åäm(kA mod 1)‚åã` | √çt nh·∫°y c·∫£m v·ªõi m | Ph·ª©c t·∫°p h∆°n |
| **Universal Hashing** | `h(k) = ((ak + b) mod p) mod m` | Tr√°nh worst-case | Chi ph√≠ t√≠nh to√°n cao |

### C√†i ƒë·∫∑t Hash Function trong Rust

```rust
struct HashTable<K, V> {
    buckets: Vec<Vec<(K, V)>>,
    size: usize,
    capacity: usize,
}

impl<K, V> HashTable<K, V> 
where 
    K: Clone + PartialEq + std::hash::Hash,
    V: Clone,
{
    fn hash(&self, key: &K) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % self.capacity
    }
    
    fn new(capacity: usize) -> Self {
        HashTable {
            buckets: vec![Vec::new(); capacity],
            size: 0,
            capacity,
        }
    }
}
```

## 3. Collision Handling (X·ª≠ l√Ω xung ƒë·ªôt)

Khi hai keys kh√°c nhau c√≥ c√πng hash value, ta g·ªçi ƒë√≥ l√† **collision**. C√≥ hai ph∆∞∆°ng ph√°p ch√≠nh ƒë·ªÉ x·ª≠ l√Ω:

```mermaid
graph TD
    A[Collision Handling] --> B[Separate Chaining]
    A --> C[Open Addressing]
    
    B --> B1[Linked Lists]
    B --> B2[Dynamic Arrays]
    B --> B3[BST/AVL Trees]
    
    C --> C1[Linear Probing]
    C --> C2[Quadratic Probing] 
    C --> C3[Double Hashing]
```

### 3.1 Separate Chaining

M·ªói bucket ch·ª©a m·ªôt danh s√°ch c√°c ph·∫ßn t·ª≠ c√≥ c√πng hash value.

| ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|---------|------------|
| ‚úÖ D·ªÖ c√†i ƒë·∫∑t | ‚ùå Overhead b·ªô nh·ªõ cho pointers |
| ‚úÖ Kh√¥ng b·ªã gi·ªõi h·∫°n s·ªë ph·∫ßn t·ª≠ | ‚ùå Cache performance k√©m |
| ‚úÖ Deletion ƒë∆°n gi·∫£n | ‚ùå Th·ªùi gian kh√¥ng ·ªïn ƒë·ªãnh |

```rust
impl<K, V> HashTable<K, V> 
where 
    K: Clone + PartialEq + std::hash::Hash,
    V: Clone,
{
    fn insert(&mut self, key: K, value: V) {
        let index = self.hash(&key);
        
        // T√¨m xem key ƒë√£ t·ªìn t·∫°i ch∆∞a
        for (existing_key, existing_value) in &mut self.buckets[index] {
            if *existing_key == key {
                *existing_value = value; // Update
                return;
            }
        }
        
        // Th√™m m·ªõi
        self.buckets[index].push((key, value));
        self.size += 1;
        
        // Ki·ªÉm tra load factor
        if self.load_factor() > 0.75 {
            self.resize();
        }
    }
    
    fn get(&self, key: &K) -> Option<&V> {
        let index = self.hash(key);
        
        for (existing_key, value) in &self.buckets[index] {
            if existing_key == key {
                return Some(value);
            }
        }
        None
    }
    
    fn remove(&mut self, key: &K) -> Option<V> {
        let index = self.hash(key);
        
        if let Some(pos) = self.buckets[index]
            .iter()
            .position(|(k, _)| k == key) 
        {
            let (_, value) = self.buckets[index].remove(pos);
            self.size -= 1;
            Some(value)
        } else {
            None
        }
    }
}
```

### 3.2 Open Addressing (Linear Probing)

Khi g·∫∑p collision, t√¨m slot ti·∫øp theo c√≤n tr·ªëng trong b·∫£ng.

```rust
struct OpenAddressingHashTable<K, V> {
    entries: Vec<Option<(K, V)>>,
    size: usize,
    capacity: usize,
}

impl<K, V> OpenAddressingHashTable<K, V>
where
    K: Clone + PartialEq + std::hash::Hash,
    V: Clone,
{
    fn new(capacity: usize) -> Self {
        OpenAddressingHashTable {
            entries: vec![None; capacity],
            size: 0,
            capacity,
        }
    }
    
    fn hash(&self, key: &K) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % self.capacity
    }
    
    fn insert(&mut self, key: K, value: V) -> bool {
        if self.size >= self.capacity * 3 / 4 {
            self.resize();
        }
        
        let mut index = self.hash(&key);
        
        loop {
            match &self.entries[index] {
                None => {
                    self.entries[index] = Some((key, value));
                    self.size += 1;
                    return true;
                }
                Some((existing_key, _)) if existing_key == &key => {
                    self.entries[index] = Some((key, value)); // Update
                    return true;
                }
                Some(_) => {
                    index = (index + 1) % self.capacity; // Linear probing
                }
            }
        }
    }
    
    fn get(&self, key: &K) -> Option<&V> {
        let mut index = self.hash(key);
        
        loop {
            match &self.entries[index] {
                None => return None,
                Some((existing_key, value)) if existing_key == key => {
                    return Some(value);
                }
                Some(_) => {
                    index = (index + 1) % self.capacity;
                }
            }
        }
    }
}
```

## 4. Load Factor v√† Rehashing

**Load Factor** = S·ªë ph·∫ßn t·ª≠ / Dung l∆∞·ª£ng b·∫£ng

```mermaid
graph LR
    A[Load Factor = 0.25] --> B[Underutilized]
    C[Load Factor = 0.75] --> D[Optimal]
    E[Load Factor = 1.0] --> F[Full/Poor Performance]
```

| Load Factor | Separate Chaining | Open Addressing |
|-------------|-------------------|-----------------|
| **< 0.5** | L√£ng ph√≠ b·ªô nh·ªõ | T·ªët, √≠t collision |
| **0.5 - 0.75** | Optimal | Acceptable |
| **> 0.75** | Acceptable | Poor performance |
| **> 1.0** | Still works | Kh√¥ng th·ªÉ ho·∫°t ƒë·ªông |

### C√†i ƒë·∫∑t Rehashing

```rust
impl<K, V> HashTable<K, V> 
where 
    K: Clone + PartialEq + std::hash::Hash,
    V: Clone,
{
    fn load_factor(&self) -> f64 {
        self.size as f64 / self.capacity as f64
    }
    
    fn resize(&mut self) {
        let old_buckets = std::mem::replace(
            &mut self.buckets, 
            vec![Vec::new(); self.capacity * 2]
        );
        
        let old_capacity = self.capacity;
        self.capacity *= 2;
        self.size = 0;
        
        // Rehash t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠
        for bucket in old_buckets {
            for (key, value) in bucket {
                self.insert(key, value);
            }
        }
        
        println!("Resized from {} to {}", old_capacity, self.capacity);
    }
}
```

## 5. So s√°nh hi·ªáu su·∫•t

<div className="overflow-x-auto mb-6">

| Thao t√°c | Separate Chaining | Open Addressing | Array | Linked List |
|----------|-------------------|------------------|-------|-------------|
| **Insert** | O(1) avg, O(n) worst | O(1) avg, O(n) worst | O(1) | O(1) at head |
| **Search** | O(1) avg, O(n) worst | O(1) avg, O(n) worst | O(n) | O(n) |
| **Delete** | O(1) avg, O(n) worst | O(1) avg, O(n) worst | O(n) | O(1) if node known |
| **Space** | O(n + m) | O(m) | O(n) | O(n) |

</div>

<div className="bg-green-50 p-4 rounded-lg border border-green-200 mb-6">
  <h3 className="text-green-800 font-semibold mb-2">üìä Khi n√†o s·ª≠ d·ª•ng Hash Table?</h3>
  <ul className="text-green-700 space-y-1">
    <li>‚Ä¢ C·∫ßn truy xu·∫•t nhanh theo key</li>
    <li>‚Ä¢ Implement database indexing</li>
    <li>‚Ä¢ Cache/memoization</li>
    <li>‚Ä¢ Counting/frequency analysis</li>
    <li>‚Ä¢ Set operations (union, intersection)</li>
  </ul>
</div>

## 6. ·ª®ng d·ª•ng th·ª±c t·∫ø

### 6.1 Word Frequency Counter

```rust
use std::collections::HashMap;

fn count_words(text: &str) -> HashMap<String, usize> {
    let mut word_count = HashMap::new();
    
    for word in text
        .split_whitespace()
        .map(|w| w.to_lowercase().trim_matches(|c: char| !c.is_alphabetic()))
        .filter(|w| !w.is_empty())
    {
        *word_count.entry(word.to_string()).or_insert(0) += 1;
    }
    
    word_count
}

fn main() {
    let text = "The quick brown fox jumps over the lazy dog. The fox is quick.";
    let counts = count_words(text);
    
    println!("Word frequencies:");
    for (word, count) in &counts {
        println!("{}: {}", word, count);
    }
}
```

### 6.2 LRU Cache Implementation

```rust
use std::collections::HashMap;
use std::ptr::NonNull;

struct Node<K, V> {
    key: K,
    value: V,
    prev: Option<NonNull<Node<K, V>>>,
    next: Option<NonNull<Node<K, V>>>,
}

struct LRUCache<K, V> {
    capacity: usize,
    map: HashMap<K, NonNull<Node<K, V>>>,
    head: Option<NonNull<Node<K, V>>>,
    tail: Option<NonNull<Node<K, V>>>,
}

impl<K, V> LRUCache<K, V> 
where
    K: Clone + std::hash::Hash + Eq,
    V: Clone,
{
    fn new(capacity: usize) -> Self {
        LRUCache {
            capacity,
            map: HashMap::new(),
            head: None,
            tail: None,
        }
    }
    
    fn get(&mut self, key: &K) -> Option<&V> {
        if let Some(&node_ptr) = self.map.get(key) {
            // Move to front (most recently used)
            self.move_to_front(node_ptr);
            unsafe { Some(&(*node_ptr.as_ptr()).value) }
        } else {
            None
        }
    }
    
    fn put(&mut self, key: K, value: V) {
        if let Some(&node_ptr) = self.map.get(&key) {
            // Update existing
            unsafe {
                (*node_ptr.as_ptr()).value = value;
            }
            self.move_to_front(node_ptr);
        } else {
            // Add new
            if self.map.len() >= self.capacity {
                self.remove_lru();
            }
            self.add_to_front(key, value);
        }
    }
    
    // Implementation details for move_to_front, remove_lru, add_to_front...
    // (Simplified for brevity)
}
```

## 7. T√≥m t·∫Øt

<div className="bg-blue-50 p-6 rounded-lg border border-blue-200">
  <h3 className="text-blue-800 font-bold mb-4">üéØ Ki·∫øn th·ª©c tr·ªçng t√¢m</h3>
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-blue-700">
    <div>
      <h4 className="font-semibold mb-2">Hash Function:</h4>
      <ul className="space-y-1 text-sm">
        <li>‚Ä¢ Chuy·ªÉn key th√†nh index</li>
        <li>‚Ä¢ Ph√¢n ph·ªëi ƒë·ªÅu, t√≠nh nhanh</li>
        <li>‚Ä¢ Division, Multiplication methods</li>
      </ul>
    </div>
    <div>
      <h4 className="font-semibold mb-2">Collision Handling:</h4>
      <ul className="space-y-1 text-sm">
        <li>‚Ä¢ Separate Chaining: linked lists</li>
        <li>‚Ä¢ Open Addressing: linear probing</li>
        <li>‚Ä¢ Trade-offs gi·ªØa memory v√† performance</li>
      </ul>
    </div>
  </div>
</div>

**Performance:** O(1) average case cho Insert/Search/Delete

**Applications:** Database indexing, Caching, Symbol tables, Set operations

---

## üöÄ B√†i t·∫≠p LeetCode li√™n quan

| B√†i | ƒê·ªô kh√≥ | M√¥ t·∫£ |
|-----|---------|-------|
| [1. Two Sum](https://leetcode.com/problems/two-sum/) | Easy | S·ª≠ d·ª•ng HashMap ƒë·ªÉ t√¨m c·∫∑p s·ªë |
| [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/) | Medium | Group strings b·∫±ng sorted string l√†m key |
| [128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) | Medium | D√πng HashSet ƒë·ªÉ t√¨m sequence |
| [146. LRU Cache](https://leetcode.com/problems/lru-cache/) | Medium | K·∫øt h·ª£p HashMap + Doubly Linked List |
| [387. First Unique Character](https://leetcode.com/problems/first-unique-character-in-a-string/) | Easy | Character frequency counting |
| [454. 4Sum II](https://leetcode.com/problems/4sum-ii/) | Medium | T·ªëi ∆∞u t·ª´ O(n‚Å¥) xu·ªëng O(n¬≤) |

---

<div className="text-center mt-8 p-4 bg-gray-50 rounded-lg">
  <div className="text-gray-600 font-medium">
    üìö <strong>B√†i ti·∫øp theo:</strong> B√†i 7 - Algorithmic Complexity Analysis
  </div>
</div>