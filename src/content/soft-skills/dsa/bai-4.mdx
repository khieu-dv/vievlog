# B√†i 4: Linked Lists - Danh s√°ch li√™n k·∫øt

## M·ª•c ti√™u h·ªçc t·∫≠p

Sau khi ho√†n th√†nh b√†i h·ªçc n√†y, b·∫°n s·∫Ω c√≥ kh·∫£ nƒÉng:
- Hi·ªÉu c·∫•u tr√∫c Node v√† c√°ch s·ª≠ d·ª•ng pointer/reference
- C√†i ƒë·∫∑t c√°c lo·∫°i Linked List c∆° b·∫£n
- Ph√¢n t√≠ch ∆∞u nh∆∞·ª£c ƒëi·ªÉm so v·ªõi Array
- Th·ª±c hi·ªán c√°c thao t√°c CRUD tr√™n Linked List

---

## 1. Gi·ªõi thi·ªáu v·ªÅ Linked List

### Kh√°i ni·ªám c∆° b·∫£n

<div className="bg-blue-50 border-l-4 border-blue-500 p-4 my-4">
  <h4 className="text-lg font-semibold text-blue-800">ƒê·ªãnh nghƒ©a</h4>
  <p className="text-blue-700">Linked List l√† c·∫•u tr√∫c d·ªØ li·ªáu tuy·∫øn t√≠nh trong ƒë√≥ c√°c ph·∫ßn t·ª≠ (node) ƒë∆∞·ª£c l∆∞u tr·ªØ trong c√°c v·ªã tr√≠ b·ªô nh·ªõ kh√¥ng li·ªÅn k·ªÅ v√† ƒë∆∞·ª£c li√™n k·∫øt v·ªõi nhau th√¥ng qua c√°c con tr·ªè (pointer) ho·∫∑c tham chi·∫øu (reference).</p>
</div>

### So s√°nh Linked List v·ªõi Array

| Ti√™u ch√≠ | Array | Linked List |
|----------|--------|-------------|
| **L∆∞u tr·ªØ b·ªô nh·ªõ** | Li·ªÅn k·ªÅ | Kh√¥ng li·ªÅn k·ªÅ |
| **Truy c·∫≠p ng·∫´u nhi√™n** | O(1) | O(n) |
| **Ch√®n/x√≥a ƒë·∫ßu** | O(n) | O(1) |
| **Ch√®n/x√≥a cu·ªëi** | O(1) | O(n) cho SLL, O(1) cho DLL |
| **Memory overhead** | Th·∫•p | Cao (do pointer) |
| **Cache performance** | T·ªët | K√©m |

---

## 2. C·∫•u tr√∫c Node

### Node c∆° b·∫£n

```rust
#[derive(Debug, Clone)]
struct Node<T> {
    data: T,
    next: Option<Box<Node<T>>>,
}

impl<T> Node<T> {
    fn new(data: T) -> Self {
        Node {
            data,
            next: None,
        }
    }
}
```

### Minh h·ªça c·∫•u tr√∫c Node

```mermaid
graph LR
    A[Node 1<br/>data: 10<br/>next: ‚Üí] --> B[Node 2<br/>data: 20<br/>next: ‚Üí]
    B --> C[Node 3<br/>data: 30<br/>next: None]
```

---

## 3. Singly Linked List

### C√†i ƒë·∫∑t SLL

```rust
#[derive(Debug)]
pub struct SinglyLinkedList<T> {
    head: Option<Box<Node<T>>>,
    size: usize,
}

impl<T: Clone> SinglyLinkedList<T> {
    pub fn new() -> Self {
        SinglyLinkedList {
            head: None,
            size: 0,
        }
    }

    // Ch√®n v√†o ƒë·∫ßu danh s√°ch - O(1)
    pub fn push_front(&mut self, data: T) {
        let new_node = Box::new(Node {
            data,
            next: self.head.take(),
        });
        self.head = Some(new_node);
        self.size += 1;
    }

    // X√≥a ph·∫ßn t·ª≠ ƒë·∫ßu - O(1)
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            self.size -= 1;
            node.data
        })
    }

    // T√¨m ki·∫øm - O(n)
    pub fn find(&self, target: &T) -> bool 
    where T: PartialEq {
        let mut current = &self.head;
        while let Some(node) = current {
            if node.data == *target {
                return true;
            }
            current = &node.next;
        }
        false
    }

    // Ch√®n t·∫°i v·ªã tr√≠ index - O(n)
    pub fn insert_at(&mut self, index: usize, data: T) -> Result<(), &'static str> {
        if index > self.size {
            return Err("Index out of bounds");
        }

        if index == 0 {
            self.push_front(data);
            return Ok(());
        }

        let mut current = &mut self.head;
        for _ in 0..index-1 {
            if let Some(node) = current {
                current = &mut node.next;
            }
        }

        if let Some(node) = current {
            let new_node = Box::new(Node {
                data,
                next: node.next.take(),
            });
            node.next = Some(new_node);
            self.size += 1;
        }

        Ok(())
    }

    pub fn len(&self) -> usize {
        self.size
    }

    pub fn is_empty(&self) -> bool {
        self.head.is_none()
    }
}
```

### Thao t√°c tr√™n SLL

<div className="overflow-x-auto">

| Thao t√°c | Time Complexity | Space Complexity | M√¥ t·∫£ |
|----------|-----------------|------------------|--------|
| **Insert Head** | O(1) | O(1) | Ch√®n v√†o ƒë·∫ßu danh s√°ch |
| **Insert Tail** | O(n) | O(1) | Ch√®n v√†o cu·ªëi danh s√°ch |
| **Insert Middle** | O(n) | O(1) | Ch√®n t·∫°i v·ªã tr√≠ b·∫•t k·ª≥ |
| **Delete Head** | O(1) | O(1) | X√≥a ph·∫ßn t·ª≠ ƒë·∫ßu |
| **Delete Tail** | O(n) | O(1) | X√≥a ph·∫ßn t·ª≠ cu·ªëi |
| **Search** | O(n) | O(1) | T√¨m ki·∫øm ph·∫ßn t·ª≠ |
| **Access** | O(n) | O(1) | Truy c·∫≠p theo index |

</div>

---

## 4. Doubly Linked List

### C·∫•u tr√∫c Node cho DLL

```rust
#[derive(Debug)]
struct DoublyNode<T> {
    data: T,
    next: Option<Box<DoublyNode<T>>>,
    prev: Option<*mut DoublyNode<T>>, // Raw pointer for prev to avoid cycle
}

#[derive(Debug)]
pub struct DoublyLinkedList<T> {
    head: Option<Box<DoublyNode<T>>>,
    tail: Option<*mut DoublyNode<T>>,
    size: usize,
}
```

### Minh h·ªça DLL

```mermaid
graph LR
    A[Node 1<br/>prev: None<br/>data: 10<br/>next: ‚Üí]
    B[Node 2<br/>prev: ‚Üê<br/>data: 20<br/>next: ‚Üí]
    C[Node 3<br/>prev: ‚Üê<br/>data: 30<br/>next: None]
    
    A -.->|next| B
    B -.->|prev| A
    B -.->|next| C
    C -.->|prev| B
```

### ∆Øu ƒëi·ªÉm c·ªßa DLL

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-4">
  <div className="bg-green-50 border border-green-200 rounded-lg p-4">
    <h4 className="font-semibold text-green-800 mb-2">‚úÖ ∆Øu ƒëi·ªÉm</h4>
    <ul className="text-green-700 text-sm space-y-1">
      <li>‚Ä¢ Duy·ªát hai chi·ªÅu (forward & backward)</li>
      <li>‚Ä¢ X√≥a node hi·ªán t·∫°i O(1)</li>
      <li>‚Ä¢ Insert/Delete tail O(1)</li>
      <li>‚Ä¢ Thu·∫≠n ti·ªán cho undo operations</li>
    </ul>
  </div>
  <div className="bg-red-50 border border-red-200 rounded-lg p-4">
    <h4 className="font-semibold text-red-800 mb-2">‚ùå Nh∆∞·ª£c ƒëi·ªÉm</h4>
    <ul className="text-red-700 text-sm space-y-1">
      <li>‚Ä¢ Memory overhead cao h∆°n</li>
      <li>‚Ä¢ C√†i ƒë·∫∑t ph·ª©c t·∫°p h∆°n</li>
      <li>‚Ä¢ Cache performance k√©m h∆°n</li>
    </ul>
  </div>
</div>

---

## 5. Circular Linked List

### ƒê·∫∑c ƒëi·ªÉm

<div className="bg-yellow-50 border-l-4 border-yellow-500 p-4 my-4">
  <p className="text-yellow-800">Trong Circular Linked List, node cu·ªëi c√πng tr·ªè v·ªÅ node ƒë·∫ßu ti√™n, t·∫°o th√†nh m·ªôt v√≤ng tr√≤n. ƒêi·ªÅu n√†y c√≥ √≠ch cho c√°c ·ª©ng d·ª•ng c·∫ßn l·∫∑p li√™n t·ª•c nh∆∞ round-robin scheduling.</p>
</div>

### Minh h·ªça CLL

```mermaid
graph LR
    A[Node 1<br/>data: 10] --> B[Node 2<br/>data: 20]
    B --> C[Node 3<br/>data: 30]
    C --> A
```

### C√†i ƒë·∫∑t CLL c∆° b·∫£n

```rust
impl<T: Clone> CircularLinkedList<T> {
    pub fn insert_after_current(&mut self, data: T) {
        if let Some(current) = &mut self.current {
            let new_node = Box::new(Node {
                data,
                next: current.next.take(),
            });
            current.next = Some(new_node);
            self.size += 1;
        }
    }

    pub fn move_next(&mut self) {
        if let Some(current) = self.current.take() {
            self.current = current.next;
        }
    }
}
```

---

## 6. Ph√¢n t√≠ch Performance

### Memory Layout Comparison

```mermaid
graph TD
    subgraph "Array Memory"
        A1[10] --- A2[20] --- A3[30] --- A4[40]
    end
    
    subgraph "Linked List Memory"
        B1["10 ‚Üí "] -.-> B2["20 ‚Üí "]
        B2 -.-> B3["30 ‚Üí "]
        B3 -.-> B4["40 ‚àÖ"]
    end
```

### Time Complexity Summary

<div className="overflow-x-auto">

| Operation | Array | Singly LL | Doubly LL | Circular LL |
|-----------|--------|-----------|-----------|-------------|
| **Access by index** | O(1) | O(n) | O(n) | O(n) |
| **Search** | O(n) | O(n) | O(n) | O(n) |
| **Insert head** | O(n) | O(1) | O(1) | O(1) |
| **Insert tail** | O(1) | O(n) | O(1) | O(1) |
| **Delete head** | O(n) | O(1) | O(1) | O(1) |
| **Delete tail** | O(1) | O(n) | O(1) | O(1) |
| **Delete middle** | O(n) | O(n) | O(1)* | O(n) |

</div>

*V·ªõi ƒëi·ªÅu ki·ªán bi·∫øt tr∆∞·ªõc node c·∫ßn x√≥a

---

## 7. ·ª®ng d·ª•ng th·ª±c t·∫ø

### Use Cases Map

| ·ª®ng d·ª•ng | Lo·∫°i LL ph√π h·ª£p | L√Ω do |
|----------|------------------|--------|
| **Browser History** | Doubly LL | C·∫ßn back/forward |
| **Music Playlist** | Circular LL | L·∫∑p li√™n t·ª•c |
| **Undo Operations** | Doubly LL | Undo/Redo |
| **Memory Management** | Singly LL | ƒê∆°n gi·∫£n, hi·ªáu qu·∫£ |
| **Process Scheduling** | Circular LL | Round-robin |
| **Stack Implementation** | Singly LL | Ch·ªâ c·∫ßn LIFO |

---

## 8. Code Example: Complete Implementation

```rust
fn main() {
    let mut list = SinglyLinkedList::new();
    
    // Test insertions
    list.push_front(30);
    list.push_front(20);
    list.push_front(10);
    
    println!("List size: {}", list.len()); // 3
    
    // Test search
    println!("Find 20: {}", list.find(&20)); // true
    println!("Find 40: {}", list.find(&40)); // false
    
    // Test insertion at index
    list.insert_at(1, 15).unwrap();
    println!("After insert at index 1, size: {}", list.len()); // 4
    
    // Test deletion
    if let Some(value) = list.pop_front() {
        println!("Popped: {}", value); // 10
    }
}
```

---

## 9. Best Practices v√† Tips

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
    <h4 className="font-semibold text-blue-800 mb-2">üí° Best Practices</h4>
    <ul className="text-blue-700 text-sm space-y-1">
      <li>‚Ä¢ Lu√¥n ki·ªÉm tra null pointer</li>
      <li>‚Ä¢ S·ª≠ d·ª•ng smart pointer (Box, Rc, Arc)</li>
      <li>‚Ä¢ C·∫≠p nh·∫≠t size counter</li>
      <li>‚Ä¢ Handle edge cases (empty list)</li>
    </ul>
  </div>
  <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
    <h4 className="font-semibold text-purple-800 mb-2">‚ö†Ô∏è Common Pitfalls</h4>
    <ul className="text-purple-700 text-sm space-y-1">
      <li>‚Ä¢ Memory leaks v·ªõi raw pointer</li>
      <li>‚Ä¢ Infinite loops trong CLL</li>
      <li>‚Ä¢ Kh√¥ng c·∫≠p nh·∫≠t tail pointer</li>
      <li>‚Ä¢ Race conditions trong multi-thread</li>
    </ul>
  </div>
</div>

---

## 10. B√†i t·∫≠p LeetCode li√™n quan

### Danh s√°ch b√†i t·∫≠p t·ª´ d·ªÖ ƒë·∫øn kh√≥

| STT | B√†i t·∫≠p | ƒê·ªô kh√≥ | K·ªπ nƒÉng |
|-----|---------|---------|---------|
| 1 | [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) | Easy | ƒê·∫£o ng∆∞·ª£c LL |
| 2 | [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | Easy | Merge LL |
| 3 | [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | Easy | Cycle detection |
| 4 | [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | Easy | Two pointers |
| 5 | [19. Remove Nth Node From End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | Medium | Two pointers |
| 6 | [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | Medium | Math + LL |
| 7 | [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) | Medium | Floyd's algorithm |
| 8 | [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) | Hard | Advanced reverse |

### G·ª£i √Ω approach:
- **Two Pointer Technique**: R·∫•t h·ªØu √≠ch cho cycle detection, middle node
- **Dummy Head**: ƒê∆°n gi·∫£n h√≥a edge cases
- **Iterative vs Recursive**: C√¢n nh·∫Øc stack overflow
- **Fast/Slow Pointers**: Floyd's Tortoise and Hare algorithm

---

## T√≥m t·∫Øt

Linked List l√† c·∫•u tr√∫c d·ªØ li·ªáu linh ho·∫°t v·ªõi ∆∞u ƒëi·ªÉm v·ªÅ dynamic memory allocation v√† insertion/deletion hi·ªáu qu·∫£. M·∫∑c d√π c√≥ nh∆∞·ª£c ƒëi·ªÉm v·ªÅ random access v√† cache performance, ch√∫ng v·∫´n r·∫•t h·ªØu √≠ch trong nhi·ªÅu scenario nh∆∞ implementing stacks, queues, v√† c√°c c·∫•u tr√∫c d·ªØ li·ªáu ph·ª©c t·∫°p kh√°c.

<div className="bg-gray-50 border border-gray-200 rounded-lg p-4 my-4">
  <h4 className="font-semibold text-gray-800 mb-2">üìù Key Takeaways</h4>
  <ul className="text-gray-700 text-sm space-y-1">
    <li>‚Ä¢ Linked List ph√π h·ª£p khi c·∫ßn insertion/deletion th∆∞·ªùng xuy√™n</li>
    <li>‚Ä¢ Array t·ªët h∆°n khi c·∫ßn random access</li>
    <li>‚Ä¢ Doubly LL trade memory cho flexibility</li>
    <li>‚Ä¢ Circular LL h·ªØu √≠ch cho cyclic operations</li>
  </ul>
</div>