# B√†i 4: Linked Lists - Danh s√°ch li√™n k·∫øt

## 1. Gi·ªõi thi·ªáu v·ªÅ Linked Lists

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
  <h3 className="text-lg font-semibold text-blue-800 mb-2">üí° ƒê·ªãnh nghƒ©a</h3>
  <p className="text-blue-700">Linked List l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu tuy·∫øn t√≠nh trong ƒë√≥ c√°c ph·∫ßn t·ª≠ ƒë∆∞·ª£c l∆∞u tr·ªØ trong c√°c node, m·ªói node ch·ª©a d·ªØ li·ªáu v√† m·ªôt con tr·ªè (pointer) tr·ªè ƒë·∫øn node ti·∫øp theo.</p>
</div>

### ƒê·∫∑c ƒëi·ªÉm ch√≠nh:

- **B·ªô nh·ªõ kh√¥ng li·ªÅn k·ªÅ**: C√°c node c√≥ th·ªÉ n·∫±m ·ªü b·∫•t k·ª≥ v·ªã tr√≠ n√†o trong b·ªô nh·ªõ
- **K√≠ch th∆∞·ªõc linh ho·∫°t**: C√≥ th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc trong qu√° tr√¨nh ch·∫°y
- **Truy c·∫≠p tu·∫ßn t·ª±**: Ph·∫£i duy·ªát t·ª´ node ƒë·∫ßu ƒë·∫øn node c·∫ßn truy c·∫≠p

## 2. C·∫•u tr√∫c Node

```mermaid
graph LR
    A[data | next] --> B[data | next] --> C[data | NULL]
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#e1f5fe
```

### C√†i ƒë·∫∑t Node trong C++:

```cpp
struct Node {
    int data;      // D·ªØ li·ªáu c·ªßa node
    Node* next;    // Con tr·ªè tr·ªè ƒë·∫øn node ti·∫øp theo

    // Constructor
    Node(int value) : data(value), next(nullptr) {}
};
```

## 3. So s√°nh Array vs Linked List

| Ti√™u ch√≠                | Array        | Linked List    |
| ----------------------- | ------------ | -------------- |
| **B·ªô nh·ªõ**              | Li·ªÅn k·ªÅ      | R·∫£i r√°c        |
| **Truy c·∫≠p ng·∫´u nhi√™n** | O(1)         | O(n)           |
| **Ch√®n/X√≥a ƒë·∫ßu**        | O(n)         | O(1)           |
| **Ch√®n/X√≥a cu·ªëi**       | O(1)         | O(n)           |
| **S·ª≠ d·ª•ng b·ªô nh·ªõ**      | Ch·ªâ l∆∞u data | Data + pointer |
| **Cache performance**   | T·ªët          | K√©m            |

## 4. Singly Linked List

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
  <h3 className="text-green-800 font-semibold mb-3">üîó Singly Linked List</h3>
  <p className="text-green-700">M·ªói node ch·ªâ c√≥ m·ªôt con tr·ªè next tr·ªè ƒë·∫øn node ti·∫øp theo. Node cu·ªëi c√πng c√≥ next = nullptr.</p>
</div>

```mermaid
graph LR
    head[HEAD] --> A[10 | ‚Ä¢] --> B[20 | ‚Ä¢] --> C[30 | ‚Ä¢] --> D[NULL]
    style head fill:#ffcdd2
    style A fill:#c8e6c9
    style B fill:#c8e6c9
    style C fill:#c8e6c9
```

### C√†i ƒë·∫∑t Singly Linked List:

```cpp
class SinglyLinkedList {
private:
    Node* head;
    int size;

public:
    // Constructor
    SinglyLinkedList() : head(nullptr), size(0) {}

    // Destructor
    ~SinglyLinkedList() {
        clear();
    }

    // Ch√®n node v√†o ƒë·∫ßu danh s√°ch - O(1)
    void insertAtHead(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
        size++;
    }

    // Ch√®n node v√†o cu·ªëi danh s√°ch - O(n)
    void insertAtTail(int value) {
        Node* newNode = new Node(value);

        if (head == nullptr) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
        size++;
    }

    // Ch√®n node t·∫°i v·ªã tr√≠ index - O(n)
    bool insertAt(int index, int value) {
        if (index < 0 || index > size) return false;

        if (index == 0) {
            insertAtHead(value);
            return true;
        }

        Node* newNode = new Node(value);
        Node* temp = head;

        for (int i = 0; i < index - 1; i++) {
            temp = temp->next;
        }

        newNode->next = temp->next;
        temp->next = newNode;
        size++;
        return true;
    }

    // X√≥a node ƒë·∫ßu danh s√°ch - O(1)
    bool deleteHead() {
        if (head == nullptr) return false;

        Node* temp = head;
        head = head->next;
        delete temp;
        size--;
        return true;
    }

    // X√≥a node c√≥ gi√° tr·ªã value - O(n)
    bool deleteValue(int value) {
        if (head == nullptr) return false;

        // N·∫øu node ƒë·∫ßu ch·ª©a gi√° tr·ªã c·∫ßn x√≥a
        if (head->data == value) {
            return deleteHead();
        }

        Node* current = head;
        while (current->next != nullptr) {
            if (current->next->data == value) {
                Node* temp = current->next;
                current->next = temp->next;
                delete temp;
                size--;
                return true;
            }
            current = current->next;
        }
        return false;
    }

    // T√¨m ki·∫øm gi√° tr·ªã - O(n)
    int search(int value) {
        Node* temp = head;
        int index = 0;

        while (temp != nullptr) {
            if (temp->data == value) {
                return index;
            }
            temp = temp->next;
            index++;
        }
        return -1; // Kh√¥ng t√¨m th·∫•y
    }

    // In danh s√°ch
    void display() {
        Node* temp = head;
        while (temp != nullptr) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }

    // L·∫•y k√≠ch th∆∞·ªõc
    int getSize() const { return size; }

    // Ki·ªÉm tra r·ªóng
    bool isEmpty() const { return head == nullptr; }

    // X√≥a to√†n b·ªô danh s√°ch
    void clear() {
        while (head != nullptr) {
            deleteHead();
        }
    }
};
```

## 5. Doubly Linked List

<div className="bg-purple-50 border border-purple-200 rounded-lg p-4 mb-6">
  <h3 className="text-purple-800 font-semibold mb-3">üîó Doubly Linked List</h3>
  <p className="text-purple-700">M·ªói node c√≥ hai con tr·ªè: prev tr·ªè v·ªÅ node tr∆∞·ªõc v√† next tr·ªè ƒë·∫øn node sau. Cho ph√©p duy·ªát theo c·∫£ hai h∆∞·ªõng.</p>
</div>

```mermaid
graph LR
    head[HEAD] -.-> A
    A[‚Ä¢ | 10 | ‚Ä¢] <--> B[‚Ä¢ | 20 | ‚Ä¢] <--> C[‚Ä¢ | 30 | ‚Ä¢]
    C -.-> tail[TAIL]
    style head fill:#ffcdd2
    style tail fill:#ffcdd2
    style A fill:#e1bee7
    style B fill:#e1bee7
    style C fill:#e1bee7
```

### C√†i ƒë·∫∑t Node cho Doubly Linked List:

```cpp
struct DoublyNode {
    int data;
    DoublyNode* prev;
    DoublyNode* next;

    DoublyNode(int value) : data(value), prev(nullptr), next(nullptr) {}
};
```

### C√†i ƒë·∫∑t Doubly Linked List:

```cpp
class DoublyLinkedList {
private:
    DoublyNode* head;
    DoublyNode* tail;
    int size;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}

    // Ch√®n v√†o ƒë·∫ßu - O(1)
    void insertAtHead(int value) {
        DoublyNode* newNode = new DoublyNode(value);

        if (head == nullptr) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
        size++;
    }

    // Ch√®n v√†o cu·ªëi - O(1)
    void insertAtTail(int value) {
        DoublyNode* newNode = new DoublyNode(value);

        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
        size++;
    }

    // X√≥a node ƒë·∫ßu - O(1)
    bool deleteHead() {
        if (head == nullptr) return false;

        if (head == tail) {
            delete head;
            head = tail = nullptr;
        } else {
            DoublyNode* temp = head;
            head = head->next;
            head->prev = nullptr;
            delete temp;
        }
        size--;
        return true;
    }

    // X√≥a node cu·ªëi - O(1)
    bool deleteTail() {
        if (tail == nullptr) return false;

        if (head == tail) {
            delete tail;
            head = tail = nullptr;
        } else {
            DoublyNode* temp = tail;
            tail = tail->prev;
            tail->next = nullptr;
            delete temp;
        }
        size--;
        return true;
    }

    // Duy·ªát t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi
    void displayForward() {
        DoublyNode* temp = head;
        while (temp != nullptr) {
            cout << temp->data << " <-> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }

    // Duy·ªát t·ª´ cu·ªëi v·ªÅ ƒë·∫ßu
    void displayBackward() {
        DoublyNode* temp = tail;
        while (temp != nullptr) {
            cout << temp->data << " <-> ";
            temp = temp->prev;
        }
        cout << "NULL" << endl;
    }
};
```

## 6. Circular Linked List

<div className="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-6">
  <h3 className="text-orange-800 font-semibold mb-3">üîÑ Circular Linked List</h3>
  <p className="text-orange-700">Node cu·ªëi c√πng tr·ªè v·ªÅ node ƒë·∫ßu ti√™n, t·∫°o th√†nh m·ªôt v√≤ng tr√≤n. Kh√¥ng c√≥ node n√†o c√≥ next = nullptr.</p>
</div>

```mermaid
graph LR
    A[10 | ‚Ä¢] --> B[20 | ‚Ä¢] --> C[30 | ‚Ä¢] --> A
    style A fill:#ffe0b2
    style B fill:#ffe0b2
    style C fill:#ffe0b2
```

## 7. B·∫£ng t√≥m t·∫Øt ƒë·ªô ph·ª©c t·∫°p

| Thao t√°c             | Singly LL | Doubly LL | Array |
| -------------------- | --------- | --------- | ----- |
| **Truy c·∫≠p ph·∫ßn t·ª≠** | O(n)      | O(n)      | O(1)  |
| **T√¨m ki·∫øm**         | O(n)      | O(n)      | O(n)  |
| **Ch√®n ƒë·∫ßu**         | O(1)      | O(1)      | O(n)  |
| **Ch√®n cu·ªëi**        | O(n)      | O(1)      | O(1)  |
| **Ch√®n gi·ªØa**        | O(n)      | O(n)      | O(n)  |
| **X√≥a ƒë·∫ßu**          | O(1)      | O(1)      | O(n)  |
| **X√≥a cu·ªëi**         | O(n)      | O(1)      | O(1)  |
| **X√≥a gi·ªØa**         | O(n)      | O(1)\*    | O(n)  |

\*V·ªõi ƒëi·ªÅu ki·ªán ƒë√£ c√≥ con tr·ªè ƒë·∫øn node c·∫ßn x√≥a

## 8. ·ª®ng d·ª•ng th·ª±c t·∫ø

### Music Playlist (Doubly Linked List)

```cpp
struct Song {
    string title;
    string artist;
    Song* prev;
    Song* next;

    Song(string t, string a) : title(t), artist(a), prev(nullptr), next(nullptr) {}
};

class MusicPlaylist {
    Song* current;
    // C√°c method: play(), next(), previous(), addSong(), removeSong()
};
```

### Undo/Redo Functionality (Doubly Linked List)

```cpp
class UndoRedoSystem {
    DoublyNode* currentState;
    // Methods: performAction(), undo(), redo()
};
```

## 9. B√†i t·∫≠p LeetCode li√™n quan

<div className="bg-red-50 border border-red-200 rounded-lg p-4">
  <h3 className="text-red-800 font-semibold mb-3">üéØ B√†i t·∫≠p th·ª±c h√†nh</h3>
  
| ƒê·ªô kh√≥ | Problem | Link |
|--------|---------|------|
| Easy | 21. Merge Two Sorted Lists | https://leetcode.com/problems/merge-two-sorted-lists/ |
| Easy | 206. Reverse Linked List | https://leetcode.com/problems/reverse-linked-list/ |
| Easy | 83. Remove Duplicates from Sorted List | https://leetcode.com/problems/remove-duplicates-from-sorted-list/ |
| Medium | 2. Add Two Numbers | https://leetcode.com/problems/add-two-numbers/ |
| Medium | 19. Remove Nth Node From End of List | https://leetcode.com/problems/remove-nth-node-from-end-of-list/ |
| Medium | 143. Reorder List | https://leetcode.com/problems/reorder-list/ |
| Medium | 24. Swap Nodes in Pairs | https://leetcode.com/problems/swap-nodes-in-pairs/ |
| Hard | 25. Reverse Nodes in k-Group | https://leetcode.com/problems/reverse-nodes-in-k-group/ |

</div>

## 10. K·∫øt lu·∫≠n

### Khi n√†o s·ª≠ d·ª•ng Linked List:

- **K√≠ch th∆∞·ªõc d·ªØ li·ªáu kh√¥ng bi·∫øt tr∆∞·ªõc** v√† thay ƒë·ªïi th∆∞·ªùng xuy√™n
- **Thao t√°c ch√®n/x√≥a ·ªü ƒë·∫ßu danh s√°ch** nhi·ªÅu
- **Kh√¥ng c·∫ßn truy c·∫≠p ng·∫´u nhi√™n** ƒë·∫øn c√°c ph·∫ßn t·ª≠
- **C·∫ßn ti·∫øt ki·ªám b·ªô nh·ªõ** (kh√¥ng c·∫ßn c·∫•p ph√°t tr∆∞·ªõc)

### Khi n√†o kh√¥ng n√™n s·ª≠ d·ª•ng:

- C·∫ßn **truy c·∫≠p ng·∫´u nhi√™n** th∆∞·ªùng xuy√™n
- **Cache performance** quan tr·ªçng
- B·ªô nh·ªõ h·∫°n ch·∫ø (overhead c·ªßa pointer)
- C·∫ßn **binary search** tr√™n d·ªØ li·ªáu ƒë√£ s·∫Øp x·∫øp

<div className="bg-gray-100 border-l-4 border-gray-400 p-4 mt-6">
  <p className="text-gray-700 italic">üí° <strong>Tip:</strong> Trong th·ª±c t·∫ø, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng std::list (doubly linked) ho·∫∑c std::forward_list (singly linked) c·ªßa C++ STL thay v√¨ t·ª± c√†i ƒë·∫∑t, tr·ª´ khi c·∫ßn customization ƒë·∫∑c bi·ªát.</p>
</div>
