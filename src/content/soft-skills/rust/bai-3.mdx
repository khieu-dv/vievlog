# B√†i 3: Ki·ªÉu D·ªØ Li·ªáu C∆° B·∫£n

<div className="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-400 mb-8">
  <h2 className="text-xl font-bold text-blue-800 mb-2">üéØ M·ª•c Ti√™u B√†i H·ªçc</h2>
  <div className="text-blue-700">L√†m ch·ªß c√°c ki·ªÉu d·ªØ li·ªáu scalar v√† compound trong Rust, hi·ªÉu c√°ch Rust qu·∫£n l√Ω memory v√† th·ª±c hi·ªán type checking.</div>
</div>

## üìö T·ªïng Quan

Rust l√† ng√¥n ng·ªØ **statically typed**, nghƒ©a l√† t·∫•t c·∫£ c√°c bi·∫øn ph·∫£i c√≥ ki·ªÉu d·ªØ li·ªáu ƒë∆∞·ª£c x√°c ƒë·ªãnh t·∫°i compile time. Rust c√≥ hai lo·∫°i ki·ªÉu d·ªØ li·ªáu ch√≠nh:
- **Scalar types**: ƒê·∫°i di·ªán cho m·ªôt gi√° tr·ªã ƒë∆°n
- **Compound types**: Nh√≥m nhi·ªÅu gi√° tr·ªã th√†nh m·ªôt ki·ªÉu

```mermaid
graph TD
    A[Ki·ªÉu D·ªØ Li·ªáu Rust] --> B[Scalar Types]
    A --> C[Compound Types]
    B --> D[Integer]
    B --> E[Float]
    B --> F[Boolean]
    B --> G[Character]
    C --> H[Tuple]
    C --> I[Array]
```

## üî¢ Scalar Types

### Integer Types

Rust cung c·∫•p nhi·ªÅu ki·ªÉu s·ªë nguy√™n v·ªõi k√≠ch th∆∞·ªõc v√† d·∫•u kh√°c nhau:

| ƒê·ªô d√†i | Signed | Unsigned |
|---------|---------|-----------|
| 8-bit | `i8` | `u8` |
| 16-bit | `i16` | `u16` |
| 32-bit | `i32` | `u32` |
| 64-bit | `i64` | `u64` |
| 128-bit | `i128` | `u128` |
| arch | `isize` | `usize` |

<div className="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-400 my-4">
  <h4 className="font-bold text-yellow-800">üí° L∆∞u √ù</h4>
  <div className="text-yellow-700">
    ‚Ä¢ <code>isize</code> v√† <code>usize</code> ph·ª• thu·ªôc v√†o ki·∫øn tr√∫c m√°y (32-bit ho·∫∑c 64-bit)<br/>
    ‚Ä¢ Ki·ªÉu m·∫∑c ƒë·ªãnh cho integer l√† <code>i32</code><br/>
    ‚Ä¢ S·ª≠ d·ª•ng <code>usize</code> cho indexing
  </div>
</div>

#### C√°c C√°ch Vi·∫øt Integer Literals

| ƒê·ªãnh d·∫°ng | V√≠ d·ª• |
|-----------|--------|
| Decimal | `98_222` |
| Hex | `0xff` |
| Octal | `0o77` |
| Binary | `0b1111_0000` |
| Byte (u8 only) | `b'A'` |

```rust
fn main() {
    // C√°c c√°ch khai b√°o integer
    let decimal = 98_222;
    let hex = 0xff;
    let octal = 0o77;
    let binary = 0b1111_0000;
    let byte = b'A';
    
    // Type annotation
    let x: u8 = 255;
    let y: i32 = -100_000;
}
```

### Float Types

Rust c√≥ hai ki·ªÉu s·ªë th·ª±c:

| Ki·ªÉu | K√≠ch th∆∞·ªõc | ƒê·ªô ch√≠nh x√°c |
|------|------------|---------------|
| `f32` | 32-bit | Single precision |
| `f64` | 64-bit | Double precision |

<div className="bg-green-50 p-4 rounded-lg border-l-4 border-green-400 my-4">
  <h4 className="font-bold text-green-800">‚úÖ Best Practice</h4>
  <div className="text-green-700">
    M·∫∑c ƒë·ªãnh s·ª≠ d·ª•ng <code>f64</code> v√¨ t·ªëc ƒë·ªô t∆∞∆°ng t·ª± <code>f32</code> nh∆∞ng ƒë·ªô ch√≠nh x√°c cao h∆°n.
  </div>
</div>

```rust
fn main() {
    let x = 2.0; // f64 m·∫∑c ƒë·ªãnh
    let y: f32 = 3.0; // f32 explicit
    
    // Floating point operations
    let sum = x + y as f64;
    let difference = 95.5 - 4.3;
    let product = 4.0 * 30.0;
    let quotient = 56.7 / 32.2;
}
```

### Boolean Type

```rust
fn main() {
    let t = true;
    let f: bool = false; // v·ªõi type annotation
    
    // Boolean operations
    let is_greater = 5 > 3;  // true
    let is_equal = 4 == 4;   // true
}
```

### Character Type

Ki·ªÉu `char` trong Rust l√† Unicode Scalar Value (4 bytes):

```rust
fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // v·ªõi type annotation
    let heart_eyed_cat = 'üòª';
    
    println!("Character: {}", c);
    println!("Unicode: {}", z);
    println!("Emoji: {}", heart_eyed_cat);
}
```

## üîó Compound Types

### Tuples

Tuple nh√≥m c√°c gi√° tr·ªã c√≥ ki·ªÉu kh√°c nhau th√†nh m·ªôt compound type:

```mermaid
graph LR
    A[Tuple] --> B[Element 0]
    A --> C[Element 1]
    A --> D[Element 2]
    A --> E[... Element n]
```

```rust
fn main() {
    // Khai b√°o tuple
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    
    // Destructuring
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
    
    // Access b·∫±ng index
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
    
    // Empty tuple (unit type)
    let unit = ();
}
```

#### ·ª®ng D·ª•ng Th·ª±c T·∫ø c·ªßa Tuple

| Use Case | V√≠ d·ª• |
|----------|-------|
| Return multiple values | `fn get_name_age() -> (String, u8)` |
| Coordinate system | `(x: f64, y: f64)` |
| RGB colors | `(r: u8, g: u8, b: u8)` |

### Arrays

Array c√≥ fixed size v√† t·∫•t c·∫£ elements c√πng ki·ªÉu:

```rust
fn main() {
    // Khai b√°o array
    let a = [1, 2, 3, 4, 5];
    let months = ["January", "February", "March"];
    
    // Type annotation
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    
    // Initialize v·ªõi gi√° tr·ªã gi·ªëng nhau
    let a = [3; 5]; // [3, 3, 3, 3, 3]
    
    // Access elements
    let first = a[0];
    let second = a[1];
}
```

#### So S√°nh Array vs Vector

| ƒê·∫∑c ƒëi·ªÉm | Array | Vector |
|----------|-------|---------|
| Size | Fixed t·∫°i compile time | Dynamic |
| Memory | Stack | Heap |
| Performance | Faster access | Slower nh∆∞ng flexible |
| Use case | Known size | Unknown/changing size |

```mermaid
graph TB
    A[Data Structure Choice] --> B{Size known at compile time?}
    B -->|Yes| C[Use Array]
    B -->|No| D[Use Vector]
    C --> E[Stack allocated<br/>Fixed size<br/>Faster access]
    D --> F[Heap allocated<br/>Dynamic size<br/>More flexible]
```

## üîÑ Type Inference v√† Type Annotation

### Type Inference

Rust c√≥ th·ªÉ t·ª± ƒë·ªông suy lu·∫≠n ki·ªÉu d·ªØ li·ªáu:

```rust
fn main() {
    let x = 5; // Rust infer x l√† i32
    let y = 2.5; // Rust infer y l√† f64
    let is_ready = true; // Rust infer l√† bool
}
```

### Explicit Type Annotation

Khi c·∫ßn thi·∫øt, ch√∫ng ta ph·∫£i ch·ªâ ƒë·ªãnh ki·ªÉu r√µ r√†ng:

```rust
fn main() {
    let guess: u32 = "42".parse().expect("Not a number!");
    let numbers: Vec<i32> = vec![1, 2, 3];
}
```

## üîÑ Type Casting

### Explicit Casting v·ªõi `as`

```rust
fn main() {
    let x = 10i32;
    let y = 20u32;
    
    // Cast i32 to u32
    let sum = y + x as u32;
    
    // Float to integer (truncation)
    let pi = 3.14159f64;
    let integer_pi = pi as i32; // 3
    
    // Casting c√≥ th·ªÉ m·∫•t d·ªØ li·ªáu
    let large_number = 300u16;
    let small_number = large_number as u8; // 44 (300 - 256)
}
```

<div className="bg-red-50 p-4 rounded-lg border-l-4 border-red-400 my-4">
  <h4 className="font-bold text-red-800">‚ö†Ô∏è C·∫£nh B√°o</h4>
  <div className="text-red-700">
    Type casting c√≥ th·ªÉ g√¢y m·∫•t d·ªØ li·ªáu ho·∫∑c overflow. Lu√¥n ki·ªÉm tra bounds khi c·∫ßn thi·∫øt.
  </div>
</div>

### Overflow Behavior

| Build Mode | Behavior |
|------------|----------|
| Debug | Panic khi overflow |
| Release | Two's complement wrapping |

```rust
fn main() {
    let mut x: u8 = 255;
    x += 1; // Debug: panic, Release: x = 0
    
    // Explicit wrapping
    let y = 255u8.wrapping_add(1); // 0
    let z = 255u8.saturating_add(1); // 255
    let (result, overflow) = 255u8.overflowing_add(1); // (0, true)
}
```

## üßÆ Th·ª±c H√†nh: Calculator ƒê∆°n Gi·∫£n

H√£y x√¢y d·ª±ng m·ªôt calculator s·ª≠ d·ª•ng c√°c ki·ªÉu d·ªØ li·ªáu ƒë√£ h·ªçc:

```rust
fn main() {
    // Input values v·ªõi different types
    let a: f64 = 10.5;
    let b: f64 = 3.2;
    let operation: char = '+';
    
    // Calculations
    let result = match operation {
        '+' => a + b,
        '-' => a - b,
        '*' => a * b,
        '/' => {
            if b != 0.0 {
                a / b
            } else {
                f64::NAN
            }
        },
        _ => {
            println!("Unknown operation: {}", operation);
            f64::NAN
        }
    };
    
    // Display result
    println!("{} {} {} = {}", a, operation, b, result);
    
    // Type casting example
    let integer_result = result as i32;
    println!("Integer result: {}", integer_result);
    
    // Working v·ªõi tuples
    let calculation: (f64, char, f64, f64) = (a, operation, b, result);
    println!("Calculation tuple: {:?}", calculation);
    
    // Array of results
    let results: [f64; 4] = [
        a + b,
        a - b,
        a * b,
        if b != 0.0 { a / b } else { 0.0 }
    ];
    
    println!("All operations: {:?}", results);
}
```

## üìã B·∫£ng T√≥m T·∫Øt

### Memory Layout

| Type Category | Stack/Heap | Size |
|---------------|------------|------|
| Scalar types | Stack | Fixed, known at compile time |
| Tuples | Stack | Sum of all elements |
| Arrays | Stack | Element size √ó length |

### Type Conversion Methods

| Method | Description | Example |
|--------|-------------|---------|
| `as` | Explicit cast | `10i32 as u32` |
| `.into()` | Generic conversion | `"hello".into()` |
| `.from()` | Constructor conversion | `String::from("hello")` |
| `.parse()` | String to number | `"42".parse::<i32>()` |

<div className="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-400 mt-8">
  <h2 className="text-xl font-bold text-blue-800 mb-2">üìù T√≥m T·∫Øt</h2>
  <ul className="text-blue-700 space-y-1">
    <li>‚Ä¢ Rust c√≥ scalar types (integer, float, bool, char) v√† compound types (tuple, array)</li>
    <li>‚Ä¢ Type inference m·∫°nh m·∫Ω nh∆∞ng ƒë√¥i khi c·∫ßn type annotation</li>
    <li>‚Ä¢ Arrays c√≥ fixed size, tuples c√≥ th·ªÉ ch·ª©a c√°c ki·ªÉu kh√°c nhau</li>
    <li>‚Ä¢ Type casting c·∫ßn c·∫©n th·∫≠n v·ªõi overflow v√† data loss</li>
    <li>‚Ä¢ Memory safety ƒë∆∞·ª£c ƒë·∫£m b·∫£o th√¥ng qua type system</li>
  </ul>
</div>

## üöÄ B√†i T·∫≠p Th·ª±c H√†nh

1. **C∆° B·∫£n**: Vi·∫øt ch∆∞∆°ng tr√¨nh chuy·ªÉn ƒë·ªïi nhi·ªát ƒë·ªô gi·ªØa Celsius v√† Fahrenheit
2. **Trung B√¨nh**: T·∫°o m·ªôt struct ƒë·ªÉ represent m·ªôt ƒëi·ªÉm 2D v√† t√≠nh kho·∫£ng c√°ch
3. **N√¢ng Cao**: Implement m·ªôt simple polynomial calculator s·ª≠ d·ª•ng arrays

## üìñ Chu·∫©n B·ªã Cho B√†i Ti·∫øp Theo

B√†i 4 s·∫Ω h·ªçc v·ªÅ **Control Flow v√† Functions** - c√°ch ƒëi·ªÅu khi·ªÉn lu·ªìng ch∆∞∆°ng tr√¨nh v√† t·∫°o functions t√°i s·ª≠ d·ª•ng.