# BÃ€I 3: KIá»‚U Dá»® LIá»†U CÆ  Báº¢N

<div className="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6 rounded-lg shadow-lg mb-8">
  <h2 className="text-2xl font-bold mb-2">ğŸ¯ Má»¤C TIÃŠU BÃ€I Há»ŒC</h2>
  <p className="text-lg">LÃ m chá»§ cÃ¡c kiá»ƒu dá»¯ liá»‡u scalar vÃ  compound trong Rust Ä‘á»ƒ xÃ¢y dá»±ng ná»n táº£ng vá»¯ng cháº¯c cho viá»‡c láº­p trÃ¬nh hiá»‡u quáº£</p>
</div>

## ğŸ“‹ Ná»˜I DUNG CHÃNH

```mermaid
graph TD
    A[Kiá»ƒu Dá»¯ Liá»‡u Rust] --> B[Scalar Types]
    A --> C[Compound Types]
    B --> D[Integers]
    B --> E[Floats]
    B --> F[Boolean]
    B --> G[Character]
    C --> H[Tuples]
    C --> I[Arrays]
    D --> J[Signed: i8, i16, i32, i64, i128, isize]
    D --> K[Unsigned: u8, u16, u32, u32, u64, u128, usize]
```

---

## ğŸ”¢ 1. SCALAR TYPES (KIá»‚U VÃ” HÆ¯á»šNG)

### 1.1 Integer Types (Kiá»ƒu Sá»‘ NguyÃªn)

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-2xl">ğŸ’¡</span>
    </div>
    <div className="ml-3">
      <p className="text-sm text-yellow-700">
        <strong>LÆ°u Ã½:</strong> Rust cÃ³ há»‡ thá»‘ng kiá»ƒu sá»‘ nguyÃªn ráº¥t phong phÃº vá»›i cáº£ signed (cÃ³ dáº¥u) vÃ  unsigned (khÃ´ng dáº¥u)
      </p>
    </div>
  </div>
</div>

| Kiá»ƒu | KÃ­ch thÆ°á»›c | Pháº¡m vi giÃ¡ trá»‹ | VÃ­ dá»¥ |
|------|------------|----------------|-------|
| `i8` | 8 bit | -128 Ä‘áº¿n 127 | `let x: i8 = -42;` |
| `i16` | 16 bit | -32,768 Ä‘áº¿n 32,767 | `let y: i16 = 1000;` |
| `i32` | 32 bit | -2Â³Â¹ Ä‘áº¿n 2Â³Â¹-1 | `let z = 42;` (máº·c Ä‘á»‹nh) |
| `i64` | 64 bit | -2â¶Â³ Ä‘áº¿n 2â¶Â³-1 | `let big: i64 = 1_000_000;` |
| `i128` | 128 bit | -2Â¹Â²â· Ä‘áº¿n 2Â¹Â²â·-1 | `let huge: i128 = 123;` |
| `isize` | arch | Phá»¥ thuá»™c kiáº¿n trÃºc | `let idx: isize = -1;` |

| Kiá»ƒu | KÃ­ch thÆ°á»›c | Pháº¡m vi giÃ¡ trá»‹ | VÃ­ dá»¥ |
|------|------------|----------------|-------|
| `u8` | 8 bit | 0 Ä‘áº¿n 255 | `let byte: u8 = 255;` |
| `u16` | 16 bit | 0 Ä‘áº¿n 65,535 | `let port: u16 = 8080;` |
| `u32` | 32 bit | 0 Ä‘áº¿n 2Â³Â²-1 | `let count: u32 = 42;` |
| `u64` | 64 bit | 0 Ä‘áº¿n 2â¶â´-1 | `let id: u64 = 12345;` |
| `u128` | 128 bit | 0 Ä‘áº¿n 2Â¹Â²â¸-1 | `let massive: u128 = 999;` |
| `usize` | arch | Phá»¥ thuá»™c kiáº¿n trÃºc | `let len: usize = 10;` |

#### VÃ­ dá»¥ thá»±c táº¿:

```rust copy
fn main() {
    // Integer literals vá»›i suffix
    let decimal = 98_222;          // Decimal
    let hex = 0xff;                // Hexadecimal
    let octal = 0o77;              // Octal
    let binary = 0b1111_0000;      // Binary
    let byte = b'A';               // Byte (u8 only)
    
    // Type annotation
    let x: u32 = 42;
    let y: i64 = -1000;
    
    println!("decimal: {}, hex: {}, octal: {}", decimal, hex, octal);
}
```

### 1.2 Floating-Point Types (Kiá»ƒu Sá»‘ Thá»±c)

| Kiá»ƒu | KÃ­ch thÆ°á»›c | Äá»™ chÃ­nh xÃ¡c | VÃ­ dá»¥ |
|------|------------|-------------|-------|
| `f32` | 32 bit | Single precision | `let x: f32 = 3.14;` |
| `f64` | 64 bit | Double precision | `let y = 2.71828;` (máº·c Ä‘á»‹nh) |

```rust copy
fn main() {
    let x = 2.0;        // f64 (máº·c Ä‘á»‹nh)
    let y: f32 = 3.0;   // f32
    
    // CÃ¡c phÃ©p toÃ¡n cÆ¡ báº£n
    let sum = x + y as f64;
    let difference = x - 1.5;
    let product = x * 2.5;
    let quotient = x / 2.0;
    
    println!("Káº¿t quáº£: {}", sum);
}
```

### 1.3 Boolean Type

```rust copy
fn main() {
    let t = true;
    let f: bool = false;
    
    // Sá»­ dá»¥ng trong Ä‘iá»u kiá»‡n
    if t {
        println!("Äiá»u kiá»‡n Ä‘Ãºng!");
    }
    
    // CÃ¡c phÃ©p toÃ¡n logic
    let and_result = t && f;    // false
    let or_result = t || f;     // true
    let not_result = !t;        // false
}
```

### 1.4 Character Type

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-2xl">ğŸŒŸ</span>
    </div>
    <div className="ml-3">
      <p className="text-sm text-blue-700">
        <strong>Äáº·c biá»‡t:</strong> Rust sá»­ dá»¥ng UTF-8 encoding, char cÃ³ kÃ­ch thÆ°á»›c 4 bytes vÃ  cÃ³ thá»ƒ chá»©a báº¥t ká»³ kÃ½ tá»± Unicode nÃ o
      </p>
    </div>
  </div>
</div>

```rust copy
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
    let vietnamese = 'áº¡';
    
    println!("Characters: {}, {}, {}, {}", c, z, heart_eyed_cat, vietnamese);
}
```

---

## ğŸ”— 2. COMPOUND TYPES (KIá»‚U PHá»¨C Há»¢P)

```mermaid
graph LR
    A[Compound Types] --> B[Tuples]
    A --> C[Arrays]
    B --> D[Heterogeneous Data]
    B --> E[Fixed Length]
    C --> F[Homogeneous Data]
    C --> G[Fixed Length]
```

### 2.1 Tuple Types

Tuples nhÃ³m nhiá»u giÃ¡ trá»‹ vá»›i cÃ¡c kiá»ƒu khÃ¡c nhau thÃ nh má»™t kiá»ƒu phá»©c há»£p duy nháº¥t.

| Äáº·c Ä‘iá»ƒm | MÃ´ táº£ | VÃ­ dá»¥ |
|----------|-------|-------|
| **Heterogeneous** | Chá»©a cÃ¡c kiá»ƒu khÃ¡c nhau | `(i32, f64, u8)` |
| **Fixed Length** | Äá»™ dÃ i cá»‘ Ä‘á»‹nh | KhÃ´ng thá»ƒ thÃªm/bá»›t pháº§n tá»­ |
| **Ordered** | CÃ¡c pháº§n tá»­ cÃ³ thá»© tá»± | `(1, 2)` â‰  `(2, 1)` |

```rust copy
fn main() {
    // Khai bÃ¡o tuple
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    
    // Destructuring
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
    
    // Truy cáº­p báº±ng index
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
    
    // Unit tuple (empty tuple)
    let unit = ();
}
```

### 2.2 Array Types

Arrays chá»©a nhiá»u giÃ¡ trá»‹ cÃ¹ng kiá»ƒu vá»›i Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh.

| Äáº·c Ä‘iá»ƒm | Array | Vector |
|----------|-------|--------|
| **KÃ­ch thÆ°á»›c** | Cá»‘ Ä‘á»‹nh | CÃ³ thá»ƒ thay Ä‘á»•i |
| **Bá»™ nhá»›** | Stack | Heap |
| **Hiá»‡u suáº¥t** | Nhanh hÆ¡n | Linh hoáº¡t hÆ¡n |
| **CÃº phÃ¡p** | `[T; N]` | `Vec<T>` |

```rust copy
fn main() {
    // Khai bÃ¡o array
    let a = [1, 2, 3, 4, 5];
    let months = [
        "January", "February", "March", "April",
        "May", "June", "July", "August", 
        "September", "October", "November", "December"
    ];
    
    // Array vá»›i type annotation
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    
    // Array vá»›i giÃ¡ trá»‹ giá»‘ng nhau
    let a = [3; 5];  // [3, 3, 3, 3, 3]
    
    // Truy cáº­p pháº§n tá»­
    let first = a[0];
    let second = a[1];
    
    // Äá»™ dÃ i array
    println!("Array cÃ³ {} pháº§n tá»­", a.len());
}
```

---

## ğŸ”„ 3. TYPE INFERENCE VÃ€ TYPE ANNOTATIONS

```mermaid
flowchart TD
    A[Compiler] --> B{Type Known?}
    B -->|Yes| C[Use Known Type]
    B -->|No| D[Type Inference]
    D --> E{Can Infer?}
    E -->|Yes| F[Infer Type]
    E -->|No| G[Require Annotation]
```

### 3.1 Type Inference (Suy luáº­n kiá»ƒu)

```rust copy
fn main() {
    let x = 42;         // Compiler suy luáº­n x lÃ  i32
    let y = 3.14;       // Compiler suy luáº­n y lÃ  f64
    let z = true;       // Compiler suy luáº­n z lÃ  bool
    
    // Suy luáº­n tá»« context
    let mut vec = Vec::new();  // Type chÆ°a xÃ¡c Ä‘á»‹nh
    vec.push(5);               // BÃ¢y giá» vec lÃ  Vec<i32>
}
```

### 3.2 Explicit Type Annotations

```rust copy
fn main() {
    let x: i32 = 42;
    let y: f32 = 3.14;
    let z: char = 'A';
    let arr: [i32; 3] = [1, 2, 3];
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    
    // Khi cáº§n thiáº¿t cho disambiguation
    let guess: u32 = "42".parse().expect("Not a number!");
}
```

---

## ğŸ”„ 4. TYPE CASTING VÃ€ CONVERSIONS

### 4.1 Explicit Casting vá»›i `as`

| Tá»« | Äáº¿n | VÃ­ dá»¥ | LÆ°u Ã½ |
|----|-----|-------|-------|
| `i32` | `f64` | `x as f64` | An toÃ n |
| `f64` | `i32` | `x as i32` | CÃ³ thá»ƒ máº¥t dá»¯ liá»‡u |
| `u32` | `i32` | `x as i32` | CÃ³ thá»ƒ overflow |
| `char` | `u8` | `x as u8` | Chá»‰ vá»›i ASCII |

```rust copy
fn main() {
    let x: i32 = 42;
    let y: f64 = x as f64;          // 42.0
    
    let a: f64 = 3.14;
    let b: i32 = a as i32;          // 3 (truncate)
    
    let c: u8 = 255;
    let d: i8 = c as i8;            // -1 (overflow)
    
    println!("y: {}, b: {}, d: {}", y, b, d);
}
```

### 4.2 Safe Conversions

```rust copy
fn main() {
    let x: i32 = 42;
    
    // Using TryFrom trait (safe)
    use std::convert::TryFrom;
    
    match u8::try_from(x) {
        Ok(val) => println!("Converted: {}", val),
        Err(e) => println!("Conversion failed: {}", e),
    }
    
    // Using Into trait
    let y: i64 = x.into();  // Always safe i32 -> i64
    println!("y: {}", y);
}
```

---

## âš ï¸ 5. OVERFLOW BEHAVIOR

<div className="bg-red-50 border-l-4 border-red-400 p-4 mb-6">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-2xl">âš ï¸</span>
    </div>
    <div className="ml-3">
      <p className="text-sm text-red-700">
        <strong>Cáº£nh bÃ¡o:</strong> Integer overflow trong Rust cÃ³ thá»ƒ gÃ¢y panic trong debug mode nhÆ°ng wrap around trong release mode
      </p>
    </div>
  </div>
</div>

| Build Mode | Overflow Behavior | VÃ­ dá»¥ |
|------------|------------------|-------|
| **Debug** | Panic | Program crashes |
| **Release** | Wrap around | 255u8 + 1 = 0u8 |

```rust copy
fn main() {
    let mut x: u8 = 255;
    
    // Explicit overflow handling
    let (result, overflowed) = x.overflowing_add(1);
    println!("Result: {}, Overflowed: {}", result, overflowed);
    
    // Safe arithmetic
    if let Some(result) = x.checked_add(1) {
        println!("Safe addition: {}", result);
    } else {
        println!("Overflow would occur!");
    }
    
    // Saturating arithmetic
    let result = x.saturating_add(10);  // Clamps at maximum
    println!("Saturating result: {}", result);
    
    // Wrapping arithmetic
    let result = x.wrapping_add(10);    // Wraps around
    println!("Wrapping result: {}", result);
}
```

---

## ğŸ§® 6. THá»°C HÃ€NH: XÃ‚Y Dá»°NG CALCULATOR ÄÆ N GIáº¢N

```rust copy
use std::io;

fn main() {
    println!("ğŸ§® SIMPLE CALCULATOR");
    println!("==================");
    
    // Input first number
    println!("Nháº­p sá»‘ thá»© nháº¥t:");
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed to read input");
    let num1: f64 = input.trim().parse().expect("Invalid number");
    
    // Input operator
    println!("Nháº­p phÃ©p toÃ¡n (+, -, *, /):");
    input.clear();
    io::stdin().read_line(&mut input).expect("Failed to read input");
    let operator = input.trim();
    
    // Input second number
    println!("Nháº­p sá»‘ thá»© hai:");
    input.clear();
    io::stdin().read_line(&mut input).expect("Failed to read input");
    let num2: f64 = input.trim().parse().expect("Invalid number");
    
    // Calculate result
    let result = match operator {
        "+" => num1 + num2,
        "-" => num1 - num2,
        "*" => num1 * num2,
        "/" => {
            if num2 != 0.0 {
                num1 / num2
            } else {
                println!("âŒ Lá»—i: KhÃ´ng thá»ƒ chia cho 0!");
                return;
            }
        }
        _ => {
            println!("âŒ PhÃ©p toÃ¡n khÃ´ng há»£p lá»‡!");
            return;
        }
    };
    
    // Display result with type information
    println!("\nğŸ“Š Káº¾T QUáº¢");
    println!("===========");
    println!("{} {} {} = {}", num1, operator, num2, result);
    println!("Kiá»ƒu dá»¯ liá»‡u káº¿t quáº£: {}", std::any::type_name::<f64>());
    
    // Additional calculations
    demonstrate_types();
}

fn demonstrate_types() {
    println!("\nğŸ”¬ DEMO KIá»‚U Dá»® LIá»†U");
    println!("====================");
    
    // Integers
    let small: i8 = 127;
    let medium: i32 = 2_147_483_647;
    let large: i64 = 9_223_372_036_854_775_807;
    
    println!("i8 max: {}", small);
    println!("i32 max: {}", medium);
    println!("i64 max: {}", large);
    
    // Floats
    let pi: f32 = 3.14159;
    let e: f64 = 2.718281828459045;
    
    println!("f32 Ï€: {:.5}", pi);
    println!("f64 e: {:.15}", e);
    
    // Boolean and char
    let is_rust_awesome = true;
    let grade = 'A';
    let emoji = 'ğŸ¦€';
    
    println!("Boolean: {}", is_rust_awesome);
    println!("Character: {}, Emoji: {}", grade, emoji);
    
    // Compound types
    let coordinates: (i32, i32) = (10, 20);
    let fibonacci: [i32; 5] = [1, 1, 2, 3, 5];
    
    println!("Coordinates: ({}, {})", coordinates.0, coordinates.1);
    println!("Fibonacci: {:?}", fibonacci);
    
    // Memory usage demonstration
    println!("\nğŸ’¾ MEMORY USAGE:");
    println!("Size of i32: {} bytes", std::mem::size_of::<i32>());
    println!("Size of f64: {} bytes", std::mem::size_of::<f64>());
    println!("Size of char: {} bytes", std::mem::size_of::<char>());
    println!("Size of tuple (i32, f64): {} bytes", std::mem::size_of::<(i32, f64)>());
    println!("Size of array [i32; 5]: {} bytes", std::mem::size_of::<[i32; 5]>());
}
```

---

## ğŸ“‹ 7. Báº¢NG Tá»”NG QUAN QUICK REFERENCE

| Danh má»¥c | Kiá»ƒu | KÃ­ch thÆ°á»›c | GiÃ¡ trá»‹ máº·c Ä‘á»‹nh | VÃ­ dá»¥ |
|----------|------|------------|------------------|-------|
| **Integer** | i32 | 4 bytes | 0 | `let x = 42;` |
| **Float** | f64 | 8 bytes | 0.0 | `let y = 3.14;` |
| **Boolean** | bool | 1 byte | false | `let flag = true;` |
| **Character** | char | 4 bytes | '\0' | `let c = 'A';` |
| **Tuple** | (T, U) | T + U | () | `let t = (1, 2);` |
| **Array** | [T; N] | T Ã— N | [T::default(); N] | `let arr = [1, 2, 3];` |

---

## ğŸ¯ 8. BÃ€I Táº¬P VÃ€ KIá»‚M TRA

<div className="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-2xl">ğŸ“</span>
    </div>
    <div className="ml-3">
      <div className="text-sm text-green-700">
        <strong>BÃ i táº­p:</strong> HÃ£y thá»­ implement cÃ¡c bÃ i táº­p sau Ä‘á»ƒ cá»§ng cá»‘ kiáº¿n thá»©c
      </div>
    </div>
  </div>
</div>

### BÃ i táº­p 1: Temperature Converter
Viáº¿t chÆ°Æ¡ng trÃ¬nh chuyá»ƒn Ä‘á»•i nhiá»‡t Ä‘á»™ giá»¯a Celsius, Fahrenheit vÃ  Kelvin.

### BÃ i táº­p 2: Array Statistics  
TÃ­nh toÃ¡n mean, median vÃ  mode cá»§a má»™t array sá»‘ nguyÃªn.

### BÃ i táº­p 3: Tuple Manipulation
Táº¡o cÃ¡c function Ä‘á»ƒ xá»­ lÃ½ tuple 3D coordinates (x, y, z).

---

## ğŸ“š 9. TÃ“M Táº®T VÃ€ NEXT STEPS

<div className="bg-indigo-600 text-white p-6 rounded-lg">
  <h3 className="text-xl font-bold mb-4">ğŸ“ KIáº¾N THá»¨C ÄÃƒ Há»ŒC</h3>
  <ul className="list-disc list-inside space-y-2">
    <li>Scalar types: integers, floats, booleans, characters</li>
    <li>Compound types: tuples vÃ  arrays</li>
    <li>Type inference vÃ  explicit annotations</li>
    <li>Type casting vÃ  overflow behavior</li>
    <li>Memory management cÆ¡ báº£n</li>
  </ul>
  
  <h3 className="text-xl font-bold mt-6 mb-4">ğŸš€ BÃ€I TIáº¾P THEO</h3>
  <p>BÃ i 4 sáº½ há»c vá» Control Flow vÃ  Functions Ä‘á»ƒ Ä‘iá»u khiá»ƒn luá»“ng thá»±c thi chÆ°Æ¡ng trÃ¬nh má»™t cÃ¡ch hiá»‡u quáº£.</p>
</div>