# BÃ i 7: Pattern Matching vÃ  Destructuring trong Rust

<div className="bg-gradient-to-r from-blue-500 to-purple-600 text-white p-6 rounded-lg mb-8">
  <h2 className="text-2xl font-bold mb-2">ğŸ¯ Má»¥c tiÃªu bÃ i há»c</h2>
  <p className="text-lg">ThÃ nh tháº¡o pattern matching - má»™t tÃ­nh nÄƒng máº¡nh máº½ cá»§a Rust Ä‘á»ƒ xá»­ lÃ½ dá»¯ liá»‡u má»™t cÃ¡ch an toÃ n vÃ  biá»ƒu cáº£m</p>
</div>

## ğŸ“š Giá»›i thiá»‡u vá» Pattern Matching

Pattern Matching lÃ  má»™t tÃ­nh nÄƒng máº¡nh máº½ trong Rust cho phÃ©p báº¡n so khá»›p giÃ¡ trá»‹ vá»›i cÃ¡c máº«u (patterns) vÃ  thá»±c hiá»‡n cÃ¡c hÃ nh Ä‘á»™ng tÆ°Æ¡ng á»©ng. ÄÃ¢y lÃ  cÃ¡ch Rust Ä‘áº£m báº£o tÃ­nh an toÃ n vÃ  trÃ¡nh lá»—i runtime.

```mermaid
graph TD
    A[Input Value] --> B{Match Expression}
    B --> C[Pattern 1]
    B --> D[Pattern 2] 
    B --> E[Pattern N]
    B --> F[Default Pattern _]
    C --> G[Action 1]
    D --> H[Action 2]
    E --> I[Action N]
    F --> J[Default Action]
```

## ğŸ” Match Expressions

### CÃº phÃ¡p cÆ¡ báº£n

```rust copy
match value {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression, // Wildcard pattern
}
```

### VÃ­ dá»¥ thá»±c táº¿ vá»›i enum

```rust copy
#[derive(Debug)]
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

fn get_action(light: TrafficLight) -> &'static str {
    match light {
        TrafficLight::Red => "Stop",
        TrafficLight::Yellow => "Prepare to stop",
        TrafficLight::Green => "Go",
    }
}
```

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-6">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-yellow-700 font-bold">âš ï¸ LÆ°u Ã½ quan trá»ng:</span>
    </div>
    <div className="ml-3">
      <p className="text-yellow-700">Match expressions pháº£i exhaustive (bao phá»§ táº¥t cáº£ trÆ°á»ng há»£p cÃ³ thá»ƒ). Rust compiler sáº½ bÃ¡o lá»—i náº¿u báº¡n bá» sÃ³t trÆ°á»ng há»£p nÃ o.</p>
    </div>
  </div>
</div>

## ğŸ¨ CÃ¡c loáº¡i Pattern

### 1. Literal Patterns

| Pattern Type | VÃ­ dá»¥ | MÃ´ táº£ |
|--------------|-------|-------|
| Number | `1`, `42`, `3.14` | Khá»›p vá»›i giÃ¡ trá»‹ sá»‘ cá»¥ thá»ƒ |
| String | `"hello"` | Khá»›p vá»›i string literal |
| Boolean | `true`, `false` | Khá»›p vá»›i giÃ¡ trá»‹ boolean |
| Character | `'a'`, `'x'` | Khá»›p vá»›i kÃ½ tá»± cá»¥ thá»ƒ |

```rust copy
fn classify_number(n: i32) -> &'static str {
    match n {
        0 => "zero",
        1 => "one", 
        2 => "two",
        _ => "other",
    }
}
```

### 2. Range Patterns

```rust copy
fn classify_score(score: u32) -> &'static str {
    match score {
        0..=59 => "Fail",
        60..=69 => "Pass",
        70..=84 => "Good", 
        85..=94 => "Very Good",
        95..=100 => "Excellent",
        _ => "Invalid score",
    }
}
```

### 3. Multiple Patterns vá»›i OR (|)

```rust copy
fn is_weekend(day: &str) -> bool {
    match day {
        "Saturday" | "Sunday" => true,
        _ => false,
    }
}
```

## ğŸ§© Destructuring

Destructuring cho phÃ©p báº¡n "tÃ¡ch" cÃ¡c thÃ nh pháº§n cá»§a compound types.

### Destructuring Tuples

```rust copy
fn process_point(point: (i32, i32)) -> String {
    match point {
        (0, 0) => "Origin".to_string(),
        (x, 0) => format!("On X-axis at {}", x),
        (0, y) => format!("On Y-axis at {}", y), 
        (x, y) => format!("Point at ({}, {})", x, y),
    }
}
```

### Destructuring Structs

```rust copy
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
    city: String,
}

fn describe_person(person: Person) -> String {
    match person {
        Person { name, age: 0..=17, .. } => {
            format!("{} is a minor", name)
        },
        Person { name, age: 18..=64, city } => {
            format!("{} is an adult living in {}", name, city)
        },
        Person { name, age, .. } => {
            format!("{} is {} years old (senior)", name, age)
        },
    }
}
```

### Destructuring Enums

```rust copy
#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => println!("Quit message received"),
        Message::Move { x, y } => {
            println!("Move to coordinates ({}, {})", x, y);
        },
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change color to RGB({}, {}, {})", r, g, b);
        },
    }
}
```

## ğŸ›¡ï¸ Guards vá»›i if

Guards cho phÃ©p thÃªm Ä‘iá»u kiá»‡n bá»• sung vÃ o patterns:

```rust copy
fn categorize_number(x: i32) -> &'static str {
    match x {
        n if n < 0 => "negative",
        n if n % 2 == 0 => "positive even",
        n if n % 2 == 1 => "positive odd", 
        _ => "unreachable",
    }
}
```

## ğŸ”— Binding vá»›i @ Operator

Operator `@` cho phÃ©p bind giÃ¡ trá»‹ vÃ o biáº¿n trong khi váº«n pattern matching:

```rust copy
#[derive(Debug)]
enum Status {
    Active(u32),
    Inactive,
    Pending(u32),
}

fn process_status(status: Status) {
    match status {
        Status::Active(id @ 1..=100) => {
            println!("High priority active task: {}", id);
        },
        Status::Active(id) => {
            println!("Normal active task: {}", id);
        },
        Status::Pending(id @ 1..=10) => {
            println!("Urgent pending task: {}", id);
        },
        Status::Pending(id) => {
            println!("Normal pending task: {}", id);
        },
        Status::Inactive => println!("Inactive status"),
    }
}
```

## ğŸ¯ If Let vÃ  While Let

### If Let - Pattern Matching ngáº¯n gá»n

So sÃ¡nh giá»¯a `match` vÃ  `if let`:

| Approach | Code | Use Case |
|----------|------|----------|
| **match** | `match option { Some(x) => { ... }, None => {} }` | Khi cáº§n xá»­ lÃ½ táº¥t cáº£ cases |
| **if let** | `if let Some(x) = option { ... }` | Chá»‰ quan tÃ¢m Ä‘áº¿n 1 pattern cá»¥ thá»ƒ |

```rust copy
fn handle_option(opt: Option<i32>) {
    // CÃ¡ch 1: Sá»­ dá»¥ng match
    match opt {
        Some(value) => println!("Got value: {}", value),
        None => {}, // KhÃ´ng lÃ m gÃ¬
    }
    
    // CÃ¡ch 2: Sá»­ dá»¥ng if let (ngáº¯n gá»n hÆ¡n)
    if let Some(value) = opt {
        println!("Got value: {}", value);
    }
}
```

### While Let - Láº·p vá»›i pattern matching

```rust copy
fn process_stack() {
    let mut stack = vec![1, 2, 3, 4, 5];
    
    // Láº¥y vÃ  xá»­ lÃ½ tá»«ng pháº§n tá»­ cho Ä‘áº¿n khi stack rá»—ng
    while let Some(value) = stack.pop() {
        println!("Processing: {}", value);
    }
}
```

## ğŸ§® Thá»±c hÃ nh: Simple Calculator

HÃ£y xÃ¢y dá»±ng má»™t mÃ¡y tÃ­nh Ä‘Æ¡n giáº£n sá»­ dá»¥ng pattern matching:

```rust copy
#[derive(Debug)]
enum Operation {
    Add(f64, f64),
    Subtract(f64, f64),
    Multiply(f64, f64),
    Divide(f64, f64),
    Power(f64, f64),
}

#[derive(Debug)]
enum CalculatorError {
    DivisionByZero,
    InvalidOperation,
}

fn calculate(op: Operation) -> Result<f64, CalculatorError> {
    match op {
        Operation::Add(a, b) => Ok(a + b),
        Operation::Subtract(a, b) => Ok(a - b),
        Operation::Multiply(a, b) => Ok(a * b),
        Operation::Divide(a, b) if b != 0.0 => Ok(a / b),
        Operation::Divide(_, 0.0) => Err(CalculatorError::DivisionByZero),
        Operation::Power(base, exp) => Ok(base.powf(exp)),
    }
}

// Expression parser
#[derive(Debug)]
enum Expression {
    Number(f64),
    Binary {
        left: Box<Expression>,
        op: BinaryOp,
        right: Box<Expression>,
    },
}

#[derive(Debug)]
enum BinaryOp {
    Add, Sub, Mul, Div,
}

fn evaluate(expr: Expression) -> f64 {
    match expr {
        Expression::Number(n) => n,
        Expression::Binary { left, op, right } => {
            let left_val = evaluate(*left);
            let right_val = evaluate(*right);
            
            match op {
                BinaryOp::Add => left_val + right_val,
                BinaryOp::Sub => left_val - right_val,
                BinaryOp::Mul => left_val * right_val,
                BinaryOp::Div => left_val / right_val,
            }
        }
    }
}
```

## ğŸ“Š So sÃ¡nh Pattern Matching trong Rust vs NgÃ´n ngá»¯ khÃ¡c

| Feature | Rust | C/C++ | Java | Python |
|---------|------|-------|------|--------|
| **Exhaustiveness checking** | âœ… Compile-time | âŒ | âŒ | âŒ |
| **Destructuring** | âœ… Deep | âŒ | âš ï¸ Limited | âœ… |
| **Guards** | âœ… | âŒ | âŒ | âš ï¸ Limited |
| **Type safety** | âœ… | âŒ | âš ï¸ | âŒ |
| **Performance** | âœ… Zero-cost | âš ï¸ | âš ï¸ | âŒ |

## ğŸ¯ Pattern Matching Best Practices

<div className="bg-green-50 border border-green-200 rounded-lg p-6 my-6">
  <h3 className="text-green-800 font-bold text-lg mb-4">âœ… NÃªn lÃ m</h3>
  <ul className="text-green-700 space-y-2">
    <li>â€¢ Sá»­ dá»¥ng <code>match</code> khi cáº§n xá»­ lÃ½ táº¥t cáº£ cases</li>
    <li>â€¢ Sá»­ dá»¥ng <code>if let</code> khi chá»‰ quan tÃ¢m 1 pattern</li>
    <li>â€¢ Äáº·t cÃ¡c patterns cá»¥ thá»ƒ trÆ°á»›c patterns tá»•ng quÃ¡t</li>
    <li>â€¢ Sá»­ dá»¥ng guards Ä‘á»ƒ thÃªm logic phá»©c táº¡p</li>
  </ul>
</div>

<div className="bg-red-50 border border-red-200 rounded-lg p-6 my-6">
  <h3 className="text-red-800 font-bold text-lg mb-4">âŒ KhÃ´ng nÃªn lÃ m</h3>
  <ul className="text-red-700 space-y-2">
    <li>â€¢ Sá»­ dá»¥ng wildcard <code>_</code> khi cÃ³ thá»ƒ list cá»¥ thá»ƒ</li>
    <li>â€¢ Táº¡o patterns quÃ¡ phá»©c táº¡p khÃ³ Ä‘á»c</li>
    <li>â€¢ Ignore compiler warnings vá» unreachable patterns</li>
  </ul>
</div>

## ğŸ”„ Flow Chart: Khi nÃ o sá»­ dá»¥ng loáº¡i pattern nÃ o

```mermaid
flowchart TD
    A[Cáº§n pattern matching?] --> B{Xá»­ lÃ½ táº¥t cáº£ cases?}
    B -->|CÃ³| C[Sá»­ dá»¥ng match]
    B -->|KhÃ´ng| D{Chá»‰ 1 pattern quan trá»ng?}
    D -->|CÃ³| E[Sá»­ dá»¥ng if let]
    D -->|KhÃ´ng| F{Láº·p vá»›i pattern?}
    F -->|CÃ³| G[Sá»­ dá»¥ng while let]
    F -->|KhÃ´ng| H[Sá»­ dá»¥ng match vá»›i _]
    
    C --> I[Äáº£m báº£o exhaustive]
    E --> J[Ngáº¯n gá»n, dá»… Ä‘á»c]
    G --> K[Láº·p an toÃ n]
    H --> L[Xá»­ lÃ½ default case]
```

## ğŸ¯ BÃ i táº­p thá»±c hÃ nh

### BÃ i táº­p 1: JSON Parser
Táº¡o má»™t JSON parser Ä‘Æ¡n giáº£n sá»­ dá»¥ng enums vÃ  pattern matching:

```rust copy
#[derive(Debug)]
enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(std::collections::HashMap<String, JsonValue>),
}

fn stringify_json(value: JsonValue) -> String {
    match value {
        JsonValue::Null => "null".to_string(),
        JsonValue::Bool(b) => b.to_string(),
        JsonValue::Number(n) => n.to_string(),
        JsonValue::String(s) => format!("\"{}\"", s),
        JsonValue::Array(arr) => {
            let items: Vec<String> = arr
                .into_iter()
                .map(stringify_json)
                .collect();
            format!("[{}]", items.join(", "))
        },
        JsonValue::Object(obj) => {
            let items: Vec<String> = obj
                .into_iter()
                .map(|(k, v)| format!("\"{}\": {}", k, stringify_json(v)))
                .collect();
            format!("{{{}}}", items.join(", "))
        },
    }
}
```

### BÃ i táº­p 2: State Machine
Implement má»™t state machine cho traffic light:

```rust copy
#[derive(Debug, Clone)]
enum TrafficState {
    Red { remaining_time: u32 },
    Yellow { remaining_time: u32 },
    Green { remaining_time: u32 },
}

impl TrafficState {
    fn tick(self) -> TrafficState {
        match self {
            TrafficState::Red { remaining_time: 0 } => {
                TrafficState::Green { remaining_time: 30 }
            },
            TrafficState::Yellow { remaining_time: 0 } => {
                TrafficState::Red { remaining_time: 45 }
            },
            TrafficState::Green { remaining_time: 0 } => {
                TrafficState::Yellow { remaining_time: 5 }
            },
            TrafficState::Red { remaining_time } => {
                TrafficState::Red { remaining_time: remaining_time - 1 }
            },
            TrafficState::Yellow { remaining_time } => {
                TrafficState::Yellow { remaining_time: remaining_time - 1 }
            },
            TrafficState::Green { remaining_time } => {
                TrafficState::Green { remaining_time: remaining_time - 1 }
            },
        }
    }
}
```

## ğŸ“ TÃ³m táº¯t

<div className="bg-blue-50 border border-blue-200 rounded-lg p-6">
  <h3 className="text-blue-800 font-bold text-lg mb-4">ğŸ“ Kiáº¿n thá»©c Ä‘Ã£ há»c</h3>
  <div className="text-blue-700 space-y-2">
    <p>â€¢ <strong>Match expressions:</strong> CÃ¡ch chÃ­nh Ä‘á»ƒ pattern matching trong Rust</p>
    <p>â€¢ <strong>Destructuring:</strong> TÃ¡ch dá»¯ liá»‡u tá»« tuples, structs, enums</p>
    <p>â€¢ <strong>Guards:</strong> ThÃªm Ä‘iá»u kiá»‡n vá»›i <code>if</code> trong patterns</p>
    <p>â€¢ <strong>@ operator:</strong> Bind giÃ¡ trá»‹ trong khi pattern matching</p>
    <p>â€¢ <strong>if let/while let:</strong> Pattern matching ngáº¯n gá»n</p>
    <p>â€¢ <strong>Exhaustiveness:</strong> Äáº£m báº£o xá»­ lÃ½ táº¥t cáº£ trÆ°á»ng há»£p</p>
  </div>
</div>

**BÃ i tiáº¿p theo:** Ownership System - Core Concepts (BÃ i 8)

Pattern matching lÃ  má»™t trong nhá»¯ng tÃ­nh nÄƒng máº¡nh máº½ nháº¥t cá»§a Rust, giÃºp code trá»Ÿ nÃªn an toÃ n, rÃµ rÃ ng vÃ  biá»ƒu cáº£m. HÃ£y thá»±c hÃ nh nhiá»u Ä‘á»ƒ thÃ nh tháº¡o!