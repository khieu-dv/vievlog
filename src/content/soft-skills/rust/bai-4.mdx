# B√†i 4: Control Flow v√† Functions

<div className="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-6 rounded-lg mb-8">
  <h2 className="text-2xl font-bold mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <p className="text-lg">S·ª≠ d·ª•ng th√†nh th·∫°o c√°c c·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn v√† functions trong Rust</p>
</div>

## üìö T·ªïng quan

Trong b√†i h·ªçc n√†y, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ c√°c c·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn lu·ªìng ch∆∞∆°ng tr√¨nh v√† c√°ch ƒë·ªãnh nghƒ©a functions trong Rust. ƒê√¢y l√† nh·ªØng kh√°i ni·ªám c·ªët l√µi gi√∫p b·∫°n x√¢y d·ª±ng logic ph·ª©c t·∫°p v√† t·ªï ch·ª©c code hi·ªáu qu·∫£.

## 1. C√¢u l·ªánh ƒëi·ªÅu ki·ªán (Conditional Statements)

### If Expressions

Rust s·ª≠ d·ª•ng `if` nh∆∞ m·ªôt expression, nghƒ©a l√† n√≥ c√≥ th·ªÉ tr·∫£ v·ªÅ gi√° tr·ªã.

```mermaid
flowchart TD
    A[B·∫Øt ƒë·∫ßu] --> B{ƒêi·ªÅu ki·ªán if}
    B -->|true| C[Th·ª±c thi kh·ªëi if]
    B -->|false| D{C√≥ else if?}
    D -->|true| E{ƒêi·ªÅu ki·ªán else if}
    D -->|false| F[Th·ª±c thi kh·ªëi else]
    E -->|true| G[Th·ª±c thi kh·ªëi else if]
    E -->|false| F
    C --> H[Ti·∫øp t·ª•c]
    G --> H
    F --> H
```

### C√∫ ph√°p c∆° b·∫£n

| Lo·∫°i | C√∫ ph√°p | V√≠ d·ª• |
|------|---------|-------|
| If ƒë∆°n gi·∫£n | `if condition { }` | `if x > 0 { println!("Positive"); }` |
| If-else | `if condition { } else { }` | `if x > 0 { 1 } else { -1 }` |
| If-else if | `if cond1 { } else if cond2 { } else { }` | Xem v√≠ d·ª• b√™n d∆∞·ªõi |

```rust
fn main() {
    let number = 6;

    // If expression tr·∫£ v·ªÅ gi√° tr·ªã
    let result = if number % 4 == 0 {
        "divisible by 4"
    } else if number % 3 == 0 {
        "divisible by 3"
    } else if number % 2 == 0 {
        "divisible by 2"
    } else {
        "not divisible by 4, 3, or 2"
    };

    println!("The number is {}", result);
}
```

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-4">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-yellow-400 text-xl">‚ö†Ô∏è</span>
    </div>
    <div className="ml-3">
      <h3 className="text-lg font-medium text-yellow-800">L∆∞u √Ω quan tr·ªçng</h3>
      <p className="text-yellow-700">ƒêi·ªÅu ki·ªán trong Rust ph·∫£i l√† ki·ªÉu <code>bool</code>. Kh√¥ng th·ªÉ s·ª≠ d·ª•ng s·ªë nguy√™n nh∆∞ trong C/C++.</p>
    </div>
  </div>
</div>

## 2. V√≤ng l·∫∑p (Loops)

Rust cung c·∫•p ba lo·∫°i v√≤ng l·∫∑p ch√≠nh:

### B·∫£ng so s√°nh c√°c lo·∫°i v√≤ng l·∫∑p

| Lo·∫°i v√≤ng l·∫∑p | C√∫ ph√°p | Khi n√†o s·ª≠ d·ª•ng | V√≠ d·ª• |
|---------------|---------|-----------------|-------|
| `loop` | `loop { }` | V√≤ng l·∫∑p v√¥ h·∫°n ho·∫∑c c√≥ ƒëi·ªÅu ki·ªán tho√°t ph·ª©c t·∫°p | `loop { if condition { break; } }` |
| `while` | `while condition { }` | L·∫∑p khi ƒëi·ªÅu ki·ªán ƒë√∫ng | `while x < 10 { x += 1; }` |
| `for` | `for item in iterator { }` | L·∫∑p qua collection ho·∫∑c range | `for i in 0..5 { }` |

### 2.1 Loop - V√≤ng l·∫∑p v√¥ h·∫°n

```rust
fn main() {
    let mut count = 0;
    
    // V√≤ng l·∫∑p v·ªõi break c√≥ gi√° tr·ªã tr·∫£ v·ªÅ
    let result = loop {
        count += 1;
        
        if count == 10 {
            break count * 2; // Tr·∫£ v·ªÅ gi√° tr·ªã khi break
        }
    };
    
    println!("Result: {}", result); // Output: Result: 20
}
```

### 2.2 While Loop

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

### 2.3 For Loop

```rust
fn main() {
    // L·∫∑p qua range
    for number in 1..=5 {
        println!("{}", number);
    }

    // L·∫∑p qua array
    let a = [10, 20, 30, 40, 50];
    for element in a {
        println!("Value: {}", element);
    }

    // L·∫∑p v·ªõi index
    for (index, value) in a.iter().enumerate() {
        println!("Index: {}, Value: {}", index, value);
    }
}
```

### Loop Labels v√† Control Flow

```mermaid
graph TD
    A[Outer Loop] --> B[Inner Loop]
    B --> C{ƒêi·ªÅu ki·ªán}
    C -->|break 'outer| D[Tho√°t outer loop]
    C -->|continue 'outer| E[Ti·∫øp t·ª•c outer loop]
    C -->|break| F[Tho√°t inner loop]
    C -->|continue| G[Ti·∫øp t·ª•c inner loop]
```

```rust
fn main() {
    'outer: loop {
        println!("Outer loop");
        
        'inner: loop {
            println!("Inner loop");
            break 'outer; // Tho√°t kh·ªèi outer loop
        }
        
        println!("This point will never be reached");
    }
    
    println!("Exited the outer loop");
}
```

## 3. Functions (H√†m)

### C√∫ ph√°p ƒë·ªãnh nghƒ©a h√†m

```rust
fn function_name(parameter1: Type1, parameter2: Type2) -> ReturnType {
    // function body
    expression_or_return_statement
}
```

### B·∫£ng ph√¢n lo·∫°i functions

| Lo·∫°i | ƒê·∫∑c ƒëi·ªÉm | V√≠ d·ª• |
|------|----------|-------|
| Kh√¥ng tham s·ªë, kh√¥ng tr·∫£ v·ªÅ | `fn name() { }` | `fn greet() { println!("Hello!"); }` |
| C√≥ tham s·ªë, kh√¥ng tr·∫£ v·ªÅ | `fn name(param: Type) { }` | `fn print_number(x: i32) { println!("{}", x); }` |
| Kh√¥ng tham s·ªë, c√≥ tr·∫£ v·ªÅ | `fn name() -> Type { }` | `fn get_number() -> i32 { 42 }` |
| C√≥ tham s·ªë, c√≥ tr·∫£ v·ªÅ | `fn name(param: Type) -> Type { }` | `fn add(x: i32, y: i32) -> i32 { x + y }` |

### 3.1 Functions v·ªõi Parameters v√† Return Values

```rust
// Function v·ªõi parameters
fn add(x: i32, y: i32) -> i32 {
    x + y  // Expression, kh√¥ng c·∫ßn return keyword
}

// Function v·ªõi return statement
fn subtract(x: i32, y: i32) -> i32 {
    return x - y;  // C√≥ th·ªÉ s·ª≠ d·ª•ng return
}

// Function tr·∫£ v·ªÅ tuple
fn calculate(x: i32, y: i32) -> (i32, i32, i32, i32) {
    (x + y, x - y, x * y, x / y)
}

fn main() {
    let sum = add(5, 3);
    let difference = subtract(10, 4);
    let (add_result, sub_result, mul_result, div_result) = calculate(20, 4);
    
    println!("Sum: {}", sum);
    println!("Difference: {}", difference);
    println!("Results: {}, {}, {}, {}", add_result, sub_result, mul_result, div_result);
}
```

### 3.2 Statements vs Expressions

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 my-4">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-blue-400 text-xl">üí°</span>
    </div>
    <div className="ml-3">
      <h3 className="text-lg font-medium text-blue-800">Kh√°i ni·ªám quan tr·ªçng</h3>
      <ul className="text-blue-700 mt-2 list-disc list-inside">
        <li><strong>Statements:</strong> Th·ª±c thi h√†nh ƒë·ªông nh∆∞ng kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã</li>
        <li><strong>Expressions:</strong> ƒê√°nh gi√° v√† tr·∫£ v·ªÅ m·ªôt gi√° tr·ªã</li>
      </ul>
    </div>
  </div>
</div>

| Lo·∫°i | V√≠ d·ª• | Ghi ch√∫ |
|------|-------|---------|
| Statement | `let x = 5;` | Kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã |
| Statement | `fn foo() {}` | ƒê·ªãnh nghƒ©a function |
| Expression | `5` | Literal value |
| Expression | `x + 1` | Mathematical operation |
| Expression | `{ let x = 3; x + 1 }` | Block expression |

```rust
fn main() {
    // Block expression
    let y = {
        let x = 3;
        x + 1  // Expression, kh√¥ng c√≥ d·∫•u ;
    };
    
    println!("Value of y: {}", y); // Output: Value of y: 4
}
```

## 4. Function Scope v√† Nested Functions

```rust
fn outer_function() {
    println!("Outer function");
    
    // Nested function
    fn inner_function() {
        println!("Inner function");
    }
    
    inner_function(); // G·ªçi nested function
}

fn main() {
    outer_function();
    // inner_function(); // Error: kh√¥ng th·ªÉ g·ªçi t·ª´ main
}
```

## üî® Th·ª±c h√†nh: Mathematical Functions

H√£y implement c√°c functions sau:

### 4.1 Factorial Function

```rust
fn factorial(n: u32) -> u32 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// Iterative version
fn factorial_iterative(n: u32) -> u32 {
    let mut result = 1;
    for i in 1..=n {
        result *= i;
    }
    result
}
```

### 4.2 Fibonacci Function

```rust
fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// Optimized iterative version
fn fibonacci_iterative(n: u32) -> u32 {
    if n <= 1 {
        return n;
    }
    
    let mut prev = 0;
    let mut curr = 1;
    
    for _ in 2..=n {
        let next = prev + curr;
        prev = curr;
        curr = next;
    }
    
    curr
}
```

### 4.3 Prime Number Checker

```rust
fn is_prime(n: u32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    
    true
}

fn find_primes(limit: u32) -> Vec<u32> {
    let mut primes = Vec::new();
    
    for num in 2..=limit {
        if is_prime(num) {
            primes.push(num);
        }
    }
    
    primes
}
```

### 4.4 Complete Example Program

```rust
fn main() {
    // Test factorial
    for i in 0..=10 {
        println!("{}! = {}", i, factorial(i));
    }
    
    println!("\n--- Fibonacci Sequence ---");
    for i in 0..15 {
        println!("F({}) = {}", i, fibonacci_iterative(i));
    }
    
    println!("\n--- Prime Numbers up to 50 ---");
    let primes = find_primes(50);
    println!("Primes: {:?}", primes);
    
    // Interactive calculator
    calculator_menu();
}

fn calculator_menu() {
    loop {
        println!("\n=== Simple Calculator ===");
        println!("1. Addition");
        println!("2. Subtraction");
        println!("3. Multiplication");
        println!("4. Division");
        println!("5. Exit");
        
        // Trong th·ª±c t·∫ø, b·∫°n s·∫Ω c·∫ßn s·ª≠ d·ª•ng th∆∞ vi·ªán ƒë·ªÉ ƒë·ªçc input
        let choice = 1; // Gi·∫£ s·ª≠ ch·ªçn 1
        let a = 10;
        let b = 5;
        
        match choice {
            1 => println!("{} + {} = {}", a, b, add(a, b)),
            2 => println!("{} - {} = {}", a, b, subtract(a, b)),
            3 => println!("{} * {} = {}", a, b, multiply(a, b)),
            4 => {
                if b != 0 {
                    println!("{} / {} = {}", a, b, divide(a, b));
                } else {
                    println!("Error: Division by zero!");
                }
            },
            5 => {
                println!("Goodbye!");
                break;
            },
            _ => println!("Invalid choice!"),
        }
        
        break; // ƒê·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n trong v√≠ d·ª• n√†y
    }
}

fn add(x: i32, y: i32) -> i32 { x + y }
fn subtract(x: i32, y: i32) -> i32 { x - y }
fn multiply(x: i32, y: i32) -> i32 { x * y }
fn divide(x: i32, y: i32) -> f64 { x as f64 / y as f64 }
```

## üìã T√≥m t·∫Øt ki·∫øn th·ª©c

<div className="bg-green-50 border-l-4 border-green-400 p-4 my-4">
  <div className="flex">
    <div className="flex-shrink-0">
      <span className="text-green-400 text-xl">‚úÖ</span>
    </div>
    <div className="ml-3">
      <h3 className="text-lg font-medium text-green-800">Nh·ªØng ƒëi·ªÅu c·∫ßn nh·ªõ</h3>
      <ul className="text-green-700 mt-2 list-disc list-inside space-y-1">
        <li><code>if</code> l√† expression, c√≥ th·ªÉ tr·∫£ v·ªÅ gi√° tr·ªã</li>
        <li>Ba lo·∫°i v√≤ng l·∫∑p: <code>loop</code>, <code>while</code>, <code>for</code></li>
        <li>S·ª≠ d·ª•ng loop labels ƒë·ªÉ control nested loops</li>
        <li>Functions c√≥ th·ªÉ tr·∫£ v·ªÅ gi√° tr·ªã m√† kh√¥ng c·∫ßn <code>return</code></li>
        <li>Ph√¢n bi·ªát statements v√† expressions</li>
        <li>Nested functions ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi trong scope c·ªßa ch√∫ng</li>
      </ul>
    </div>
  </div>
</div>

## üéØ B√†i t·∫≠p th·ª±c h√†nh

1. **Vi·∫øt function `power(base: i32, exp: u32) -> i32`** t√≠nh l≈©y th·ª´a
2. **T·∫°o function `gcd(a: u32, b: u32) -> u32`** t√¨m ∆∞·ªõc chung l·ªõn nh·∫•t
3. **Implement `is_perfect_number(n: u32) -> bool`** ki·ªÉm tra s·ªë ho√†n h·∫£o
4. **X√¢y d·ª±ng number guessing game** s·ª≠ d·ª•ng loops v√† conditions

---

<div className="text-center p-4 bg-gray-100 rounded-lg">
  <p className="text-gray-600">üìö <strong>B√†i ti·∫øp theo:</strong> B√†i 5 - Strings v√† Collections c∆° b·∫£n</p>
</div>