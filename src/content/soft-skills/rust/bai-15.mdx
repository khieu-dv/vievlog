# B√ÄI 15: ADVANCED COLLECTIONS V√Ä CONCURRENCY BASICS

<div className="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6 rounded-lg mb-8">
  <h2 className="text-2xl font-bold mb-2">üéØ M·ª•c ti√™u b√†i h·ªçc</h2>
  <p className="text-lg">S·ª≠ d·ª•ng advanced collections v√† introduction to concurrency</p>
</div>

## üìö N·ªôi dung b√†i h·ªçc

Trong b√†i h·ªçc n√†y, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ c√°c collection n√¢ng cao trong Rust v√† nh·ªØng kh√°i ni·ªám c∆° b·∫£n v·ªÅ l·∫≠p tr√¨nh ƒë·ªìng th·ªùi (concurrency).

---

## üóÇÔ∏è ADVANCED COLLECTIONS

### 1. BTreeMap v√† BTreeSet

<div className="bg-green-50 border-l-4 border-green-400 p-4 mb-4">
  <h4 className="font-bold text-green-800">üí° Kh√°i ni·ªám:</h4>
  <p className="text-green-700">BTreeMap v√† BTreeSet l√† c√°c collection ƒë∆∞·ª£c s·∫Øp x·∫øp t·ª± ƒë·ªông, s·ª≠ d·ª•ng c√¢y B (B-tree) ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu.</p>
</div>

| Lo·∫°i Collection | ƒê·∫∑c ƒëi·ªÉm | Use Case |
|---|---|---|
| **HashMap** | O(1) trung b√¨nh, kh√¥ng s·∫Øp x·∫øp | Truy xu·∫•t nhanh, kh√¥ng c·∫ßn th·ª© t·ª± |
| **BTreeMap** | O(log n), lu√¥n s·∫Øp x·∫øp | C·∫ßn duy·ªát theo th·ª© t·ª±, range queries |
| **HashSet** | O(1) trung b√¨nh, kh√¥ng s·∫Øp x·∫øp | Ki·ªÉm tra membership nhanh |
| **BTreeSet** | O(log n), lu√¥n s·∫Øp x·∫øp | Set c√≥ th·ª© t·ª±, range operations |

```rust
use std::collections::{BTreeMap, BTreeSet};

fn btree_collections_demo() {
    // BTreeMap - Key-value pairs ƒë∆∞·ª£c s·∫Øp x·∫øp
    let mut scores = BTreeMap::new();
    scores.insert("Alice", 85);
    scores.insert("Bob", 92);
    scores.insert("Charlie", 78);
    scores.insert("David", 95);
    
    // Duy·ªát theo th·ª© t·ª± alphabet
    for (name, score) in &scores {
        println!("{}: {}", name, score);
    }
    
    // Range queries
    let range: Vec<_> = scores.range("Bob"..).collect();
    println!("From Bob onwards: {:?}", range);
    
    // BTreeSet - Set c√≥ th·ª© t·ª±
    let mut numbers = BTreeSet::new();
    numbers.insert(5);
    numbers.insert(2);
    numbers.insert(8);
    numbers.insert(1);
    
    // T·ª± ƒë·ªông s·∫Øp x·∫øp: 1, 2, 5, 8
    println!("Sorted numbers: {:?}", numbers);
}
```

### 2. C√°c Collection ƒê·∫∑c Bi·ªát Kh√°c

```mermaid
graph TD
    A[Collections] --> B[Sequence]
    A --> C[Maps]
    A --> D[Sets]
    
    B --> E[Vec]
    B --> F[VecDeque]
    B --> G[LinkedList]
    
    C --> H[HashMap]
    C --> I[BTreeMap]
    
    D --> J[HashSet]
    D --> K[BTreeSet]
    
    A --> L[Priority Queue]
    L --> M[BinaryHeap]
```

#### VecDeque (Double-ended Queue)

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4">
  <h4 className="font-bold text-yellow-800">‚ö° ∆Øu ƒëi·ªÉm:</h4>
  <p className="text-yellow-700">Th√™m/x√≥a ph·∫ßn t·ª≠ ·ªü c·∫£ hai ƒë·∫ßu v·ªõi ƒë·ªô ph·ª©c t·∫°p O(1)</p>
</div>

```rust
use std::collections::VecDeque;

fn vecdeque_demo() {
    let mut deque = VecDeque::new();
    
    // Th√™m v√†o cu·ªëi
    deque.push_back(1);
    deque.push_back(2);
    
    // Th√™m v√†o ƒë·∫ßu
    deque.push_front(0);
    
    println!("Deque: {:?}", deque); // [0, 1, 2]
    
    // L·∫•y t·ª´ c·∫£ hai ƒë·∫ßu
    let front = deque.pop_front(); // Some(0)
    let back = deque.pop_back();   // Some(2)
    
    println!("Front: {:?}, Back: {:?}", front, back);
}
```

#### BinaryHeap (Priority Queue)

```rust
use std::collections::BinaryHeap;

fn binary_heap_demo() {
    let mut heap = BinaryHeap::new();
    
    heap.push(3);
    heap.push(1);
    heap.push(4);
    heap.push(2);
    
    // Lu√¥n l·∫•y ph·∫ßn t·ª≠ l·ªõn nh·∫•t
    while let Some(max) = heap.pop() {
        println!("Max: {}", max); // 4, 3, 2, 1
    }
}
```

---

## üîó SHARED OWNERSHIP V·ªöI RC V√Ä ARC

### Reference Counting v·ªõi Rc&lt;T&gt;

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-4">
  <h4 className="font-bold text-blue-800">üìñ ƒê·ªãnh nghƒ©a:</h4>
  <p className="text-blue-700">Rc (Reference Counted) cho ph√©p multiple owners cho c√πng m·ªôt d·ªØ li·ªáu trong single-threaded context.</p>
</div>

```rust
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: Vec<Rc<Node>>,
}

fn rc_demo() {
    let leaf = Rc::new(Node {
        value: 3,
        children: vec![],
    });
    
    println!("Leaf reference count: {}", Rc::strong_count(&leaf));
    
    let branch = Rc::new(Node {
        value: 5,
        children: vec![Rc::clone(&leaf)],
    });
    
    println!("Leaf reference count after branch: {}", Rc::strong_count(&leaf));
    
    let root = Rc::new(Node {
        value: 10,
        children: vec![Rc::clone(&branch), Rc::clone(&leaf)],
    });
    
    println!("Final leaf reference count: {}", Rc::strong_count(&leaf));
}
```

### Atomic Reference Counting v·ªõi Arc&lt;T&gt;

| Rc&lt;T&gt; | Arc&lt;T&gt; |
|---|---|
| Single-threaded | Multi-threaded |
| Kh√¥ng thread-safe | Thread-safe |
| Overhead th·∫•p h∆°n | Overhead cao h∆°n (atomic operations) |

```rust
use std::sync::Arc;
use std::thread;

fn arc_demo() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let sum: i32 = data_clone.iter().sum();
            println!("Thread {}: Sum = {}", i, sum);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## üîí INTERIOR MUTABILITY V·ªöI REFCELL

<div className="bg-red-50 border-l-4 border-red-400 p-4 mb-4">
  <h4 className="font-bold text-red-800">‚ö†Ô∏è L∆∞u √Ω:</h4>
  <p className="text-red-700">RefCell cho ph√©p mutable borrow checking t·∫°i runtime thay v√¨ compile time.</p>
</div>

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Counter {
    value: RefCell<i32>,
}

impl Counter {
    fn new(initial: i32) -> Self {
        Counter {
            value: RefCell::new(initial),
        }
    }
    
    fn increment(&self) {
        *self.value.borrow_mut() += 1;
    }
    
    fn get(&self) -> i32 {
        *self.value.borrow()
    }
}

fn refcell_demo() {
    let counter = Rc::new(Counter::new(0));
    let counter1 = Rc::clone(&counter);
    let counter2 = Rc::clone(&counter);
    
    counter1.increment();
    counter2.increment();
    
    println!("Final count: {}", counter.get()); // 2
}
```

### So s√°nh Borrowing Strategies

```mermaid
flowchart TD
    A[Borrowing Strategy] --> B[Compile-time]
    A --> C[Runtime]
    
    B --> D[&T / &mut T]
    B --> E[Box<T>]
    
    C --> F[RefCell<T>]
    C --> G[Rc<RefCell<T>>]
    C --> H[Arc<Mutex<T>>]
    
    D --> I[Static borrow checking]
    F --> J[Dynamic borrow checking]
    G --> K[Shared ownership + mutability]
    H --> L[Thread-safe shared mutability]
```

---

## üßµ CONCURRENCY BASICS

### Basic Threading

<div className="bg-purple-50 border-l-4 border-purple-400 p-4 mb-4">
  <h4 className="font-bold text-purple-800">üîÑ Threading:</h4>
  <p className="text-purple-700">Rust cung c·∫•p 1:1 threading model v·ªõi native OS threads.</p>
</div>

```rust
use std::thread;
use std::time::Duration;

fn basic_threading() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("Thread: {}", i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    
    for i in 1..5 {
        println!("Main: {}", i);
        thread::sleep(Duration::from_millis(1));
    }
    
    handle.join().unwrap();
}
```

### Message Passing v·ªõi Channels

```rust
use std::sync::mpsc;
use std::thread;

fn channel_demo() {
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        let values = vec![
            String::from("Hello"),
            String::from("from"),
            String::from("thread"),
        ];
        
        for val in values {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
    
    for received in rx {
        println!("Received: {}", received);
    }
}
```

### Shared State v·ªõi Mutex

| Approach | Use Case | Thread Safety |
|---|---|---|
| **mpsc::channel** | Producer-Consumer | ‚úÖ |
| **Mutex&lt;T&gt;** | Shared mutable state | ‚úÖ |
| **RwLock&lt;T&gt;** | Many readers, few writers | ‚úÖ |

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_demo() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

---

## üéØ TH·ª∞C H√ÄNH: MULTI-THREADED FILE PROCESSOR

```rust
use std::sync::{Arc, Mutex, mpsc};
use std::thread;
use std::fs;
use std::io;

struct FileProcessor {
    results: Arc<Mutex<Vec<String>>>,
}

impl FileProcessor {
    fn new() -> Self {
        FileProcessor {
            results: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    fn process_files(&self, file_paths: Vec<String>) -> io::Result<()> {
        let (tx, rx) = mpsc::channel();
        let results = Arc::clone(&self.results);
        
        // Worker threads
        let mut handles = vec![];
        for _ in 0..4 {
            let rx = rx.clone();
            let results = Arc::clone(&results);
            
            let handle = thread::spawn(move || {
                while let Ok(path) = rx.recv() {
                    match fs::read_to_string(&path) {
                        Ok(content) => {
                            let word_count = content.split_whitespace().count();
                            let result = format!("{}: {} words", path, word_count);
                            results.lock().unwrap().push(result);
                        }
                        Err(e) => {
                            let error = format!("{}: Error - {}", path, e);
                            results.lock().unwrap().push(error);
                        }
                    }
                }
            });
            handles.push(handle);
        }
        
        // Send work to threads
        for path in file_paths {
            tx.send(path).unwrap();
        }
        drop(tx); // Close channel
        
        // Wait for completion
        for handle in handles {
            handle.join().unwrap();
        }
        
        Ok(())
    }
    
    fn get_results(&self) -> Vec<String> {
        self.results.lock().unwrap().clone()
    }
}

fn main() -> io::Result<()> {
    let processor = FileProcessor::new();
    let files = vec![
        "file1.txt".to_string(),
        "file2.txt".to_string(),
        "file3.txt".to_string(),
    ];
    
    processor.process_files(files)?;
    
    for result in processor.get_results() {
        println!("{}", result);
    }
    
    Ok(())
}
```

---

## üìä PERFORMANCE COMPARISON

<div className="overflow-x-auto">
  <table className="min-w-full bg-white border border-gray-300">
    <thead className="bg-gray-100">
      <tr>
        <th className="px-4 py-2 border-b">Collection</th>
        <th className="px-4 py-2 border-b">Insert</th>
        <th className="px-4 py-2 border-b">Lookup</th>
        <th className="px-4 py-2 border-b">Iteration</th>
        <th className="px-4 py-2 border-b">Memory</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="px-4 py-2 border-b font-mono">Vec</td>
        <td className="px-4 py-2 border-b">O(1) amortized</td>
        <td className="px-4 py-2 border-b">O(n)</td>
        <td className="px-4 py-2 border-b">O(n)</td>
        <td className="px-4 py-2 border-b">Compact</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="px-4 py-2 border-b font-mono">HashMap</td>
        <td className="px-4 py-2 border-b">O(1) average</td>
        <td className="px-4 py-2 border-b">O(1) average</td>
        <td className="px-4 py-2 border-b">O(n)</td>
        <td className="px-4 py-2 border-b">Overhead</td>
      </tr>
      <tr>
        <td className="px-4 py-2 border-b font-mono">BTreeMap</td>
        <td className="px-4 py-2 border-b">O(log n)</td>
        <td className="px-4 py-2 border-b">O(log n)</td>
        <td className="px-4 py-2 border-b">O(n) sorted</td>
        <td className="px-4 py-2 border-b">Balanced</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="px-4 py-2 border-b font-mono">VecDeque</td>
        <td className="px-4 py-2 border-b">O(1) both ends</td>
        <td className="px-4 py-2 border-b">O(n)</td>
        <td className="px-4 py-2 border-b">O(n)</td>
        <td className="px-4 py-2 border-b">Ring buffer</td>
      </tr>
    </tbody>
  </table>
</div>

---

## üîç CONCURRENCY PATTERNS

```mermaid
graph LR
    A[Concurrency Patterns] --> B[Message Passing]
    A --> C[Shared State]
    A --> D[Actor Model]
    
    B --> E[mpsc::channel]
    B --> F[crossbeam-channel]
    
    C --> G[Mutex]
    C --> H[RwLock]
    C --> I[Atomic Types]
    
    D --> J[tokio actors]
    D --> K[actix]
```

### Best Practices cho Concurrency

<div className="bg-gray-50 p-6 rounded-lg">
  <h4 className="font-bold mb-4">‚úÖ DOs:</h4>
  <ul className="space-y-2 mb-4">
    <li>‚Ä¢ ∆Øu ti√™n message passing h∆°n shared state</li>
    <li>‚Ä¢ S·ª≠ d·ª•ng Arc&lt;Mutex&lt;T&gt;&gt; cho shared mutable data</li>
    <li>‚Ä¢ Handle panics trong threads</li>
    <li>‚Ä¢ Use thread pools cho CPU-intensive tasks</li>
  </ul>
  
  <h4 className="font-bold mb-4">‚ùå DON'Ts:</h4>
  <ul className="space-y-2">
    <li>‚Ä¢ Avoid sharing raw pointers between threads</li>
    <li>‚Ä¢ Don't ignore join() results</li>
    <li>‚Ä¢ Avoid excessive lock contention</li>
    <li>‚Ä¢ Don't create too many threads</li>
  </ul>
</div>

---

## üí° KEY TAKEAWAYS

<div className="bg-gradient-to-r from-green-400 to-blue-500 text-white p-6 rounded-lg">
  <h3 className="text-xl font-bold mb-4">ƒêi·ªÉm quan tr·ªçng:</h3>
  <ul className="space-y-2">
    <li>üóÇÔ∏è <strong>Advanced Collections:</strong> Ch·ªçn collection ph√π h·ª£p cho t·ª´ng use case</li>
    <li>üîó <strong>Rc/Arc:</strong> Enable shared ownership khi c·∫ßn thi·∫øt</li>
    <li>üîí <strong>RefCell:</strong> Interior mutability v·ªõi runtime borrow checking</li>
    <li>üßµ <strong>Threading:</strong> Rust ƒë·∫£m b·∫£o thread safety t·∫°i compile time</li>
    <li>üì® <strong>Channels:</strong> An to√†n cho communication between threads</li>
    <li>üîê <strong>Mutex:</strong> Synchronize access to shared mutable data</li>
  </ul>
</div>

---

## üéì B√ÄI T·∫¨P V·ªÄ NH√Ä

1. **Th·ª±c h√†nh Collections**: Implement m·ªôt URL shortener s·ª≠ d·ª•ng BTreeMap
2. **Concurrency Project**: T·∫°o web crawler s·ª≠ d·ª•ng multiple threads
3. **Performance Testing**: So s√°nh hi·ªáu su·∫•t c·ªßa c√°c collections kh√°c nhau
4. **Thread Pool**: Implement custom thread pool cho task processing

---

<div className="bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded mt-8">
  <strong>üìö Chu·∫©n b·ªã cho b√†i ti·∫øp theo:</strong> Trong b√†i 16, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu v·ªÅ Async Programming v·ªõi futures v√† async/await syntax.
</div>