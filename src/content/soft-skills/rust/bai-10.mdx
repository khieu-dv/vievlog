# B√ÄI 10: ERROR HANDLING TRONG RUST

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border-l-4 border-blue-500 mb-6">
  <h2 className="text-2xl font-bold text-blue-800 mb-2">üéØ M·ª§C TI√äU B√ÄI H·ªåC</h2>
  <div className="text-gray-700">X·ª≠ l√Ω errors m·ªôt c√°ch an to√†n v√† hi·ªáu qu·∫£ trong Rust th√¥ng qua h·ªá th·ªëng type-safe error handling</div>
</div>

## üìã N·ªòI DUNG CH√çNH

```mermaid
graph TD
    A[Error Handling] --> B[Recoverable Errors]
    A --> C[Unrecoverable Errors]
    
    B --> D[Result T E]
    B --> E[Option T]
    
    C --> F[panic!]
    
    D --> G[match expressions]
    D --> H[? operator]
    D --> I[unwrap/expect]
    
    E --> J[Some/None]
    E --> K[if let]
```

---

## 1. T·ªîNG QUAN V·ªÄ ERROR HANDLING

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
  <h3 className="text-lg font-semibold text-yellow-800">‚ö° ƒê·∫∑c ƒëi·ªÉm c·ªßa Rust Error Handling</h3>
  <div className="mt-2 text-gray-700">
    <div>‚Ä¢ No null pointers - s·ª≠ d·ª•ng <code>Option&lt;T&gt;</code></div>
    <div>‚Ä¢ No exceptions - s·ª≠ d·ª•ng <code>Result&lt;T, E&gt;</code></div>
    <div>‚Ä¢ Compile-time guarantee v·ªÅ error handling</div>
    <div>‚Ä¢ Explicit error propagation</div>
  </div>
</div>

### So s√°nh v·ªõi c√°c ng√¥n ng·ªØ kh√°c

| Ng√¥n ng·ªØ | Error Handling | Nh∆∞·ª£c ƒëi·ªÉm |
|----------|----------------|------------|
| Java/C# | Exceptions | Runtime overhead, c√≥ th·ªÉ b·ªã b·ªè qua |
| C | Return codes | D·ªÖ b·ªã ignore, kh√¥ng type-safe |
| Go | Multiple return values | Verbose, c√≥ th·ªÉ b·ªè qua |
| **Rust** | **Result/Option** | **Compile-time safe, explicit** |

---

## 2. OPTION&lt;T&gt; ENUM

### ƒê·ªãnh nghƒ©a v√† c√°ch s·ª≠ d·ª•ng

```rust
enum Option<T> {
    Some(T),
    None,
}
```

<div className="bg-green-50 border border-green-200 rounded-lg p-4">
  <h4 className="font-semibold text-green-800">‚úÖ Khi n√†o s·ª≠ d·ª•ng Option&lt;T&gt;?</h4>
  <div className="text-gray-700 mt-2">Khi m·ªôt gi√° tr·ªã c√≥ th·ªÉ t·ªìn t·∫°i ho·∫∑c kh√¥ng (thay th·∫ø cho null/nil)</div>
</div>

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some("Alice".to_string())
    } else {
        None
    }
}

fn main() {
    // C√°ch 1: S·ª≠ d·ª•ng match
    match find_user(1) {
        Some(name) => println!("Found user: {}", name),
        None => println!("User not found"),
    }
    
    // C√°ch 2: S·ª≠ d·ª•ng if let
    if let Some(name) = find_user(1) {
        println!("User found: {}", name);
    }
    
    // C√°ch 3: S·ª≠ d·ª•ng unwrap_or
    let name = find_user(2).unwrap_or("Unknown".to_string());
    println!("Name: {}", name);
}
```

### C√°c ph∆∞∆°ng th·ª©c h·ªØu √≠ch c·ªßa Option

| Method | M√¥ t·∫£ | V√≠ d·ª• |
|--------|-------|-------|
| `is_some()` | Ki·ªÉm tra c√≥ gi√° tr·ªã | `opt.is_some()` |
| `is_none()` | Ki·ªÉm tra kh√¥ng c√≥ gi√° tr·ªã | `opt.is_none()` |
| `unwrap()` | L·∫•y gi√° tr·ªã (panic n·∫øu None) | `opt.unwrap()` |
| `unwrap_or(default)` | L·∫•y gi√° tr·ªã ho·∫∑c default | `opt.unwrap_or(0)` |
| `map(f)` | Transform gi√° tr·ªã n·∫øu Some | `opt.map(|x| x * 2)` |

---

## 3. RESULT&lt;T, E&gt; ENUM

### ƒê·ªãnh nghƒ©a v√† ·ª©ng d·ª•ng

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

```mermaid
flowchart TD
    A[Operation] --> B{Success?}
    B -->|Yes| C[Ok value]
    B -->|No| D[Err error]
    
    C --> E[Continue processing]
    D --> F[Handle error]
```

### V√≠ d·ª• th·ª±c t·∫ø v·ªõi file I/O

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_content(filename: &str) -> Result<String, io::Error> {
    let mut file = File::open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file_content("example.txt") {
        Ok(content) => println!("File content: {}", content),
        Err(error) => println!("Error reading file: {}", error),
    }
}
```

### B·∫£ng so s√°nh c√°c c√°ch x·ª≠ l√Ω Result

| Ph∆∞∆°ng ph√°p | C√∫ ph√°p | Khi n√†o s·ª≠ d·ª•ng | An to√†n |
|-------------|---------|-----------------|---------|
| `match` | `match result { Ok(v) => ..., Err(e) => ... }` | C·∫ßn x·ª≠ l√Ω c·∫£ 2 tr∆∞·ªùng h·ª£p | ‚úÖ |
| `unwrap()` | `result.unwrap()` | Ch·∫Øc ch·∫Øn kh√¥ng c√≥ l·ªói | ‚ùå (panic) |
| `expect()` | `result.expect("message")` | Debug, v·ªõi th√¥ng b√°o r√µ r√†ng | ‚ùå (panic) |
| `?` operator | `let value = operation()?;` | Propagate l·ªói l√™n caller | ‚úÖ |

---

## 4. TO√ÅN T·ª¨ ? (QUESTION MARK OPERATOR)

<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
  <h3 className="text-lg font-semibold text-blue-800">üöÄ T√≠nh nƒÉng n·ªïi b·∫≠t</h3>
  <div className="text-gray-700">To√°n t·ª≠ <code>?</code> gi√∫p code ng·∫Øn g·ªçn v√† d·ªÖ ƒë·ªçc h∆°n khi x·ª≠ l√Ω chu·ªói operations c√≥ th·ªÉ fail</div>
</div>

### Tr∆∞·ªõc v√† sau khi s·ª≠ d·ª•ng ?

```rust
// C√°ch c≈© - verbose
fn read_username_from_file() -> Result<String, io::Error> {
    let mut file = match File::open("username.txt") {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    
    let mut username = String::new();
    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}

// C√°ch m·ªõi - v·ªõi ? operator
fn read_username_from_file_v2() -> Result<String, io::Error> {
    let mut file = File::open("username.txt")?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    Ok(username)
}

// Ng·∫Øn g·ªçn nh·∫•t
fn read_username_from_file_v3() -> Result<String, io::Error> {
    std::fs::read_to_string("username.txt")
}
```

```mermaid
sequenceDiagram
    participant F as Function
    participant O1 as Operation 1
    participant O2 as Operation 2
    participant C as Caller
    
    F->>O1: Call with ?
    alt Success
        O1->>F: Ok(value)
        F->>O2: Call with ?
        alt Success
            O2->>F: Ok(final_value)
            F->>C: Ok(result)
        else Error
            O2->>C: Err(error) [propagated]
        end
    else Error
        O1->>C: Err(error) [propagated]
    end
```

---

## 5. CUSTOM ERROR TYPES

### T·∫°o Error Type ƒë∆°n gi·∫£n

```rust
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    NegativeSquareRoot,
}

impl std::fmt::Display for MathError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            MathError::DivisionByZero => write!(f, "Cannot divide by zero"),
            MathError::NegativeSquareRoot => write!(f, "Cannot calculate square root of negative number"),
        }
    }
}

impl std::error::Error for MathError {}

fn divide(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn sqrt(x: f64) -> Result<f64, MathError> {
    if x < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(x.sqrt())
    }
}
```

### Error conversion v√† From trait

```rust
use std::fs::File;
use std::io;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Math(MathError),
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<MathError> for AppError {
    fn from(error: MathError) -> Self {
        AppError::Math(error)
    }
}

fn complex_operation() -> Result<String, AppError> {
    let file = File::open("data.txt")?; // io::Error -> AppError
    let result = divide(10.0, 0.0)?;    // MathError -> AppError
    Ok(format!("Result: {}", result))
}
```

---

## 6. PANIC! V√Ä UNRECOVERABLE ERRORS

<div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
  <h3 className="text-lg font-semibold text-red-800">‚ö†Ô∏è Khi n√†o s·ª≠ d·ª•ng panic!</h3>
  <div className="mt-2 text-gray-700">
    <div>‚Ä¢ Bugs trong code (array out of bounds)</div>
    <div>‚Ä¢ Invariants b·ªã vi ph·∫°m</div>
    <div>‚Ä¢ Prototype/testing</div>
    <div>‚Ä¢ Kh√¥ng th·ªÉ recover ƒë∆∞·ª£c</div>
  </div>
</div>

```rust
fn main() {
    // Panic v·ªõi message
    panic!("Something went terribly wrong!");
    
    // Panic t·ª´ unwrap
    let result: Result<i32, &str> = Err("error");
    let value = result.unwrap(); // Panic!
    
    // Panic v·ªõi expect (better message)
    let value = result.expect("Failed to get value"); // Panic with custom message
}
```

### Panic vs Result - Khi n√†o d√πng g√¨?

| T√¨nh hu·ªëng | S·ª≠ d·ª•ng | L√Ω do |
|------------|---------|--------|
| File kh√¥ng t·ªìn t·∫°i | `Result` | C√≥ th·ªÉ recover (t·∫°o file m·ªõi, d√πng default) |
| Array index out of bounds | `panic!` | Bug trong code |
| Network timeout | `Result` | C√≥ th·ªÉ retry |
| Out of memory | `panic!` | Kh√¥ng th·ªÉ continue |
| Invalid config | `Result` | C√≥ th·ªÉ d√πng default config |

---

## 7. BEST PRACTICES V√Ä PATTERNS

### Pattern 1: Early Return v·ªõi ?

```rust
fn process_data() -> Result<String, Box<dyn std::error::Error>> {
    let data = read_file("input.txt")?;
    let parsed = parse_data(&data)?;
    let processed = transform_data(parsed)?;
    let result = format_output(processed)?;
    Ok(result)
}
```

### Pattern 2: Combinator Methods

```rust
fn main() {
    let result = read_file("config.json")
        .and_then(|content| parse_json(&content))
        .and_then(|config| validate_config(config))
        .map(|config| format!("Config loaded: {:?}", config))
        .unwrap_or_else(|e| format!("Error: {}", e));
    
    println!("{}", result);
}
```

### Pattern 3: Error Context v·ªõi th∆∞ vi·ªán anyhow

```rust
// Cargo.toml
// [dependencies]
// anyhow = "1.0"

use anyhow::{Context, Result};

fn read_config() -> Result<Config> {
    let content = std::fs::read_to_string("config.toml")
        .context("Failed to read config file")?;
    
    let config: Config = toml::from_str(&content)
        .context("Failed to parse config file")?;
    
    Ok(config)
}
```

---

## 8. TH·ª∞C H√ÄNH: FILE PROCESSING SYSTEM

<div className="bg-purple-50 border border-purple-200 rounded-lg p-4 mb-4">
  <h3 className="text-lg font-semibold text-purple-800">üõ†Ô∏è B√ÄI T·∫¨P TH·ª∞C H√ÄNH</h3>
  <div className="text-gray-700">X√¢y d·ª±ng h·ªá th·ªëng x·ª≠ l√Ω file v·ªõi error handling ho√†n ch·ªânh</div>
</div>

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader, Write};
use std::path::Path;

#[derive(Debug)]
enum ProcessError {
    Io(io::Error),
    Parse(std::num::ParseIntError),
    Validation(String),
}

impl From<io::Error> for ProcessError {
    fn from(error: io::Error) -> Self {
        ProcessError::Io(error)
    }
}

impl From<std::num::ParseIntError> for ProcessError {
    fn from(error: std::num::ParseIntError) -> Self {
        ProcessError::Parse(error)
    }
}

struct FileProcessor;

impl FileProcessor {
    fn process_numbers_file(input_path: &Path, output_path: &Path) -> Result<usize, ProcessError> {
        let input_file = File::open(input_path)?;
        let reader = BufReader::new(input_file);
        
        let mut output_file = File::create(output_path)?;
        let mut processed_count = 0;
        
        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;
            
            // Skip empty lines
            if line.trim().is_empty() {
                continue;
            }
            
            // Parse number
            let number: i32 = line.trim().parse()
                .map_err(|e| ProcessError::Validation(
                    format!("Invalid number at line {}: {}", line_num + 1, e)
                ))?;
            
            // Validate positive numbers only
            if number <= 0 {
                return Err(ProcessError::Validation(
                    format!("Negative number at line {}: {}", line_num + 1, number)
                ));
            }
            
            // Process (square the number)
            let result = number * number;
            writeln!(output_file, "{}", result)?;
            processed_count += 1;
        }
        
        Ok(processed_count)
    }
    
    fn create_sample_file(path: &Path) -> Result<(), ProcessError> {
        let mut file = File::create(path)?;
        writeln!(file, "1")?;
        writeln!(file, "2")?;
        writeln!(file, "3")?;
        writeln!(file, "4")?;
        writeln!(file, "5")?;
        Ok(())
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let input_path = Path::new("input.txt");
    let output_path = Path::new("output.txt");
    
    // Create sample input file
    FileProcessor::create_sample_file(input_path)?;
    println!("‚úÖ Created sample input file");
    
    // Process file
    match FileProcessor::process_numbers_file(input_path, output_path) {
        Ok(count) => {
            println!("‚úÖ Successfully processed {} numbers", count);
            
            // Read and display results
            let results = std::fs::read_to_string(output_path)?;
            println!("Results:\n{}", results);
        }
        Err(ProcessError::Io(e)) => {
            eprintln!("‚ùå IO Error: {}", e);
        }
        Err(ProcessError::Parse(e)) => {
            eprintln!("‚ùå Parse Error: {}", e);
        }
        Err(ProcessError::Validation(e)) => {
            eprintln!("‚ùå Validation Error: {}", e);
        }
    }
    
    Ok(())
}
```

---

## 9. T√ìM T·∫ÆT V√Ä KI·ªÇM TRA

### Checklist ki·∫øn th·ª©c

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
  <div className="bg-gray-50 p-4 rounded-lg">
    <h4 className="font-semibold text-gray-800">‚úÖ C·∫ßn n·∫Øm v·ªØng:</h4>
    <ul className="mt-2 space-y-1 text-sm text-gray-700">
      <li>‚ñ° Option&lt;T&gt; cho nullable values</li>
      <li>‚ñ° Result&lt;T, E&gt; cho recoverable errors</li>
      <li>‚ñ° ? operator cho error propagation</li>
      <li>‚ñ° match vs if let vs unwrap</li>
      <li>‚ñ° Custom error types</li>
      <li>‚ñ° panic! cho unrecoverable errors</li>
    </ul>
  </div>
  
  <div className="bg-gray-50 p-4 rounded-lg">
    <h4 className="font-semibold text-gray-800">üéØ M·ª•c ti√™u ti·∫øp theo:</h4>
    <ul className="mt-2 space-y-1 text-sm text-gray-700">
      <li>‚Ä¢ Modules v√† crate organization</li>
      <li>‚Ä¢ Advanced error handling patterns</li>
      <li>‚Ä¢ Testing error conditions</li>
      <li>‚Ä¢ Async error handling</li>
    </ul>
  </div>
</div>

### Key Takeaways

```mermaid
mindmap
  root)Error Handling(
    Option<T>
      Some(value)
      None
      is_some/is_none
      unwrap_or
    Result<T,E>
      Ok(value)
      Err(error)
      ? operator
      match/if let
    Patterns
      Early return
      Combinators
      Custom errors
      From trait
    Best Practices
      Prefer Result over panic
      Use ? for propagation  
      Meaningful error messages
      Error context
```

---

<div className="bg-green-100 border border-green-300 rounded-lg p-4 mt-6">
  <h3 className="text-lg font-semibold text-green-800">üéâ HO√ÄN TH√ÄNH B√ÄI 10</h3>
  <div className="text-gray-700 mt-2">
    B·∫°n ƒë√£ h·ªçc xong error handling trong Rust! ƒê√¢y l√† m·ªôt trong nh·ªØng t√≠nh nƒÉng quan tr·ªçng nh·∫•t gi√∫p Rust tr·ªü th√†nh ng√¥n ng·ªØ an to√†n v√† ƒë√°ng tin c·∫≠y. 
    <br /><br />
    <strong>B√†i ti·∫øp theo:</strong> Modules v√† Crates - T·ªï ch·ª©c code hi·ªáu qu·∫£
  </div>
</div>