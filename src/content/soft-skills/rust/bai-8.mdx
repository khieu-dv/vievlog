# B√ÄI 8: OWNERSHIP SYSTEM - CORE CONCEPTS

<div className="bg-gradient-to-r from-blue-50 to-indigo-100 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
  <h2 className="text-2xl font-bold text-blue-900 mb-2">üéØ M·ª•c Ti√™u B√†i H·ªçc</h2>
  <p className="text-blue-800">Hi·ªÉu s√¢u v·ªÅ ownership - t√≠nh nƒÉng ƒë·∫∑c tr∆∞ng v√† m·∫°nh m·∫Ω nh·∫•t c·ªßa Rust, ƒë·∫£m b·∫£o memory safety m√† kh√¥ng c·∫ßn garbage collector.</p>
</div>

## 1. Gi·ªõi Thi·ªáu Ownership System

**Ownership** l√† h·ªá th·ªëng qu·∫£n l√Ω b·ªô nh·ªõ ƒë·ªôc ƒë√°o c·ªßa Rust, gi√∫p ƒë·∫£m b·∫£o memory safety t·∫°i compile time m√† kh√¥ng c·∫ßn garbage collector.

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 my-6">
  <p className="font-semibold text-yellow-800">üí° T·∫°i Sao Ownership Quan Tr·ªçng?</p>
  <ul className="list-disc list-inside text-yellow-700 mt-2">
    <li>NgƒÉn ng·ª´a memory leaks</li>
    <li>Tr√°nh double-free errors</li>
    <li>Lo·∫°i b·ªè dangling pointers</li>
    <li>ƒê·∫£m b·∫£o thread safety</li>
  </ul>
</div>

### So S√°nh Qu·∫£n L√Ω Memory

| Ph∆∞∆°ng Ph√°p | Ng√¥n Ng·ªØ | ∆Øu ƒêi·ªÉm | Nh∆∞·ª£c ƒêi·ªÉm |
|-------------|----------|---------|------------|
| **Manual** | C/C++ | Hi·ªáu su·∫•t cao, ki·ªÉm so√°t t·ªëi ƒëa | D·ªÖ c√≥ l·ªói memory |
| **Garbage Collection** | Java, Python | An to√†n, d·ªÖ s·ª≠ d·ª•ng | Overhead, pause time |
| **Ownership** | Rust | An to√†n + Hi·ªáu su·∫•t cao | Learning curve cao |

## 2. Ba Quy T·∫Øc Ownership C∆° B·∫£n

<div className="bg-red-50 border-l-4 border-red-500 p-4 mb-6">
  <h3 className="font-bold text-red-900 mb-3">üìú Quy T·∫Øc Ownership</h3>
  <ol className="list-decimal list-inside text-red-800 space-y-2">
    <li><strong>M·ªói value trong Rust c√≥ m·ªôt owner</strong></li>
    <li><strong>T·∫°i m·ªói th·ªùi ƒëi·ªÉm ch·ªâ c√≥ m·ªôt owner</strong></li>
    <li><strong>Khi owner ra kh·ªèi scope, value s·∫Ω ƒë∆∞·ª£c dropped</strong></li>
  </ol>
</div>

```mermaid
graph TD
    A[Value ƒë∆∞·ª£c t·∫°o] --> B[G√°n cho Variable]
    B --> C[Variable tr·ªü th√†nh Owner]
    C --> D[Variable ra kh·ªèi scope]
    D --> E[Value ƒë∆∞·ª£c dropped/freed]
    
    style A fill:#e1f5fe
    style C fill:#c8e6c9
    style E fill:#ffcdd2
```

## 3. Stack vs Heap Memory

### Stack Memory

<div className="bg-green-50 p-4 rounded-lg mb-4">
  <h4 className="font-bold text-green-900 mb-2">üè† Stack Characteristics</h4>
  <ul className="text-green-800 space-y-1">
    <li>‚Ä¢ Fast access (LIFO - Last In, First Out)</li>
    <li>‚Ä¢ Fixed size data</li>
    <li>‚Ä¢ Automatic cleanup</li>
    <li>‚Ä¢ Known size at compile time</li>
  </ul>
</div>

### Heap Memory

<div className="bg-orange-50 p-4 rounded-lg mb-4">
  <h4 className="font-bold text-orange-900 mb-2">üåä Heap Characteristics</h4>
  <ul className="text-orange-800 space-y-1">
    <li>‚Ä¢ Slower access (pointer indirection)</li>
    <li>‚Ä¢ Dynamic size data</li>
    <li>‚Ä¢ Manual or automatic cleanup</li>
    <li>‚Ä¢ Size determined at runtime</li>
  </ul>
</div>

| Ki·ªÉu D·ªØ Li·ªáu | V·ªã Tr√≠ L∆∞u Tr·ªØ | L√Ω Do |
|---------------|----------------|--------|
| `i32`, `f64`, `bool` | Stack | K√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh |
| `String`, `Vec<T>` | Heap | K√≠ch th∆∞·ªõc ƒë·ªông |
| `&str` (string slice) | Stack (pointer) + Stack/Static (data) | Reference |

## 4. Move Semantics

```rust
fn main() {
    // String ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n heap
    let s1 = String::from("Hello");
    let s2 = s1; // s1 ƒë∆∞·ª£c MOVED v√†o s2
    
    // println!("{}", s1); // ‚ùå ERROR: s1 kh√¥ng c√≤n valid
    println!("{}", s2); // ‚úÖ OK: s2 l√† owner m·ªõi
}
```

```mermaid
sequenceDiagram
    participant Stack
    participant Heap
    
    Note over Stack,Heap: let s1 = String::from("Hello")
    Stack->>Heap: Allocate memory for "Hello"
    Stack->>Stack: s1 points to heap data
    
    Note over Stack,Heap: let s2 = s1
    Stack->>Stack: s2 gets s1's pointer
    Stack->>Stack: s1 becomes invalid
    
    Note over Stack,Heap: s1 ra kh·ªèi scope
    Note over Stack,Heap: s2 ra kh·ªèi scope
    Stack->>Heap: Free memory (ch·ªâ m·ªôt l·∫ßn)
```

### Khi N√†o Move X·∫£y Ra?

| Tr∆∞·ªùng H·ª£p | V√≠ D·ª• | Move? |
|-------------|--------|-------|
| **Assignment** | `let s2 = s1;` | ‚úÖ Yes |
| **Function call** | `take_ownership(s1);` | ‚úÖ Yes |
| **Return value** | `return s1;` | ‚úÖ Yes |
| **Copy types** | `let x2 = x1; // i32` | ‚ùå No (Copy) |

## 5. Copy Trait vs Clone Trait

### Copy Trait

<div className="bg-blue-50 p-4 rounded-lg mb-4">
  <h4 className="font-bold text-blue-900 mb-2">üìã Copy Trait</h4>
  <p className="text-blue-800">Automatic, lightweight copy operation cho c√°c types c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh</p>
</div>

```rust
fn main() {
    let x = 5;        // i32 implements Copy
    let y = x;        // x ƒë∆∞·ª£c copy, v·∫´n valid
    
    println!("x: {}, y: {}", x, y); // ‚úÖ Both are valid
}
```

**C√°c ki·ªÉu implement Copy:**

| Nh√≥m | Ki·ªÉu D·ªØ Li·ªáu |
|------|-------------|
| **Integers** | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` |
| **Unsigned** | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` |
| **Floats** | `f32`, `f64` |
| **Others** | `bool`, `char` |
| **Tuples** | `(i32, i32)` (n·∫øu t·∫•t c·∫£ elements ƒë·ªÅu Copy) |
| **Arrays** | `[i32; 3]` (n·∫øu element type l√† Copy) |

### Clone Trait

<div className="bg-purple-50 p-4 rounded-lg mb-4">
  <h4 className="font-bold text-purple-900 mb-2">üîÑ Clone Trait</h4>
  <p className="text-purple-800">Explicit, potentially expensive deep copy operation</p>
</div>

```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = s1.clone(); // Explicit clone
    
    println!("s1: {}, s2: {}", s1, s2); // ‚úÖ Both valid
}
```

## 6. Ownership v·ªõi Functions

### Passing Ownership

```rust
fn take_ownership(s: String) {
    println!("{}", s);
} // s goes out of scope and is dropped

fn main() {
    let s = String::from("Hello");
    take_ownership(s); // s moved into function
    // println!("{}", s); // ‚ùå ERROR: s no longer valid
}
```

### Returning Ownership

```rust
fn give_ownership() -> String {
    String::from("Hello") // Return moves out
}

fn take_and_give_back(s: String) -> String {
    s // Return moves out
}

fn main() {
    let s1 = give_ownership();
    let s2 = String::from("World");
    let s3 = take_and_give_back(s2);
    
    println!("{} {}", s1, s3);
    // s2 kh√¥ng c√≤n valid, ƒë√£ moved v√†o function
}
```

```mermaid
graph LR
    A[main function] --> B[give_ownership]
    B --> C[Return String]
    C --> A
    
    A --> D[take_and_give_back]
    D --> E[Return received String]
    E --> A
    
    style C fill:#c8e6c9
    style E fill:#c8e6c9
```

## 7. Scope v√† RAII (Resource Acquisition Is Initialization)

### Automatic Cleanup

```rust
fn main() {
    {
        let s = String::from("Hello"); // s comes into scope
        // do stuff with s
    } // s goes out of scope, drop is called
    
    // s is no longer valid here
}
```

### Custom Drop Implementation

```rust
struct MyStruct {
    data: String,
}

impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Dropping MyStruct with data: {}", self.data);
    }
}

fn main() {
    let my_struct = MyStruct {
        data: String::from("Hello"),
    };
    // my_struct will be automatically dropped here
}
```

## 8. Common Ownership Patterns

### Pattern 1: Function Parameters

| Pattern | Use Case | Ownership |
|---------|----------|-----------|
| `fn process(s: String)` | Take ownership | Caller loses ownership |
| `fn process(s: &String)` | Borrow (read-only) | Caller keeps ownership |
| `fn process(s: &mut String)` | Borrow (mutable) | Caller keeps ownership |

### Pattern 2: Return Values

```rust
// ‚ùå Problematic: Creating and immediately moving
fn bad_pattern() -> String {
    let s = String::from("Hello");
    s // Moves out, but could be optimized
}

// ‚úÖ Better: Direct construction
fn good_pattern() -> String {
    String::from("Hello") // Direct return
}
```

## 9. Debugging Ownership Issues

### Common Compiler Messages

<div className="bg-gray-50 p-4 rounded-lg mb-4">
  <h4 className="font-bold text-gray-900 mb-2">üîç Error: "value moved here"</h4>
  <pre className="text-sm text-gray-800">
error[E0382]: borrow of moved value: `s`
  --> src/main.rs:4:20
   |
2  |     let s = String::from("hello");
   |         - move occurs because `s` has type `String`
3  |     let s2 = s;
   |              - value moved here
4  |     println!("{}", s);
   |                    ^ value borrowed here after move
  </pre>
</div>

### Debugging Strategy

```mermaid
flowchart TD
    A[Ownership Error] --> B{Variable used after move?}
    B -->|Yes| C[Use borrowing]
    B -->|No| D{Need multiple copies?}
    D -->|Yes| E[Use clone]
    D -->|No| F[Restructure code]
    
    C --> G[Fixed]
    E --> G
    F --> G
    
    style A fill:#ffcdd2
    style G fill:#c8e6c9
```

## 10. Th·ª±c H√†nh

### B√†i T·∫≠p 1: Ownership Transfer

```rust
fn main() {
    // TODO: Fix ownership issues
    let message = String::from("Hello, World!");
    print_message(message);
    print_length(message); // Error: value moved
}

fn print_message(msg: String) {
    println!("Message: {}", msg);
}

fn print_length(msg: String) {
    println!("Length: {}", msg.len());
}
```

<details>
<summary>üí° Gi·∫£i ph√°p</summary>

```rust
fn main() {
    let message = String::from("Hello, World!");
    print_message(&message);    // Borrow instead of move
    print_length(&message);     // Borrow instead of move
}

fn print_message(msg: &String) {  // Take reference
    println!("Message: {}", msg);
}

fn print_length(msg: &String) {   // Take reference
    println!("Length: {}", msg.len());
}
```
</details>

### B√†i T·∫≠p 2: Ownership v·ªõi Collections

```rust
fn process_data() -> Vec<String> {
    let mut data = Vec::new();
    
    // TODO: Implement without ownership issues
    let item1 = String::from("Hello");
    let item2 = String::from("World");
    
    data.push(item1);
    data.push(item2);
    
    // Return processed data
    data
}
```

## 11. T√≥m T·∫Øt

<div className="bg-indigo-50 border-l-4 border-indigo-500 p-6 mt-8">
  <h3 className="font-bold text-indigo-900 mb-4">üìö Ki·∫øn Th·ª©c Tr·ªçng T√¢m</h3>
  
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <h4 className="font-semibold text-indigo-800 mb-2">Core Concepts:</h4>
      <ul className="text-indigo-700 space-y-1">
        <li>‚Ä¢ Ba quy t·∫Øc ownership</li>
        <li>‚Ä¢ Move semantics</li>
        <li>‚Ä¢ Stack vs Heap</li>
        <li>‚Ä¢ Copy vs Clone</li>
      </ul>
    </div>
    
    <div>
      <h4 className="font-semibold text-indigo-800 mb-2">Best Practices:</h4>
      <ul className="text-indigo-700 space-y-1">
        <li>‚Ä¢ S·ª≠ d·ª•ng references khi possible</li>
        <li>‚Ä¢ Clone ch·ªâ khi c·∫ßn thi·∫øt</li>
        <li>‚Ä¢ Hi·ªÉu compiler messages</li>
        <li>‚Ä¢ Design around ownership</li>
      </ul>
    </div>
  </div>
</div>

**B√†i ti·∫øp theo:** B√†i 9 - Borrowing, References v√† Slices - H·ªçc c√°ch "m∆∞·ª£n" data m√† kh√¥ng chi·∫øm ownership!