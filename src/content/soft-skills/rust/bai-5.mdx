# B√ÄI 5: STRINGS V√Ä COLLECTIONS C∆† B·∫¢N

<div className="bg-gradient-to-r from-blue-500 to-purple-600 text-white p-6 rounded-lg shadow-lg mb-8">
  <h2 className="text-2xl font-bold mb-2">üéØ M·ª•c Ti√™u B√†i H·ªçc</h2>
  <p className="text-lg">L√†m vi·ªác hi·ªáu qu·∫£ v·ªõi strings v√† c√°c collections c∆° b·∫£n trong Rust</p>
</div>

## üìö N·ªôi Dung B√†i H·ªçc

### 1. Strings trong Rust

<div className="bg-yellow-100 border-l-4 border-yellow-500 p-4 mb-6">
  <h4 className="font-bold text-yellow-800">‚ö†Ô∏è ƒêi·ªÉm Quan Tr·ªçng</h4>
  <p className="text-yellow-700">Rust c√≥ hai lo·∫°i string ch√≠nh: <code>&str</code> (string slice) v√† <code>String</code> (owned string)</p>
</div>

#### 1.1 String Literals (&str)

```mermaid
graph TD
    A[String Literal] --> B["&str"]
    B --> C[Immutable]
    B --> D[Stack-allocated reference]
    B --> E[UTF-8 encoded]
    B --> F[Fixed size at compile time]
```

| ƒê·∫∑c ƒëi·ªÉm | M√¥ t·∫£ |
|----------|-------|
| Ki·ªÉu | `&str` (string slice) |
| Kh·∫£ nƒÉng thay ƒë·ªïi | Immutable |
| B·ªô nh·ªõ | Stack (reference), Heap (data) |
| K√≠ch th∆∞·ªõc | C·ªë ƒë·ªãnh t·∫°i compile time |

```rust
fn main() {
    let greeting = "Hello, World!"; // &str
    let name = "Rust"; // &str
    
    println!("{}", greeting);
    println!("Language: {}", name);
}
```

#### 1.2 String Type

```mermaid
graph TD
    A[String Type] --> B[Mutable]
    A --> C[Heap-allocated]
    A --> D[Growable]
    A --> E[UTF-8 encoded]
    A --> F[Runtime size]
```

| ƒê·∫∑c ƒëi·ªÉm | M√¥ t·∫£ |
|----------|-------|
| Ki·ªÉu | `String` |
| Kh·∫£ nƒÉng thay ƒë·ªïi | Mutable (v·ªõi `mut`) |
| B·ªô nh·ªõ | Heap-allocated |
| K√≠ch th∆∞·ªõc | C√≥ th·ªÉ thay ƒë·ªïi t·∫°i runtime |

```rust
fn main() {
    let mut my_string = String::new(); // T·∫°o String r·ªóng
    my_string.push_str("Hello");
    my_string.push(' ');
    my_string.push_str("Rust");
    
    println!("{}", my_string); // "Hello Rust"
}
```

### 2. String Methods v√† Operations

<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
  <h4 className="font-semibold text-blue-800 mb-2">üìã String Methods Ph·ªï Bi·∫øn</h4>
</div>

| Method | M√¥ t·∫£ | V√≠ d·ª• |
|--------|-------|-------|
| `String::new()` | T·∫°o String r·ªóng | `let s = String::new();` |
| `String::from()` | T·∫°o String t·ª´ &str | `let s = String::from("hello");` |
| `push_str()` | Th√™m &str v√†o cu·ªëi | `s.push_str(" world");` |
| `push()` | Th√™m char v√†o cu·ªëi | `s.push('!');` |
| `len()` | ƒê·ªô d√†i (bytes) | `s.len()` |
| `is_empty()` | Ki·ªÉm tra r·ªóng | `s.is_empty()` |

```rust
fn string_operations() {
    // T·∫°o String
    let mut message = String::from("Hello");
    
    // Concatenation
    message.push_str(", ");
    message.push_str("Rust");
    message.push('!');
    
    // String slicing
    let hello = &message[0..5]; // "Hello"
    let rust = &message[7..11]; // "Rust"
    
    println!("Full message: {}", message);
    println!("First part: {}", hello);
    println!("Second part: {}", rust);
}
```

### 3. Vectors (Vec&lt;T&gt;)

```mermaid
graph LR
    A[Vector] --> B[Dynamic Array]
    B --> C[Heap-allocated]
    B --> D[Growable]
    B --> E[Contiguous Memory]
    B --> F[Generic Type]
```

#### 3.1 Vector Creation v√† Manipulation

| Operation | Syntax | M√¥ t·∫£ |
|-----------|--------|-------|
| T·∫°o vector r·ªóng | `Vec::new()` | `let v: Vec<i32> = Vec::new();` |
| T·∫°o v·ªõi macro | `vec![]` | `let v = vec![1, 2, 3];` |
| Th√™m element | `push()` | `v.push(4);` |
| X√≥a element cu·ªëi | `pop()` | `v.pop();` |
| Truy c·∫≠p element | `[]` ho·∫∑c `get()` | `v[0]` ho·∫∑c `v.get(0)` |

```rust
fn vector_operations() {
    // T·∫°o vector
    let mut numbers = Vec::new();
    numbers.push(1);
    numbers.push(2);
    numbers.push(3);
    
    // Ho·∫∑c s·ª≠ d·ª•ng macro
    let mut fruits = vec!["apple", "banana", "orange"];
    
    // Truy c·∫≠p elements
    println!("First number: {}", numbers[0]);
    
    // An to√†n v·ªõi get()
    match numbers.get(10) {
        Some(value) => println!("Value: {}", value),
        None => println!("Index out of bounds"),
    }
    
    // Iteration
    for fruit in &fruits {
        println!("Fruit: {}", fruit);
    }
}
```

#### 3.2 Vector vs Array Comparison

<div className="overflow-x-auto">
  <table className="min-w-full bg-white border border-gray-300">
    <thead className="bg-gray-100">
      <tr>
        <th className="border border-gray-300 px-4 py-2 text-left">ƒê·∫∑c ƒëi·ªÉm</th>
        <th className="border border-gray-300 px-4 py-2 text-left">Array</th>
        <th className="border border-gray-300 px-4 py-2 text-left">Vector</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td className="border border-gray-300 px-4 py-2 font-medium">K√≠ch th∆∞·ªõc</td>
        <td className="border border-gray-300 px-4 py-2">C·ªë ƒë·ªãnh t·∫°i compile time</td>
        <td className="border border-gray-300 px-4 py-2">ƒê·ªông t·∫°i runtime</td>
      </tr>
      <tr className="bg-gray-50">
        <td className="border border-gray-300 px-4 py-2 font-medium">B·ªô nh·ªõ</td>
        <td className="border border-gray-300 px-4 py-2">Stack</td>
        <td className="border border-gray-300 px-4 py-2">Heap</td>
      </tr>
      <tr>
        <td className="border border-gray-300 px-4 py-2 font-medium">Performance</td>
        <td className="border border-gray-300 px-4 py-2">Nhanh h∆°n</td>
        <td className="border border-gray-300 px-4 py-2">Linh ho·∫°t h∆°n</td>
      </tr>
    </tbody>
  </table>
</div>

### 4. HashMaps

```mermaid
graph TD
    A[HashMap] --> B[Key-Value Storage]
    B --> C[Fast Lookup]
    B --> D[Unique Keys]
    B --> E[Hash-based]
    B --> F[Unordered]
```

#### 4.1 HashMap Operations

```rust
use std::collections::HashMap;

fn hashmap_operations() {
    // T·∫°o HashMap
    let mut scores = HashMap::new();
    
    // Insert key-value pairs
    scores.insert("Alice", 100);
    scores.insert("Bob", 85);
    scores.insert("Charlie", 92);
    
    // Truy c·∫≠p values
    match scores.get("Alice") {
        Some(score) => println!("Alice's score: {}", score),
        None => println!("Alice not found"),
    }
    
    // Update values
    scores.insert("Alice", 105); // Overwrite
    
    // Or update only if key doesn't exist
    scores.entry("David").or_insert(88);
    
    // Iterate
    for (name, score) in &scores {
        println!("{}: {}", name, score);
    }
}
```

#### 4.2 HashMap Methods

| Method | M√¥ t·∫£ | V√≠ d·ª• |
|--------|-------|-------|
| `insert(k, v)` | Th√™m/c·∫≠p nh·∫≠t key-value | `map.insert("key", 42);` |
| `get(&k)` | L·∫•y value theo key | `map.get("key")` |
| `contains_key(&k)` | Ki·ªÉm tra key t·ªìn t·∫°i | `map.contains_key("key")` |
| `remove(&k)` | X√≥a key-value | `map.remove("key")` |
| `entry(k)` | Entry API | `map.entry("key").or_insert(0)` |

### 5. String Formatting

<div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
  <h4 className="font-semibold text-green-800 mb-2">‚ú® String Formatting Macros</h4>
</div>

| Macro | M√¥ t·∫£ | Output |
|-------|-------|--------|
| `format!()` | T·∫°o String | Tr·∫£ v·ªÅ String |
| `print!()` | In ra stdout | Kh√¥ng c√≥ newline |
| `println!()` | In ra stdout | C√≥ newline |
| `eprint!()` | In ra stderr | Kh√¥ng c√≥ newline |
| `eprintln!()` | In ra stderr | C√≥ newline |

```rust
fn string_formatting() {
    let name = "Rust";
    let version = 1.70;
    
    // Basic formatting
    let message = format!("Hello, {}!", name);
    println!("{}", message);
    
    // Multiple parameters
    println!("Language: {}, Version: {}", name, version);
    
    // Named parameters
    println!("{lang} version {ver}", lang=name, ver=version);
    
    // Number formatting
    let pi = 3.14159;
    println!("Pi: {:.2}", pi); // 2 decimal places
    println!("Pi: {:08.2}", pi); // 8 width, 2 decimals, zero-padded
}
```

## üõ†Ô∏è Th·ª±c H√†nh

### B√†i T·∫≠p 1: Word Counter

```rust
use std::collections::HashMap;

fn word_counter(text: &str) -> HashMap<String, usize> {
    let mut word_count = HashMap::new();
    
    for word in text.split_whitespace() {
        let word = word.to_lowercase();
        *word_count.entry(word).or_insert(0) += 1;
    }
    
    word_count
}

fn main() {
    let text = "Hello world hello rust world";
    let counts = word_counter(text);
    
    for (word, count) in &counts {
        println!("{}: {}", word, count);
    }
}
```

### B√†i T·∫≠p 2: Simple Contact Manager

```rust
use std::collections::HashMap;

struct ContactManager {
    contacts: HashMap<String, String>,
}

impl ContactManager {
    fn new() -> ContactManager {
        ContactManager {
            contacts: HashMap::new(),
        }
    }
    
    fn add_contact(&mut self, name: String, phone: String) {
        self.contacts.insert(name, phone);
    }
    
    fn find_contact(&self, name: &str) -> Option<&String> {
        self.contacts.get(name)
    }
    
    fn list_contacts(&self) {
        for (name, phone) in &self.contacts {
            println!("{}: {}", name, phone);
        }
    }
}

fn main() {
    let mut manager = ContactManager::new();
    
    manager.add_contact("Alice".to_string(), "123-456-7890".to_string());
    manager.add_contact("Bob".to_string(), "098-765-4321".to_string());
    
    println!("All contacts:");
    manager.list_contacts();
    
    if let Some(phone) = manager.find_contact("Alice") {
        println!("Alice's phone: {}", phone);
    }
}
```

## üìã T√≥m T·∫Øt B√†i H·ªçc

```mermaid
mindmap
  root)Strings & Collections(
    Strings
      &str (literals)
      String (owned)
      Methods
      UTF-8
    Vectors
      Vec<T>
      Dynamic arrays
      Push/pop
      Indexing
    HashMaps
      Key-value
      Fast lookup
      Entry API
    Formatting
      format!
      println!
      Parameters
```

<div className="bg-gray-100 p-6 rounded-lg mt-8">
  <h3 className="text-xl font-bold mb-4">üéØ ƒêi·ªÉm C·∫ßn Nh·ªõ</h3>
  <ul className="space-y-2">
    <li className="flex items-start">
      <span className="text-blue-500 mr-2">‚Ä¢</span>
      <span><strong>&str</strong> l√† string slice (immutable), <strong>String</strong> l√† owned string (mutable)</span>
    </li>
    <li className="flex items-start">
      <span className="text-blue-500 mr-2">‚Ä¢</span>
      <span><strong>Vec&lt;T&gt;</strong> l√† dynamic array, c√≥ th·ªÉ grow/shrink t·∫°i runtime</span>
    </li>
    <li className="flex items-start">
      <span className="text-blue-500 mr-2">‚Ä¢</span>
      <span><strong>HashMap</strong> cung c·∫•p key-value storage v·ªõi O(1) lookup time</span>
    </li>
    <li className="flex items-start">
      <span className="text-blue-500 mr-2">‚Ä¢</span>
      <span>S·ª≠ d·ª•ng <strong>format!</strong> v√† c√°c macro li√™n quan ƒë·ªÉ format strings</span>
    </li>
    <li className="flex items-start">
      <span className="text-blue-500 mr-2">‚Ä¢</span>
      <span>Rust strings lu√¥n l√† valid UTF-8</span>
    </li>
  </ul>
</div>

## üîÑ B√†i Ti·∫øp Theo

Trong **B√†i 6**, ch√∫ng ta s·∫Ω h·ªçc v·ªÅ **Structs v√† Enums** - c√°ch t·∫°o custom data types ƒë·ªÉ organize data m·ªôt c√°ch hi·ªáu qu·∫£ h∆°n.