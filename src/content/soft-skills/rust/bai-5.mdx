# B√ÄI 5: STRINGS V√Ä COLLECTIONS C∆† B·∫¢N

<div className="bg-gradient-to-r from-orange-500 to-red-600 text-white p-6 rounded-lg mb-8 shadow-lg">
  <h2 className="text-2xl font-bold mb-2">üéØ M·ª§C TI√äU B√ÄI H·ªåC</h2>
  <p className="text-lg">L√†m vi·ªác hi·ªáu qu·∫£ v·ªõi strings v√† c√°c collections c∆° b·∫£n trong Rust</p>
</div>

## üìö T·ªîNG QUAN N·ªòI DUNG

```mermaid
graph TD
    A[Strings & Collections] --> B[String Types]
    A --> C[Vectors]
    A --> D[HashMaps]
    
    B --> B1[String Literals &str]
    B --> B2[String Type]
    B --> B3[String Methods]
    
    C --> C1[Vec Creation]
    C --> C2[Vec Manipulation]
    C --> C3[Vec Iteration]
    
    D --> D1[HashMap Creation]
    D --> D2[Insert & Retrieve]
    D --> D3[HashMap Methods]
```

---

## üî§ PH·∫¶N 1: STRINGS TRONG RUST

### 1.1 Hai Lo·∫°i String Ch√≠nh

<div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6 rounded-r-lg">
  <h3 className="text-blue-800 font-semibold mb-2">üí° Kh√°i Ni·ªám Quan Tr·ªçng</h3>
  <p className="text-blue-700">Rust c√≥ hai lo·∫°i string ch√≠nh: <code>&str</code> (string slice) v√† <code>String</code> (owned string)</p>
</div>

| ƒê·∫∑c ƒëi·ªÉm | `&str` | `String` |
|----------|--------|----------|
| **Ownership** | Borrowed | Owned |
| **Memory** | Stack (reference) | Heap |
| **Mutability** | Immutable | C√≥ th·ªÉ mutable |
| **Size** | Fixed | C√≥ th·ªÉ thay ƒë·ªïi |
| **Use case** | String literals, slices | Dynamic strings |

### 1.2 String Literals (&str)

```rust copy
// String literals - stored in program binary
let greeting = "Hello, World!";  // Type: &str
let multiline = "This is a 
multiline string";

// Raw strings - kh√¥ng escape characters
let raw_string = r"C:\Users\Name\file.txt";
let raw_multiline = r#"
    This is a "raw" string
    with multiple lines
"#;
```

### 1.3 String Type

```rust copy
// T·∫°o String t·ª´ literal
let mut s1 = String::from("Hello");
let mut s2 = "Hello".to_string();
let mut s3 = String::new(); // Empty string

// String manipulation
s1.push_str(", World!");     // Append string slice
s1.push('!');                // Append single character
```

### 1.4 String Methods Map

```mermaid
mindmap
  root)String Methods(
    Creation
      ::from()
      ::new()
      ::with_capacity()
    
    Modification
      ::push()
      ::push_str()
      ::insert()
      ::replace()
    
    Information
      ::len()
      ::is_empty()
      ::capacity()
      ::chars()
    
    Conversion
      ::to_string()
      ::as_str()
      ::into_bytes()
```

### 1.5 String Operations Table

| Method | Description | Example |
|--------|-------------|---------|
| `len()` | Tr·∫£ v·ªÅ s·ªë bytes | `"Hello".len() // 5` |
| `chars()` | Iterator qua characters | `"Hello".chars()` |
| `split()` | T√°ch string theo delimiter | `"a,b,c".split(',')` |
| `trim()` | Lo·∫°i b·ªè whitespace | `" hello ".trim()` |
| `replace()` | Thay th·∫ø substring | `"hello".replace("l", "x")` |
| `contains()` | Ki·ªÉm tra substring | `"hello".contains("ell")` |

---

## üì¶ PH·∫¶N 2: VECTORS - VEC&LT;T&GT;

### 2.1 Vector Overview

<div className="bg-green-50 border-l-4 border-green-500 p-4 mb-6 rounded-r-lg">
  <h3 className="text-green-800 font-semibold mb-2">üöÄ Vector l√† g√¨?</h3>
  <p className="text-green-700">Vector l√† dynamic array, c√≥ th·ªÉ thay ƒë·ªïi size v√† store elements c√πng type tr√™n heap</p>
</div>

### 2.2 Vector Creation Methods

```rust copy
// T·∫°o vector r·ªóng
let mut v1: Vec<i32> = Vec::new();
let mut v2 = Vec::<i32>::new();

// T·∫°o vector v·ªõi macro vec!
let v3 = vec![1, 2, 3, 4, 5];
let v4 = vec![0; 5]; // [0, 0, 0, 0, 0]

// T·∫°o v·ªõi capacity
let mut v5 = Vec::with_capacity(10);
```

### 2.3 Vector Operations

| Operation | Method | Example | Result |
|-----------|--------|---------|---------|
| **Add element** | `push()` | `v.push(5)` | Adds to end |
| **Remove last** | `pop()` | `v.pop()` | `Option<T>` |
| **Insert at index** | `insert()` | `v.insert(0, 10)` | Insert at position |
| **Remove at index** | `remove()` | `v.remove(1)` | Remove & return |
| **Access element** | `[]` ho·∫∑c `get()` | `v[0]` ho·∫∑c `v.get(0)` | Direct ho·∫∑c `Option<&T>` |

### 2.4 Vector Iteration

```rust copy
let v = vec![1, 2, 3, 4, 5];

// Iterate by reference
for item in &v {
    println!("{}", item);
}

// Iterate by value (consumes vector)
for item in v {
    println!("{}", item);
}

// Iterate with index
for (index, value) in v.iter().enumerate() {
    println!("Index {}: {}", index, value);
}

// Mutable iteration
let mut v = vec![1, 2, 3];
for item in &mut v {
    *item *= 2;
}
```

---

## üó∫Ô∏è PH·∫¶N 3: HASHMAPS - KEY-VALUE STORAGE

### 3.1 HashMap Characteristics

```mermaid
graph LR
    A[HashMap] --> B[Key-Value Pairs]
    A --> C[Hash-based Lookup]
    A --> D[O(1) Average Access]
    
    B --> B1[Unique Keys]
    B --> B2[Any Value Type]
    
    C --> C1[Fast Insertion]
    C --> C2[Fast Retrieval]
```

### 3.2 HashMap Creation v√† Basic Operations

```rust copy
use std::collections::HashMap;

// T·∫°o HashMap
let mut scores = HashMap::new();

// Insert key-value pairs
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Red"), 25);

// T·∫°o t·ª´ vector of tuples
let teams = vec![String::from("Blue"), String::from("Red")];
let scores_vec = vec![10, 25];
let scores: HashMap<_, _> = teams.iter().zip(scores_vec.iter()).collect();
```

### 3.3 HashMap Methods Reference

| Method | Purpose | Return Type | Example |
|--------|---------|-------------|---------|
| `insert(k, v)` | Insert/Update | `Option<V>` | `map.insert("key", 42)` |
| `get(k)` | Retrieve value | `Option<&V>` | `map.get("key")` |
| `remove(k)` | Remove entry | `Option<V>` | `map.remove("key")` |
| `contains_key(k)` | Check existence | `bool` | `map.contains_key("key")` |
| `entry(k)` | Get entry | `Entry<K,V>` | `map.entry("key")` |

### 3.4 Advanced HashMap Patterns

```rust copy
use std::collections::HashMap;

let mut map = HashMap::new();

// Entry API - insert if not exists
map.entry("key".to_string())
   .or_insert(42);

// Entry API - update existing or insert default
*map.entry("counter".to_string())
    .or_insert(0) += 1;

// Pattern matching with get()
match map.get("key") {
    Some(value) => println!("Found: {}", value),
    None => println!("Key not found"),
}
```

---

## ‚öñÔ∏è PH·∫¶N 4: SO S√ÅNH COLLECTIONS

### 4.1 Arrays vs Vectors Comparison

<div className="overflow-x-auto">

| Aspect | Array `[T; N]` | Vector `Vec<T>` |
|--------|----------------|-----------------|
| **Size** | Fixed at compile time | Dynamic |
| **Memory** | Stack | Heap |
| **Performance** | Faster access | Slightly slower |
| **Flexibility** | Limited | High |
| **Use case** | Known size, performance critical | Dynamic size needed |

</div>

### 4.2 Collection Selection Guide

```mermaid
flowchart TD
    A[Need Collection?] --> B{Size Known?}
    B --> C{Small and Fixed?}
    B --> D[Use Vec]
    
    C --> E[Use Array]
    C --> D
    
    D --> F{Key-Value pairs?}
    F --> G[Use HashMap]
    F --> H[Use Vec]
    
    E --> I{Performance Critical?}
    I --> J[Array]
    I --> K[Consider Vec]
```

---

## üé® PH·∫¶N 5: STRING FORMATTING

### 5.1 Format Macros

| Macro | Purpose | Example |
|-------|---------|---------|
| `format!` | Create formatted String | `format!("Hello {}", name)` |
| `print!` | Print to stdout | `print!("Value: {}", x)` |
| `println!` | Print with newline | `println!("Debug: {:?}", obj)` |
| `eprintln!` | Print to stderr | `eprintln!("Error: {}", msg)` |

### 5.2 Format Specifiers

```rust copy
let name = "Alice";
let age = 30;
let pi = 3.14159;

// Basic formatting
println!("Hello, {}!", name);

// Positional parameters
println!("{0} is {1} years old, {0} likes Rust", name, age);

// Named parameters  
println!("{name} is {age} years old");

// Number formatting
println!("Pi: {:.2}", pi);        // 2 decimal places
println!("Hex: {:x}", 255);       // Hexadecimal
println!("Binary: {:b}", 8);      // Binary
println!("Padded: {:05}", 42);    // Zero-padded
```

---

## üíª PH·∫¶N 6: TH·ª∞C H√ÄNH - WORD COUNTER

<div className="bg-yellow-50 border-l-4 border-yellow-500 p-4 mb-6 rounded-r-lg">
  <h3 className="text-yellow-800 font-semibold mb-2">üîß B√†i T·∫≠p Th·ª±c H√†nh</h3>
  <p className="text-yellow-700">X√¢y d·ª±ng ch∆∞∆°ng tr√¨nh ƒë·∫øm t·ª´ s·ª≠ d·ª•ng HashMap v√† String processing</p>
</div>

```rust copy
use std::collections::HashMap;

fn word_counter(text: &str) -> HashMap<String, usize> {
    let mut word_count = HashMap::new();
    
    // Split text th√†nh words v√† clean up
    for word in text
        .to_lowercase()
        .split_whitespace()
        .map(|w| w.trim_matches(|c: char| !c.is_alphabetic()))
        .filter(|w| !w.is_empty())
    {
        let count = word_count.entry(word.to_string()).or_insert(0);
        *count += 1;
    }
    
    word_count
}

fn main() {
    let text = "Hello world! This is a hello world example.";
    let counts = word_counter(text);
    
    // In k·∫øt qu·∫£
    for (word, count) in &counts {
        println!("{}: {}", word, count);
    }
    
    // Top 3 words
    let mut word_vec: Vec<_> = counts.iter().collect();
    word_vec.sort_by(|a, b| b.1.cmp(a.1));
    
    println!("\nTop 3 words:");
    for (word, count) in word_vec.iter().take(3) {
        println!("  {}: {}", word, count);
    }
}
```

---

## üéØ PH·∫¶N 7: CONTACT MANAGER EXAMPLE

```rust copy
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Contact {
    name: String,
    email: String,
    phone: String,
}

struct ContactManager {
    contacts: HashMap<String, Contact>,
}

impl ContactManager {
    fn new() -> Self {
        ContactManager {
            contacts: HashMap::new(),
        }
    }
    
    fn add_contact(&mut self, contact: Contact) {
        let key = contact.name.to_lowercase();
        self.contacts.insert(key, contact);
    }
    
    fn find_contact(&self, name: &str) -> Option<&Contact> {
        self.contacts.get(&name.to_lowercase())
    }
    
    fn list_contacts(&self) -> Vec<&Contact> {
        self.contacts.values().collect()
    }
    
    fn remove_contact(&mut self, name: &str) -> Option<Contact> {
        self.contacts.remove(&name.to_lowercase())
    }
}

fn main() {
    let mut manager = ContactManager::new();
    
    // Add contacts
    manager.add_contact(Contact {
        name: "Alice Johnson".to_string(),
        email: "alice@example.com".to_string(),
        phone: "123-456-7890".to_string(),
    });
    
    // Find contact
    if let Some(contact) = manager.find_contact("alice johnson") {
        println!("Found: {:?}", contact);
    }
    
    // List all contacts
    println!("All contacts:");
    for contact in manager.list_contacts() {
        println!("  {}: {}", contact.name, contact.email);
    }
}
```

---

## üìã T√ìM T·∫ÆT B√ÄI H·ªåC

<div className="bg-purple-50 border border-purple-200 rounded-lg p-6">
  <h3 className="text-purple-800 font-bold text-lg mb-4">üéä Nh·ªØng ƒêi·ªÅu ƒê√£ H·ªçc</h3>
  
  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div className="bg-white p-4 rounded border">
      <h4 className="font-semibold text-purple-700 mb-2">Strings</h4>
      <ul className="text-sm text-purple-600 space-y-1">
        <li>‚Ä¢ Hi·ªÉu s·ª± kh√°c bi·ªát gi·ªØa &str v√† String</li>
        <li>‚Ä¢ String methods v√† manipulation</li>
        <li>‚Ä¢ UTF-8 encoding handling</li>
        <li>‚Ä¢ String formatting v·ªõi macros</li>
      </ul>
    </div>
    
    <div className="bg-white p-4 rounded border">
      <h4 className="font-semibold text-purple-700 mb-2">Collections</h4>
      <ul className="text-sm text-purple-600 space-y-1">
        <li>‚Ä¢ Vector creation v√† manipulation</li>
        <li>‚Ä¢ HashMap key-value operations</li>
        <li>‚Ä¢ Collection iteration patterns</li>
        <li>‚Ä¢ Choosing right collection type</li>
      </ul>
    </div>
  </div>
</div>

---

## üöÄ CHU·∫®N B·ªä CHO B√ÄI TI·∫æP THEO

B√†i 6 s·∫Ω h·ªçc v·ªÅ **Structs v√† Enums** - t·∫°o custom data types ƒë·ªÉ t·ªï ch·ª©c code t·ªët h∆°n:

```mermaid
graph LR
    A[B√†i 5: Collections] --> B[B√†i 6: Structs & Enums]
    B --> C[Custom Data Types]
    B --> D[Methods & Functions]
    B --> E[Pattern Matching]
```

<div className="bg-gray-100 p-4 rounded-lg mt-6">
  <p className="text-gray-700 font-medium">üí° <strong>L·ªùi khuy√™n:</strong> H√£y th·ª±c h√†nh nhi·ªÅu v·ªõi String v√† HashMap operations v√¨ ch√∫ng r·∫•t ph·ªï bi·∫øn trong Rust programming!</p>
</div>