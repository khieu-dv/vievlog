# BÃ i 5: Stacks & Queues - NgÄƒn xáº¿p vÃ  HÃ ng Ä‘á»£i

<div className="bg-blue-50 border-l-4 border-blue-500 p-4 my-6">
<h2 className="text-xl font-bold text-blue-800 mb-2">ğŸ¯ Má»¥c tiÃªu há»c táº­p</h2>
<p className="text-blue-700">Náº¯m vá»¯ng hai cáº¥u trÃºc dá»¯ liá»‡u tuyáº¿n tÃ­nh quan trá»ng: Stack (LIFO) vÃ  Queue (FIFO), cÃ¹ng vá»›i cÃ¡c á»©ng dá»¥ng thá»±c táº¿ cá»§a chÃºng.</p>
</div>

## ğŸ“‹ Ná»™i dung chÃ­nh

### 1. Stack (NgÄƒn xáº¿p) - LIFO (Last In, First Out)

Stack lÃ  cáº¥u trÃºc dá»¯ liá»‡u tuyáº¿n tÃ­nh hoáº¡t Ä‘á»™ng theo nguyÃªn táº¯c **LIFO** - pháº§n tá»­ Ä‘Æ°á»£c thÃªm vÃ o cuá»‘i cÃ¹ng sáº½ Ä‘Æ°á»£c láº¥y ra Ä‘áº§u tiÃªn.

<div className="bg-gray-50 p-4 rounded-lg my-4">
<h4 className="font-bold text-gray-800 mb-2">ğŸ”„ CÃ¡c thao tÃ¡c cÆ¡ báº£n cá»§a Stack:</h4>
<ul className="list-disc list-inside text-gray-700">
<li><strong>push(item)</strong>: ThÃªm pháº§n tá»­ vÃ o Ä‘á»‰nh stack</li>
<li><strong>pop()</strong>: Loáº¡i bá» vÃ  tráº£ vá» pháº§n tá»­ á»Ÿ Ä‘á»‰nh stack</li>
<li><strong>top/peek()</strong>: Xem pháº§n tá»­ á»Ÿ Ä‘á»‰nh stack mÃ  khÃ´ng loáº¡i bá»</li>
<li><strong>is_empty()</strong>: Kiá»ƒm tra stack cÃ³ rá»—ng khÃ´ng</li>
<li><strong>size()</strong>: Tráº£ vá» sá»‘ lÆ°á»£ng pháº§n tá»­ trong stack</li>
</ul>
</div>

```mermaid
graph TD
    A[Stack Visualization] --> B[Top: 40]
    B --> C[30]
    C --> D[20]
    D --> E[Bottom: 10]
    
    F[Push 50] --> G[Top: 50]
    G --> H[40]
    H --> I[30]
    I --> J[20]
    J --> K[Bottom: 10]
    
    L[Pop] --> M[Top: 30]
    M --> N[20]
    N --> O[Bottom: 10]
```

#### CÃ i Ä‘áº·t Stack vá»›i Array trong Rust

```rust
pub struct ArrayStack<T> {
    data: Vec<T>,
    capacity: usize,
}

impl<T> ArrayStack<T> {
    pub fn new(capacity: usize) -> Self {
        ArrayStack {
            data: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn push(&mut self, item: T) -> Result<(), &'static str> {
        if self.data.len() >= self.capacity {
            return Err("Stack overflow");
        }
        self.data.push(item);
        Ok(())
    }
    
    pub fn pop(&mut self) -> Option<T> {
        self.data.pop()
    }
    
    pub fn peek(&self) -> Option<&T> {
        self.data.last()
    }
    
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
    
    pub fn size(&self) -> usize {
        self.data.len()
    }
}
```

#### CÃ i Ä‘áº·t Stack vá»›i Linked List trong Rust

```rust
type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    data: T,
    next: Link<T>,
}

pub struct LinkedStack<T> {
    head: Link<T>,
    size: usize,
}

impl<T> LinkedStack<T> {
    pub fn new() -> Self {
        LinkedStack { head: None, size: 0 }
    }
    
    pub fn push(&mut self, item: T) {
        let new_node = Box::new(Node {
            data: item,
            next: self.head.take(),
        });
        self.head = Some(new_node);
        self.size += 1;
    }
    
    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            self.size -= 1;
            node.data
        })
    }
    
    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.data)
    }
    
    pub fn is_empty(&self) -> bool {
        self.head.is_none()
    }
    
    pub fn size(&self) -> usize {
        self.size
    }
}
```

### 2. Queue (HÃ ng Ä‘á»£i) - FIFO (First In, First Out)

Queue lÃ  cáº¥u trÃºc dá»¯ liá»‡u tuyáº¿n tÃ­nh hoáº¡t Ä‘á»™ng theo nguyÃªn táº¯c **FIFO** - pháº§n tá»­ Ä‘Æ°á»£c thÃªm vÃ o Ä‘áº§u tiÃªn sáº½ Ä‘Æ°á»£c láº¥y ra Ä‘áº§u tiÃªn.

<div className="bg-green-50 p-4 rounded-lg my-4">
<h4 className="font-bold text-green-800 mb-2">ğŸ”„ CÃ¡c thao tÃ¡c cÆ¡ báº£n cá»§a Queue:</h4>
<ul className="list-disc list-inside text-green-700">
<li><strong>enqueue(item)</strong>: ThÃªm pháº§n tá»­ vÃ o cuá»‘i queue</li>
<li><strong>dequeue()</strong>: Loáº¡i bá» vÃ  tráº£ vá» pháº§n tá»­ á»Ÿ Ä‘áº§u queue</li>
<li><strong>front()</strong>: Xem pháº§n tá»­ á»Ÿ Ä‘áº§u queue mÃ  khÃ´ng loáº¡i bá»</li>
<li><strong>rear()</strong>: Xem pháº§n tá»­ á»Ÿ cuá»‘i queue</li>
<li><strong>is_empty()</strong>: Kiá»ƒm tra queue cÃ³ rá»—ng khÃ´ng</li>
<li><strong>size()</strong>: Tráº£ vá» sá»‘ lÆ°á»£ng pháº§n tá»­ trong queue</li>
</ul>
</div>

```mermaid
graph LR
    A[Front] --> B[10] --> C[20] --> D[30] --> E[40] --> F[Rear]
    
    G[Enqueue 50] 
    H[Front] --> I[10] --> J[20] --> K[30] --> L[40] --> M[50] --> N[Rear]
    
    O[Dequeue]
    P[Front] --> Q[20] --> R[30] --> S[40] --> T[50] --> U[Rear]
```

#### CÃ i Ä‘áº·t Queue vá»›i Circular Buffer trong Rust

```rust
pub struct CircularQueue<T> {
    data: Vec<Option<T>>,
    front: usize,
    rear: usize,
    size: usize,
    capacity: usize,
}

impl<T> CircularQueue<T> {
    pub fn new(capacity: usize) -> Self {
        CircularQueue {
            data: vec![None; capacity + 1],
            front: 0,
            rear: 0,
            size: 0,
            capacity: capacity + 1,
        }
    }
    
    pub fn enqueue(&mut self, item: T) -> Result<(), &'static str> {
        if self.is_full() {
            return Err("Queue is full");
        }
        
        self.data[self.rear] = Some(item);
        self.rear = (self.rear + 1) % self.capacity;
        self.size += 1;
        Ok(())
    }
    
    pub fn dequeue(&mut self) -> Option<T> {
        if self.is_empty() {
            return None;
        }
        
        let item = self.data[self.front].take();
        self.front = (self.front + 1) % self.capacity;
        self.size -= 1;
        item
    }
    
    pub fn front(&self) -> Option<&T> {
        if self.is_empty() {
            None
        } else {
            self.data[self.front].as_ref()
        }
    }
    
    pub fn is_empty(&self) -> bool {
        self.size == 0
    }
    
    pub fn is_full(&self) -> bool {
        self.size == self.capacity - 1
    }
    
    pub fn size(&self) -> usize {
        self.size
    }
}
```

### 3. So sÃ¡nh Stack vÃ  Queue

| TiÃªu chÃ­ | Stack (LIFO) | Queue (FIFO) |
|----------|--------------|--------------|
| **NguyÃªn táº¯c** | Last In, First Out | First In, First Out |
| **Thao tÃ¡c thÃªm** | push() - á»Ÿ top | enqueue() - á»Ÿ rear |
| **Thao tÃ¡c láº¥y** | pop() - á»Ÿ top | dequeue() - á»Ÿ front |
| **á»¨ng dá»¥ng** | Function calls, Undo operations | Task scheduling, BFS |
| **Complexity** | O(1) cho táº¥t cáº£ operations | O(1) cho táº¥t cáº£ operations |

### 4. á»¨ng dá»¥ng thá»±c táº¿

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
<div className="bg-purple-50 p-4 rounded-lg">
<h4 className="font-bold text-purple-800 mb-2">ğŸ¥ á»¨ng dá»¥ng cá»§a Stack:</h4>
<ul className="list-disc list-inside text-purple-700 space-y-1">
<li>Function call stack</li>
<li>Expression evaluation</li>
<li>Undo operations trong editors</li>
<li>Browser history</li>
<li>Syntax parsing</li>
<li>Backtracking algorithms</li>
</ul>
</div>

<div className="bg-orange-50 p-4 rounded-lg">
<h4 className="font-bold text-orange-800 mb-2">ğŸš¶â€â™€ï¸ á»¨ng dá»¥ng cá»§a Queue:</h4>
<ul className="list-disc list-inside text-orange-700 space-y-1">
<li>CPU task scheduling</li>
<li>Print queue management</li>
<li>Breadth-First Search (BFS)</li>
<li>Buffer cho I/O operations</li>
<li>Traffic light systems</li>
<li>Call center systems</li>
</ul>
</div>
</div>

### 5. VÃ­ dá»¥ thá»±c táº¿: Expression Evaluation

```rust
fn evaluate_postfix(expression: &str) -> Result<i32, &'static str> {
    let mut stack = ArrayStack::new(100);
    
    for token in expression.split_whitespace() {
        match token {
            "+" | "-" | "*" | "/" => {
                let b = stack.pop().ok_or("Invalid expression")?;
                let a = stack.pop().ok_or("Invalid expression")?;
                
                let result = match token {
                    "+" => a + b,
                    "-" => a - b,
                    "*" => a * b,
                    "/" => {
                        if b == 0 { return Err("Division by zero"); }
                        a / b
                    }
                    _ => unreachable!(),
                };
                
                stack.push(result)?;
            }
            _ => {
                let num = token.parse::<i32>()
                    .map_err(|_| "Invalid number")?;
                stack.push(num)?;
            }
        }
    }
    
    if stack.size() == 1 {
        stack.pop().ok_or("Empty stack")
    } else {
        Err("Invalid expression")
    }
}

// Sá»­ dá»¥ng: evaluate_postfix("3 4 + 2 *") â†’ 14
```

### 6. Äá»™ phá»©c táº¡p thá»i gian vÃ  khÃ´ng gian

| Thao tÃ¡c | Stack | Queue |
|----------|-------|-------|
| **Push/Enqueue** | O(1) | O(1) |
| **Pop/Dequeue** | O(1) | O(1) |
| **Peek/Front** | O(1) | O(1) |
| **Size** | O(1) | O(1) |
| **Space** | O(n) | O(n) |

```mermaid
graph TB
    A[Memory Layout Comparison] 
    
    B[Stack with Array]
    B --> C[Contiguous memory]
    B --> D[Fixed size]
    B --> E[Cache friendly]
    
    F[Stack with Linked List]
    F --> G[Dynamic size]
    F --> H[Extra memory for pointers]
    F --> I[Memory scattered]
    
    J[Queue with Circular Buffer]
    J --> K[Efficient space usage]
    J --> L[No memory waste]
    J --> M[Fixed size]
```

## ğŸ¯ Tá»•ng káº¿t

**Stack vÃ  Queue** lÃ  hai cáº¥u trÃºc dá»¯ liá»‡u cÆ¡ báº£n nhÆ°ng vÃ´ cÃ¹ng quan trá»ng trong láº­p trÃ¬nh. Stack vá»›i nguyÃªn táº¯c LIFO phÃ¹ há»£p cho viá»‡c quáº£n lÃ½ tráº¡ng thÃ¡i táº¡m thá»i, cÃ²n Queue vá»›i FIFO lÃ½ tÆ°á»Ÿng cho viá»‡c xá»­ lÃ½ tuáº§n tá»± cÃ¡c tÃ¡c vá»¥.

<div className="bg-yellow-50 border border-yellow-200 p-4 rounded-lg my-4">
<h4 className="font-bold text-yellow-800 mb-2">ğŸ’¡ Lá»i khuyÃªn:</h4>
<p className="text-yellow-700">HÃ£y thá»±c hÃ nh cÃ i Ä‘áº·t cáº£ hai cáº¥u trÃºc báº±ng array vÃ  linked list Ä‘á»ƒ hiá»ƒu rÃµ trade-offs giá»¯a performance vÃ  memory usage.</p>
</div>

## ğŸ“ BÃ i táº­p LeetCode liÃªn quan

1. **[Valid Parentheses (Easy)](https://leetcode.com/problems/valid-parentheses/)** - Stack
2. **[Implement Queue using Stacks (Easy)](https://leetcode.com/problems/implement-queue-using-stacks/)** 
3. **[Implement Stack using Queues (Easy)](https://leetcode.com/problems/implement-stack-using-queues/)**
4. **[Min Stack (Easy)](https://leetcode.com/problems/min-stack/)** 
5. **[Daily Temperatures (Medium)](https://leetcode.com/problems/daily-temperatures/)** - Monotonic Stack
6. **[Sliding Window Maximum (Hard)](https://leetcode.com/problems/sliding-window-maximum/)** - Deque
7. **[Evaluate Reverse Polish Notation (Medium)](https://leetcode.com/problems/evaluate-reverse-polish-notation/)**

---

**BÃ i tiáº¿p theo:** [BÃ i 6: Hash Tables - Báº£ng bÄƒm]()