# BÃ i 13: Tree Data Structures Basics
## Cáº¥u trÃºc dá»¯ liá»‡u cÃ¢y cÆ¡ báº£n

---

<div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border border-blue-200 mb-6">
<h3 className="text-xl font-semibold text-blue-800 mb-3">ğŸ¯ Má»¥c tiÃªu há»c táº­p</h3>
<div className="text-blue-700">
<p><strong>Sau bÃ i há»c nÃ y, báº¡n sáº½ cÃ³ thá»ƒ:</strong></p>
<ul className="list-disc list-inside space-y-1 mt-2">
<li>Hiá»ƒu cÃ¡c khÃ¡i niá»‡m cÆ¡ báº£n vá» cáº¥u trÃºc cÃ¢y</li>
<li>CÃ i Ä‘áº·t Binary Tree báº±ng Rust</li>
<li>Thá»±c hiá»‡n cÃ¡c thao tÃ¡c cÆ¡ báº£n trÃªn cÃ¢y</li>
<li>PhÃ¢n tÃ­ch Ä‘á»™ phá»©c táº¡p cá»§a cÃ¡c thao tÃ¡c trÃªn cÃ¢y</li>
</ul>
</div>
</div>

## 1. KhÃ¡i niá»‡m cÆ¡ báº£n vá» Tree

### 1.1 Äá»‹nh nghÄ©a Tree

**Tree** lÃ  má»™t cáº¥u trÃºc dá»¯ liá»‡u phi tuyáº¿n tÃ­nh bao gá»“m cÃ¡c **node** Ä‘Æ°á»£c káº¿t ná»‘i bá»Ÿi cÃ¡c **edge**, táº¡o thÃ nh má»™t cáº¥u trÃºc phÃ¢n cáº¥p.

### 1.2 CÃ¡c thuáº­t ngá»¯ quan trá»ng

| Thuáº­t ngá»¯ | Äá»‹nh nghÄ©a | VÃ­ dá»¥ |
|-----------|------------|-------|
| **Root** | Node gá»‘c, khÃ´ng cÃ³ parent | Node A |
| **Parent** | Node cha cá»§a node khÃ¡c | A lÃ  parent cá»§a B, C |
| **Child** | Node con cá»§a node khÃ¡c | B, C lÃ  child cá»§a A |
| **Leaf** | Node khÃ´ng cÃ³ child nÃ o | Node D, E, F |
| **Sibling** | CÃ¡c node cÃ³ cÃ¹ng parent | B vÃ  C lÃ  sibling |
| **Height** | Äá»™ cao cá»§a cÃ¢y (tá»« root Ä‘áº¿n leaf xa nháº¥t) | 2 |
| **Depth** | Äá»™ sÃ¢u cá»§a node (tá»« root Ä‘áº¿n node Ä‘Ã³) | Depth cá»§a D = 2 |
| **Level** | Má»©c Ä‘á»™ cá»§a node (báº¯t Ä‘áº§u tá»« 0 hoáº·c 1) | Root á»Ÿ level 0 |

### 1.3 SÆ¡ Ä‘á»“ minh há»a cáº¥u trÃºc Tree

```mermaid
graph TD
    A[A - Root] --> B[B]
    A --> C[C]
    B --> D[D - Leaf]
    B --> E[E - Leaf]
    C --> F[F - Leaf]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style F fill:#e8f5e8
```

## 2. Binary Tree - CÃ¢y nhá»‹ phÃ¢n

### 2.1 Äá»‹nh nghÄ©a Binary Tree

**Binary Tree** lÃ  má»™t cÃ¢y Ä‘áº·c biá»‡t trong Ä‘Ã³ má»—i node cÃ³ tá»‘i Ä‘a **2 node con**, Ä‘Æ°á»£c gá»i lÃ  **left child** vÃ  **right child**.

### 2.2 CÃ¡c loáº¡i Binary Tree

| Loáº¡i Tree | Äáº·c Ä‘iá»ƒm | HÃ¬nh minh há»a |
|-----------|----------|---------------|
| **Full Binary Tree** | Má»i node cÃ³ 0 hoáº·c 2 child | KhÃ´ng cÃ³ node cÃ³ 1 child |
| **Complete Binary Tree** | Táº¥t cáº£ level Ä‘á»u Ä‘áº§y, trá»« level cuá»‘i (Ä‘áº§y tá»« trÃ¡i sang pháº£i) | Sá»­ dá»¥ng trong Heap |
| **Perfect Binary Tree** | Táº¥t cáº£ level Ä‘á»u Ä‘áº§y hoÃ n toÃ n | 2^h - 1 nodes |

<div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
<h4 className="font-semibold text-yellow-800 mb-2">ğŸ’¡ LÆ°u Ã½ quan trá»ng</h4>
<p className="text-yellow-700">Perfect Binary Tree cÃ³ Ä‘Ãºng 2^h - 1 nodes, trong Ä‘Ã³ h lÃ  height cá»§a cÃ¢y.</p>
</div>

## 3. CÃ i Ä‘áº·t Binary Tree báº±ng Rust

### 3.1 Äá»‹nh nghÄ©a Node Structure

```rust
use std::rc::Rc;
use std::cell::RefCell;

// Äá»‹nh nghÄ©a Node cho Binary Tree
#[derive(Debug, Clone)]
pub struct TreeNode<T> {
    pub value: T,
    pub left: Option<Rc<RefCell<TreeNode<T>>>>,
    pub right: Option<Rc<RefCell<TreeNode<T>>>>,
}

impl<T> TreeNode<T> {
    // Táº¡o má»™t node má»›i
    pub fn new(value: T) -> Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }
    
    // Táº¡o node vá»›i reference counting
    pub fn new_rc(value: T) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(TreeNode::new(value)))
    }
}
```

### 3.2 CÃ i Ä‘áº·t Binary Tree Class

```rust
pub struct BinaryTree<T> {
    pub root: Option<Rc<RefCell<TreeNode<T>>>>,
}

impl<T: Clone + PartialEq + std::fmt::Debug> BinaryTree<T> {
    // Táº¡o cÃ¢y rá»—ng
    pub fn new() -> Self {
        BinaryTree { root: None }
    }
    
    // Kiá»ƒm tra cÃ¢y cÃ³ rá»—ng khÃ´ng
    pub fn is_empty(&self) -> bool {
        self.root.is_none()
    }
    
    // TÃ­nh height cá»§a cÃ¢y
    pub fn height(&self) -> usize {
        Self::calculate_height(&self.root)
    }
    
    // Helper function Ä‘á»ƒ tÃ­nh height
    fn calculate_height(node: &Option<Rc<RefCell<TreeNode<T>>>>) -> usize {
        match node {
            None => 0,
            Some(n) => {
                let node_ref = n.borrow();
                let left_height = Self::calculate_height(&node_ref.left);
                let right_height = Self::calculate_height(&node_ref.right);
                1 + left_height.max(right_height)
            }
        }
    }
    
    // Äáº¿m sá»‘ node trong cÃ¢y
    pub fn count_nodes(&self) -> usize {
        Self::count_nodes_recursive(&self.root)
    }
    
    fn count_nodes_recursive(node: &Option<Rc<RefCell<TreeNode<T>>>>) -> usize {
        match node {
            None => 0,
            Some(n) => {
                let node_ref = n.borrow();
                1 + Self::count_nodes_recursive(&node_ref.left) 
                  + Self::count_nodes_recursive(&node_ref.right)
            }
        }
    }
}
```

## 4. CÃ¡c thao tÃ¡c cÆ¡ báº£n trÃªn Binary Tree

### 4.1 Báº£ng so sÃ¡nh Ä‘á»™ phá»©c táº¡p

| Thao tÃ¡c | Äá»™ phá»©c táº¡p thá»i gian | Äá»™ phá»©c táº¡p khÃ´ng gian | Ghi chÃº |
|----------|---------------------|----------------------|---------|
| **Táº¡o cÃ¢y** | O(1) | O(1) | Chá»‰ táº¡o root |
| **TÃ­nh height** | O(n) | O(h) | h = height cá»§a cÃ¢y |
| **Äáº¿m nodes** | O(n) | O(h) | Duyá»‡t táº¥t cáº£ nodes |
| **TÃ¬m kiáº¿m** | O(n) | O(h) | Worst case: linear |
| **ChÃ¨n node** | O(1) | O(1) | Náº¿u biáº¿t vá»‹ trÃ­ |

### 4.2 CÃ i Ä‘áº·t thÃªm cÃ¡c thao tÃ¡c

```rust
impl<T: Clone + PartialEq + std::fmt::Debug> BinaryTree<T> {
    // TÃ¬m node cÃ³ giÃ¡ trá»‹ cá»¥ thá»ƒ
    pub fn search(&self, target: &T) -> bool {
        Self::search_recursive(&self.root, target)
    }
    
    fn search_recursive(node: &Option<Rc<RefCell<TreeNode<T>>>>, target: &T) -> bool {
        match node {
            None => false,
            Some(n) => {
                let node_ref = n.borrow();
                if node_ref.value == *target {
                    true
                } else {
                    Self::search_recursive(&node_ref.left, target) ||
                    Self::search_recursive(&node_ref.right, target)
                }
            }
        }
    }
    
    // TÃ¬m giÃ¡ trá»‹ lá»›n nháº¥t
    pub fn find_max(&self) -> Option<T> {
        Self::find_max_recursive(&self.root)
    }
    
    fn find_max_recursive(node: &Option<Rc<RefCell<TreeNode<T>>>>) -> Option<T>
    where T: PartialOrd {
        match node {
            None => None,
            Some(n) => {
                let node_ref = n.borrow();
                let mut max_val = node_ref.value.clone();
                
                if let Some(left_max) = Self::find_max_recursive(&node_ref.left) {
                    if left_max > max_val {
                        max_val = left_max;
                    }
                }
                
                if let Some(right_max) = Self::find_max_recursive(&node_ref.right) {
                    if right_max > max_val {
                        max_val = right_max;
                    }
                }
                
                Some(max_val)
            }
        }
    }
}
```

## 5. Memory Representation

### 5.1 Array vs Linked Structure

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
<div className="bg-green-50 border border-green-200 rounded-lg p-4">
<h4 className="font-semibold text-green-800 mb-2">ğŸ“Š Array Representation</h4>
<div className="text-green-700 text-sm">
<strong>Æ¯u Ä‘iá»ƒm:</strong> Tiáº¿t kiá»‡m bá»™ nhá»›, truy cáº­p nhanh<br />
<strong>NhÆ°á»£c Ä‘iá»ƒm:</strong> KhÃ³ thay Ä‘á»•i kÃ­ch thÆ°á»›c, lÃ£ng phÃ­ vá»›i cÃ¢y thÆ°a
</div>
</div>
<div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
<h4 className="font-semibold text-blue-800 mb-2">ğŸ”— Linked Structure</h4>
<div className="text-blue-700 text-sm">
<strong>Æ¯u Ä‘iá»ƒm:</strong> Linh hoáº¡t, dá»… má»Ÿ rá»™ng<br />
<strong>NhÆ°á»£c Ä‘iá»ƒm:</strong> Tá»‘n bá»™ nhá»› cho pointers, cache locality kÃ©m
</div>
</div>
</div>

### 5.2 Array Representation Example

| Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|---|
| Value | A | B | C | D | E | F | - |
| Relation | Root | Left(A) | Right(A) | Left(B) | Right(B) | Left(C) | Right(C) |

**CÃ´ng thá»©c quan trá»ng:**
- Left child cá»§a node i: `2*i + 1`
- Right child cá»§a node i: `2*i + 2`
- Parent cá»§a node i: `(i-1)/2`

## 6. VÃ­ dá»¥ thá»±c hÃ nh

### 6.1 Táº¡o vÃ  sá»­ dá»¥ng Binary Tree

```rust
fn main() {
    // Táº¡o Binary Tree
    let mut tree = BinaryTree::new();
    
    // Táº¡o root node
    let root = TreeNode::new_rc(1);
    let left_child = TreeNode::new_rc(2);
    let right_child = TreeNode::new_rc(3);
    
    // Káº¿t ná»‘i cÃ¡c node
    root.borrow_mut().left = Some(left_child.clone());
    root.borrow_mut().right = Some(right_child.clone());
    
    // ThÃªm leaf nodes
    left_child.borrow_mut().left = Some(TreeNode::new_rc(4));
    left_child.borrow_mut().right = Some(TreeNode::new_rc(5));
    
    tree.root = Some(root);
    
    // Test cÃ¡c thao tÃ¡c
    println!("Height: {}", tree.height());        // Output: 3
    println!("Nodes count: {}", tree.count_nodes()); // Output: 5
    println!("Search 4: {}", tree.search(&4));    // Output: true
    println!("Search 10: {}", tree.search(&10));  // Output: false
}
```

## 7. SÆ¡ Ä‘á»“ tá»•ng káº¿t cÃ¡c loáº¡i Tree

```mermaid
graph LR
    A[Tree Types] --> B[Binary Tree]
    A --> C[N-ary Tree]
    
    B --> D[Full Binary Tree]
    B --> E[Complete Binary Tree]
    B --> F[Perfect Binary Tree]
    B --> G[Binary Search Tree]
    
    C --> H[Trie]
    C --> I[B-Tree]
    C --> J[Decision Tree]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style F fill:#e8f5e8
    style G fill:#fff3e0
```

<div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
<h4 className="font-semibold text-red-800 mb-2">âš ï¸ LÆ°u Ã½ quan trá»ng</h4>
<div className="text-red-700 text-sm">
<div><strong>Rust Memory Safety:</strong> Sá»­ dá»¥ng Rc&lt;RefCell&lt;T&gt;&gt; Ä‘á»ƒ trÃ¡nh ownership conflicts khi cÃ³ multiple references Ä‘áº¿n cÃ¹ng má»™t node.</div>
<div><strong>Performance:</strong> Binary Tree thÃ´ng thÆ°á»ng khÃ´ng Ä‘áº£m báº£o balanced, cÃ³ thá»ƒ degrade thÃ nh linked list (O(n) operations).</div>
</div>
</div>

## 8. BÃ i táº­p LeetCode liÃªn quan

### 8.1 BÃ i táº­p cÆ¡ báº£n
| BÃ i sá»‘ | TÃªn bÃ i | Äá»™ khÃ³ | Ká»¹ nÄƒng cáº§n thiáº¿t |
|--------|---------|---------|-------------------|
| **104** | Maximum Depth of Binary Tree | Easy | Recursion, Tree height |
| **111** | Minimum Depth of Binary Tree | Easy | BFS/DFS, Edge cases |
| **100** | Same Tree | Easy | Tree comparison |
| **101** | Symmetric Tree | Easy | Recursion, Mirror check |

### 8.2 BÃ i táº­p nÃ¢ng cao
| BÃ i sá»‘ | TÃªn bÃ i | Äá»™ khÃ³ | Ká»¹ nÄƒng cáº§n thiáº¿t |
|--------|---------|---------|-------------------|
| **110** | Balanced Binary Tree | Easy | Height calculation |
| **222** | Count Complete Tree Nodes | Medium | Binary search, Complete tree |
| **226** | Invert Binary Tree | Easy | Tree manipulation |
| **543** | Diameter of Binary Tree | Easy | Path length calculation |

---

<div className="bg-gradient-to-r from-green-50 to-blue-50 p-6 rounded-lg border border-green-200">
<h3 className="text-xl font-semibold text-green-800 mb-3">ğŸ‰ Tá»•ng káº¿t</h3>
<div className="text-green-700">
<p>BÃ i há»c nÃ y Ä‘Ã£ giÃºp báº¡n:</p>
<ul className="list-disc list-inside space-y-1 mt-2">
<li>Hiá»ƒu cÃ¡c khÃ¡i niá»‡m cÆ¡ báº£n vá» Tree data structure</li>
<li>CÃ i Ä‘áº·t Binary Tree báº±ng Rust má»™t cÃ¡ch an toÃ n vÃ  hiá»‡u quáº£</li>
<li>Thá»±c hiá»‡n cÃ¡c thao tÃ¡c cÆ¡ báº£n: tÃ­nh height, Ä‘áº¿m nodes, tÃ¬m kiáº¿m</li>
<li>PhÃ¢n biá»‡t cÃ¡c loáº¡i Binary Tree khÃ¡c nhau</li>
<li>Chuáº©n bá»‹ cho viá»‡c há»c Tree Traversal trong bÃ i tiáº¿p theo</li>
</ul>
</div>
</div>

**BÃ i tiáº¿p theo:** [BÃ i 14: Tree Traversal Algorithms]()