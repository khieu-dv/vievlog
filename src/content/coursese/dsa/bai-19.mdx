# B√†i 19: Graph Search Algorithms - Thu·∫≠t to√°n t√¨m ki·∫øm tr√™n ƒë·ªì th·ªã

## M·ª•c ti√™u h·ªçc t·∫≠p

<div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
<h3 className="text-lg font-semibold text-blue-800">Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:</h3>
<ul className="list-disc list-inside text-blue-700 mt-2">
<li>Hi·ªÉu v√† c√†i ƒë·∫∑t thu·∫≠t to√°n Breadth-First Search (BFS)</li>
<li>Hi·ªÉu v√† c√†i ƒë·∫∑t thu·∫≠t to√°n Depth-First Search (DFS)</li>
<li>Ph√¢n bi·ªát ·ª©ng d·ª•ng v√† ƒë·ªô ph·ª©c t·∫°p c·ªßa t·ª´ng thu·∫≠t to√°n</li>
<li>√Åp d·ª•ng BFS/DFS cho c√°c b√†i to√°n th·ª±c t·∫ø</li>
</ul>
</div>

## 1. Gi·ªõi thi·ªáu v·ªÅ Graph Search

Graph Search (t√¨m ki·∫øm tr√™n ƒë·ªì th·ªã) l√† qu√° tr√¨nh duy·ªát qua c√°c ƒë·ªânh (vertices) c·ªßa ƒë·ªì th·ªã theo m·ªôt th·ª© t·ª± nh·∫•t ƒë·ªãnh. Hai thu·∫≠t to√°n c∆° b·∫£n nh·∫•t l√†:

| Thu·∫≠t to√°n | C·∫•u tr√∫c d·ªØ li·ªáu | Th·ª© t·ª± duy·ªát | ƒê·ªô ph·ª©c t·∫°p |
|------------|------------------|--------------|-------------|
| **BFS** | Queue (FIFO) | Theo t·ª´ng t·∫ßng | O(V + E) |
| **DFS** | Stack/Recursion (LIFO) | ƒêi s√¢u tr∆∞·ªõc | O(V + E) |

*Trong ƒë√≥: V = s·ªë ƒë·ªânh, E = s·ªë c·∫°nh*

## 2. Breadth-First Search (BFS)

### 2.1 Nguy√™n l√Ω ho·∫°t ƒë·ªông

BFS duy·ªát ƒë·ªì th·ªã theo t·ª´ng t·∫ßng, b·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh kh·ªüi t·∫°o v√† lan r·ªông ra c√°c ƒë·ªânh l√¢n c·∫≠n.

```mermaid
graph TD
    A[B·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh A] --> B[Th√™m A v√†o queue]
    B --> C[L·∫•y ƒë·ªânh t·ª´ queue]
    C --> D{Queue r·ªóng?}
    D -->|Kh√¥ng| E[ThƒÉm c√°c ƒë·ªânh k·ªÅ ch∆∞a ƒë∆∞·ª£c thƒÉm]
    E --> F[Th√™m c√°c ƒë·ªânh k·ªÅ v√†o queue]
    F --> C
    D -->|C√≥| G[K·∫øt th√∫c]
```

### 2.2 C√†i ƒë·∫∑t BFS b·∫±ng Rust

```rust
use std::collections::{VecDeque, HashSet};

struct Graph {
    adj_list: Vec<Vec<usize>>,
    num_vertices: usize,
}

impl Graph {
    fn new(num_vertices: usize) -> Self {
        Graph {
            adj_list: vec![Vec::new(); num_vertices],
            num_vertices,
        }
    }
    
    fn add_edge(&mut self, src: usize, dest: usize) {
        self.adj_list[src].push(dest);
        // N·∫øu l√† ƒë·ªì th·ªã v√¥ h∆∞·ªõng, th√™m c·∫°nh ng∆∞·ª£c l·∫°i
        self.adj_list[dest].push(src);
    }
    
    fn bfs(&self, start: usize) -> Vec<usize> {
        let mut visited = vec![false; self.num_vertices];
        let mut queue = VecDeque::new();
        let mut result = Vec::new();
        
        // B·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh start
        queue.push_back(start);
        visited[start] = true;
        
        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);
            
            // Duy·ªát t·∫•t c·∫£ ƒë·ªânh k·ªÅ
            for &neighbor in &self.adj_list[vertex] {
                if !visited[neighbor] {
                    visited[neighbor] = true;
                    queue.push_back(neighbor);
                }
            }
        }
        
        result
    }
    
    // BFS t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (s·ªë c·∫°nh √≠t nh·∫•t)
    fn bfs_shortest_path(&self, start: usize, target: usize) -> Option<Vec<usize>> {
        let mut visited = vec![false; self.num_vertices];
        let mut queue = VecDeque::new();
        let mut parent = vec![None; self.num_vertices];
        
        queue.push_back(start);
        visited[start] = true;
        
        while let Some(vertex) = queue.pop_front() {
            if vertex == target {
                // X√¢y d·ª±ng ƒë∆∞·ªùng ƒëi t·ª´ parent array
                let mut path = Vec::new();
                let mut current = Some(target);
                
                while let Some(v) = current {
                    path.push(v);
                    current = parent[v];
                }
                
                path.reverse();
                return Some(path);
            }
            
            for &neighbor in &self.adj_list[vertex] {
                if !visited[neighbor] {
                    visited[neighbor] = true;
                    parent[neighbor] = Some(vertex);
                    queue.push_back(neighbor);
                }
            }
        }
        
        None // Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng ƒëi
    }
}
```

### 2.3 V√≠ d·ª• minh h·ªça BFS

```mermaid
graph LR
    0((0)) --- 1((1))
    0 --- 2((2))
    1 --- 3((3))
    2 --- 4((4))
    3 --- 5((5))
    4 --- 5
    
    classDef visited fill:#e1f5fe
    classDef current fill:#81c784
    classDef queue fill:#ffb74d
```

<div className="bg-gray-50 p-4 rounded-lg">
<h4 className="font-semibold mb-2">Th·ª© t·ª± duy·ªát BFS t·ª´ ƒë·ªânh 0:</h4>
<table className="w-full">
<thead>
<tr><th>B∆∞·ªõc</th><th>Queue</th><th>ThƒÉm</th><th>Th√™m v√†o Queue</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>[0]</td><td>0</td><td>[1, 2]</td></tr>
<tr><td>2</td><td>[1, 2]</td><td>1</td><td>[3]</td></tr>
<tr><td>3</td><td>[2, 3]</td><td>2</td><td>[4]</td></tr>
<tr><td>4</td><td>[3, 4]</td><td>3</td><td>[5]</td></tr>
<tr><td>5</td><td>[4, 5]</td><td>4</td><td>[]</td></tr>
<tr><td>6</td><td>[5]</td><td>5</td><td>[]</td></tr>
</tbody>
</table>
<p><strong>K·∫øt qu·∫£:</strong> [0, 1, 2, 3, 4, 5]</p>
</div>

## 3. Depth-First Search (DFS)

### 3.1 Nguy√™n l√Ω ho·∫°t ƒë·ªông

DFS ƒëi s√¢u v√†o m·ªôt h∆∞·ªõng cho ƒë·∫øn khi kh√¥ng th·ªÉ ƒëi ti·∫øp, sau ƒë√≥ quay l·∫°i v√† th·ª≠ h∆∞·ªõng kh√°c.

```mermaid
graph TD
    A[B·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh start] --> B[ƒê√°nh d·∫•u ƒë√£ thƒÉm]
    B --> C[Duy·ªát c√°c ƒë·ªânh k·ªÅ]
    C --> D{C√≥ ƒë·ªânh k·ªÅ ch∆∞a thƒÉm?}
    D -->|C√≥| E[G·ªçi ƒë·ªá quy DFS cho ƒë·ªânh k·ªÅ]
    E --> C
    D -->|Kh√¥ng| F[Quay l·∫°i ƒë·ªânh tr∆∞·ªõc]
    F --> G[K·∫øt th√∫c]
```

### 3.2 C√†i ƒë·∫∑t DFS b·∫±ng Rust

```rust
impl Graph {
    // DFS s·ª≠ d·ª•ng ƒë·ªá quy
    fn dfs(&self, start: usize) -> Vec<usize> {
        let mut visited = vec![false; self.num_vertices];
        let mut result = Vec::new();
        self.dfs_util(start, &mut visited, &mut result);
        result
    }
    
    fn dfs_util(&self, vertex: usize, visited: &mut Vec<bool>, result: &mut Vec<usize>) {
        visited[vertex] = true;
        result.push(vertex);
        
        for &neighbor in &self.adj_list[vertex] {
            if !visited[neighbor] {
                self.dfs_util(neighbor, visited, result);
            }
        }
    }
    
    // DFS s·ª≠ d·ª•ng stack (iterative)
    fn dfs_iterative(&self, start: usize) -> Vec<usize> {
        let mut visited = vec![false; self.num_vertices];
        let mut stack = Vec::new();
        let mut result = Vec::new();
        
        stack.push(start);
        
        while let Some(vertex) = stack.pop() {
            if !visited[vertex] {
                visited[vertex] = true;
                result.push(vertex);
                
                // Th√™m c√°c ƒë·ªânh k·ªÅ v√†o stack (th·ª© t·ª± ng∆∞·ª£c)
                for &neighbor in self.adj_list[vertex].iter().rev() {
                    if !visited[neighbor] {
                        stack.push(neighbor);
                    }
                }
            }
        }
        
        result
    }
    
    // Ki·ªÉm tra chu tr√¨nh trong ƒë·ªì th·ªã c√≥ h∆∞·ªõng
    fn has_cycle_directed(&self) -> bool {
        let mut visited = vec![false; self.num_vertices];
        let mut rec_stack = vec![false; self.num_vertices];
        
        for i in 0..self.num_vertices {
            if !visited[i] && self.has_cycle_util(i, &mut visited, &mut rec_stack) {
                return true;
            }
        }
        false
    }
    
    fn has_cycle_util(&self, vertex: usize, visited: &mut Vec<bool>, rec_stack: &mut Vec<bool>) -> bool {
        visited[vertex] = true;
        rec_stack[vertex] = true;
        
        for &neighbor in &self.adj_list[vertex] {
            if !visited[neighbor] && self.has_cycle_util(neighbor, visited, rec_stack) {
                return true;
            } else if rec_stack[neighbor] {
                return true;
            }
        }
        
        rec_stack[vertex] = false;
        false
    }
}
```

## 4. So s√°nh BFS vs DFS

<div className="overflow-x-auto">
<table className="w-full border-collapse border border-gray-300">
<thead>
<tr className="bg-gray-100">
<th className="border border-gray-300 p-3">Ti√™u ch√≠</th>
<th className="border border-gray-300 p-3">BFS</th>
<th className="border border-gray-300 p-3">DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td className="border border-gray-300 p-3 font-semibold">C·∫•u tr√∫c d·ªØ li·ªáu</td>
<td className="border border-gray-300 p-3">Queue (FIFO)</td>
<td className="border border-gray-300 p-3">Stack/Recursion (LIFO)</td>
</tr>
<tr>
<td className="border border-gray-300 p-3 font-semibold">Th·ª© t·ª± duy·ªát</td>
<td className="border border-gray-300 p-3">Theo t·∫ßng (level-order)</td>
<td className="border border-gray-300 p-3">ƒêi s√¢u tr∆∞·ªõc</td>
</tr>
<tr>
<td className="border border-gray-300 p-3 font-semibold">B·ªô nh·ªõ</td>
<td className="border border-gray-300 p-3">O(W) - W l√† ƒë·ªô r·ªông l·ªõn nh·∫•t</td>
<td className="border border-gray-300 p-3">O(H) - H l√† ƒë·ªô s√¢u l·ªõn nh·∫•t</td>
</tr>
<tr>
<td className="border border-gray-300 p-3 font-semibold">ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t</td>
<td className="border border-gray-300 p-3">‚úÖ T√¨m ƒë∆∞·ª£c (unweighted)</td>
<td className="border border-gray-300 p-3">‚ùå Kh√¥ng ƒë·∫£m b·∫£o</td>
</tr>
<tr>
<td className="border border-gray-300 p-3 font-semibold">Ph√°t hi·ªán chu tr√¨nh</td>
<td className="border border-gray-300 p-3">‚úÖ C√≥ th·ªÉ</td>
<td className="border border-gray-300 p-3">‚úÖ Hi·ªáu qu·∫£ h∆°n</td>
</tr>
</tbody>
</table>
</div>

## 5. ·ª®ng d·ª•ng th·ª±c t·∫ø

### 5.1 BFS Applications

| ·ª®ng d·ª•ng | M√¥ t·∫£ | V√≠ d·ª• |
|----------|-------|-------|
| **Shortest Path** | T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t trong unweighted graph | GPS navigation |
| **Level-order Traversal** | Duy·ªát theo t·∫ßng | Web crawling |
| **Connected Components** | T√¨m th√†nh ph·∫ßn li√™n th√¥ng | Social network analysis |
| **Bipartite Graph** | Ki·ªÉm tra ƒë·ªì th·ªã 2-ph√¢n | Task assignment |

### 5.2 DFS Applications

| ·ª®ng d·ª•ng | M√¥ t·∫£ | V√≠ d·ª• |
|----------|-------|-------|
| **Cycle Detection** | Ph√°t hi·ªán chu tr√¨nh | Deadlock detection |
| **Topological Sort** | S·∫Øp x·∫øp topo | Course scheduling |
| **Strongly Connected Components** | Th√†nh ph·∫ßn li√™n th√¥ng m·∫°nh | Compiler optimization |
| **Path Finding** | T√¨m ƒë∆∞·ªùng ƒëi | Maze solving |

## 6. B√†i t·∫≠p th·ª±c h√†nh

### B√†i t·∫≠p c∆° b·∫£n

```rust
fn main() {
    let mut graph = Graph::new(6);
    
    // X√¢y d·ª±ng ƒë·ªì th·ªã v√≠ d·ª•
    graph.add_edge(0, 1);
    graph.add_edge(0, 2);
    graph.add_edge(1, 3);
    graph.add_edge(2, 4);
    graph.add_edge(3, 5);
    graph.add_edge(4, 5);
    
    println!("BFS traversal: {:?}", graph.bfs(0));
    println!("DFS traversal: {:?}", graph.dfs(0));
    
    if let Some(path) = graph.bfs_shortest_path(0, 5) {
        println!("Shortest path from 0 to 5: {:?}", path);
    }
}
```

## 7. Complexity Analysis

```mermaid
graph LR
    A[Time Complexity] --> B[O(V + E)]
    A --> C[Space Complexity]
    C --> D[BFS: O(V)]
    C --> E[DFS: O(V)]
    
    F[Where:] --> G[V = s·ªë ƒë·ªânh]
    F --> H[E = s·ªë c·∫°nh]
```

<div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
<h4 className="font-semibold text-yellow-800">üí° L∆∞u √Ω quan tr·ªçng:</h4>
<ul className="list-disc list-inside text-yellow-700 mt-2">
<li>BFS ƒë·∫£m b·∫£o t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t trong unweighted graph</li>
<li>DFS hi·ªáu qu·∫£ h∆°n cho vi·ªác ph√°t hi·ªán chu tr√¨nh</li>
<li>C·∫£ hai thu·∫≠t to√°n ƒë·ªÅu c√≥ ƒë·ªô ph·ª©c t·∫°p th·ªùi gian O(V + E)</li>
<li>L·ª±a ch·ªçn thu·∫≠t to√°n ph·ª• thu·ªôc v√†o b√†i to√°n c·ª• th·ªÉ</li>
</ul>
</div>

## 8. B√†i t·∫≠p LeetCode li√™n quan

### Easy Level
- [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) - LC 102
- [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) - LC 101
- [Same Tree](https://leetcode.com/problems/same-tree/) - LC 100

### Medium Level
- [Number of Islands](https://leetcode.com/problems/number-of-islands/) - LC 200
- [Course Schedule](https://leetcode.com/problems/course-schedule/) - LC 207
- [Clone Graph](https://leetcode.com/problems/clone-graph/) - LC 133
- [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/) - LC 417

### Hard Level
- [Word Ladder](https://leetcode.com/problems/word-ladder/) - LC 127
- [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) - LC 269
- [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/) - LC 1091

---

<div className="bg-green-50 border border-green-200 rounded-lg p-4">
<h3 className="text-green-800 font-semibold mb-2">üéØ T√≥m t·∫Øt b√†i h·ªçc</h3>
<ul className="list-disc list-inside text-green-700 space-y-1">
<li>BFS s·ª≠ d·ª•ng Queue, duy·ªát theo t·∫ßng, t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t</li>
<li>DFS s·ª≠ d·ª•ng Stack/Recursion, ƒëi s√¢u tr∆∞·ªõc, hi·ªáu qu·∫£ cho ph√°t hi·ªán chu tr√¨nh</li>
<li>C·∫£ hai ƒë·ªÅu c√≥ ƒë·ªô ph·ª©c t·∫°p O(V + E)</li>
<li>L·ª±a ch·ªçn thu·∫≠t to√°n d·ª±a tr√™n y√™u c·∫ßu b√†i to√°n c·ª• th·ªÉ</li>
</ul>
</div>